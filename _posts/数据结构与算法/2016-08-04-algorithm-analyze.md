---
layout: post
title: 算法基础-插入排序算法的分析
category: 数据结构与算法
tags: 进阶 数据结构与算法 排序
keywords: 蓝桥 lanqiao 教程 数据结构 算法 插入排序
description: 本章介绍分析算法的核心手段。
author: 郑未

---

# 插入排序算法的分析：运行时间是输入规模的函数

过程INSERTION-SORT需要的时间依赖于输入：排序1000个数比排序三个数需要更长的时间。此外，依据它们已被排序的程度，INSERTION-SORT可能需要不同数量的时间来排序两个具有相同规模的输入序列。一般来说，**算法需要的时间与输入的规模同步增长，所以通常把一个程序的运行时间描述成其输入规模的函数**。为此，我们必须更仔细地定义术语“运行时间”和“输入规模”。

输入规模的最佳概念依赖于研究的问题。对许多问题，如排序或计算离散傅里叶变换，最自然的量度是输入中的项数，例如，待排序数组的规模n。对其他许多问题，如两个整数相乘，输入规模的最佳量度是用通常的二进制记号表示输入所需的总位数。有时，用两个数而不是一个数来描述输入规模可能更合适。例如，若某个算法的输入是一个图，则输入规模可以用该图中的顶点数和边数来描述。对于研究的每个问题，我们将指出所使用的输入规模量度。

一个算法在特定输入上的运行时间是指执行的基本操作数或步数。定义“步”的概念以便尽量独立于机器是方便的。目前，让我们采纳以下观点，执行每行伪代码需要常量时间。虽然一行与另一行可能需要不同数量的时间，但是我们假定第i行的每次执行需要时间ci，其中ci是一个常量。这个观点与RAM模型是一致的，并且也反映了伪代码在大多数真实计算机上如何实现。

在下面的讨论中，我们由繁到简地改进INSERTION-SORT运行时间的表达式，最初的公式使用所有语句代价ci，而最终的记号则更加简明、更容易处理，简单得多。这种较简单的记号比较易于用来判定一个算法是否比另一个更有效。

我们首先给出过程INSERTION-SORT中，每条语句的执行时间和执行次数。对j=2，3，…，n，其中n=A.length，假设tj表示对那个值j第5行执行while循环测试的次数。当一个for或while循环按通常的方式（即由于循环头中的测试）退出时，执行测试的次数比执行循环体的次数多1。我们假定注释是不可执行的语句，所以它们不需要时间。

![Alt text](/public/img/algorithm/algorithm-analyze-1.png)

该算法的运行时间是执行每条语句的运行时间之和。需要执行ci步且执行n次的一条语句将贡献cin给总运行时间。为计算在具有n个值的输入上INSERTION-SORT的运行时间Tn］，我们将代价与次数列对应元素之积求和，得：

![Alt text](/public/img/algorithm/algorithm-analyze-2.png)

即使对给定规模的输入，一个算法的运行时间也可能依赖于给定的是该规模下的哪个输入。例如，在INSERTION-SORT中，若输入数组已排好序，则出现最佳情况。这时，对每个j=2，3，…，n，我们发现在第5行，当i取其初值j-1时，有Ai］≤key。从而对j=2，3，…，n，有tj=1，该最佳情况的运行时间为：

T(n)=c1n+c2(n-1)+c4(n-1)+c5(n-1)+c8(n-1)
=(c1+c2+c4+c5+c8)n-(c2+c4+c5+c8)

我们可以把该运行时间表示为an+b，其中常量a和b依赖于语句代价ci。因此，它是n的线性函数。

若输入数组已反向排序，即按递减序排好序，则导致最坏情况。我们必须将每个元素A［j］与整个已排序子数组A［1..j-1］中的每个元素进行比较，所以对j=2，3，…，n，有tj=j。我们发现在最坏情况下，INSERTION-SORT的运行时间为：

![Alt text](/public/img/algorithm/algorithm-analyze-3.png)

我们可以把该最坏情况运行时间表示为an²+bn+c，其中常量a、b和c又依赖于语句代价ci。因此，它是n的二次函数。……**我们往往集中于只求最坏情况运行时间**……

# 增长量级：简化地评估算法的性能

首先，把最坏情况运行时间表示为an2+bn+c，其中常量a、b和c依赖于语句代价ci。这样，我们不但忽略实际的语句代价，而且也忽略抽象的代价ci。

做出一种更简化的抽象：即我们真正感兴趣的运行时间的增长率或增长量级。所以我们只考虑公式中最重要的项（例如，an²），因为当n的值很大时，**低阶项相对来说不太重要**。我们也忽略最重要的项的常系数，因为对大的输入，在确定计算效率时常量因子不如增长率重要。对于插入排序，当我们忽略低阶项和最重要的项的常系数时，只剩下最重要的项中的因子n²。我们记插入排序具有最坏情况运行时间Θ（n²）（读作“theta n平方”）

一个Θ(n²)的算法在最坏情况下比另一个Θ(n³)的算法要运行得更快。

# 练习

## 2.2-1　

用Θ记号表示函数n³/1000-100n²-100n+3。

解：Θ(n³)

## 2.2-2　

考虑排序存储在数组A中的n个数：首先找出A中的最小元素并将其与A[1]中的元素进行交换。接着，找出A中的次最小元素并将其与A[2]中的元素进行交换。对A中前n-1个元素按该方式继续。该算法称为**选择排序算法**，写出其伪代码。该算法维持的循环不变式是什么？为什么它只需要对前n-1个元素，而不是对所有n个元素运行？用Θ记号给出选择排序的最好情况与最坏情况运行时间。

解：

伪代码：

![Alt text](/public/img/algorithm/algorithm-analyze-4.png)


选择排序算法正确性的证明

初始化:i=1,从子数组 A[1..n]里找到最小值 A[ j],并不 A[i]互换,此时子数组 A[1..i]只有 一个元素 A[1],显然是已排序的。

保持:若 A[1..i]是已排序子数组。这里显然 A[1]≤A[2]≤A[3]≤...≤A[i],而 A[i+1..n]里最小 值也必大于 A[i],找出此最小值不 A[i+1]互换并将 A[i+1]插入 A[1..i]得到子数组 A[1..i+1]。 A[1..i+1]显然也是已排序的。

终止:当 i=n 时终止,此时已得到已排序数组 A[1..n-1],而 A[n]是经过 n-1 次比较后剩下 的元素,因此 A[n]大于 A[1..n-1]中任意元素,故数组 A[1..n]也即是原数组此时已是已排序 的。所以,算法正确。

仅需要在头 n-1 个元素上运行是因为经过 n-1 次比较后剩下的是最大元素,其理应排在最后 一个位置上,因此可以不必对此元素进行交换位置操作。

最好最坏情况，其时间复杂度都是Θ(n²)

具体代码请参考：[常见排序算法java版](/ref/sort-java-impl)

## 2.2-3　

再次考虑线性查找问题（参见练习2.1-3）。假定要查找的元素等可能地为数组中的任意元素，平均需要检查输入序列的多少元素？最坏情况又如何呢？用Θ记号给出线性查找的平均情况和最坏情况运行时间。证明你的答案。

答：
平均:n/2 次。因为任意一个元素大于、小于查找数的概率一样。 
最坏:n 次。最后一个元素才是要查找的元素。 
用Θ表示都是:Θ(n)

## 2.2-4　

我们可以如何修改几乎任意算法来使之具有良好的最好情况运行时间？

答：
要使算法具有较好的最佳情况运行时间就一定要对输入进行控制,使之偏向能够使得算法具 有最佳运行情况的排列。

