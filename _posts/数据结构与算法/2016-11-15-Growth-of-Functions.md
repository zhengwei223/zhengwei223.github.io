---
layout: post
title: 算法基础-函数的增长
category: 数据结构与算法
tags: 进阶 数据结构与算法
keywords: 蓝桥 lanqiao 教程 数据结构 算法 函数的增长
description: 当输入规模足够大，使得只有运行时间的增长量级有关时，我们要研究算法的渐进效率。
author: 郑未

---
>当输入规模足够大，使得只有运行时间的增长量级有关时，我们要研究算法的渐进效率。

# 5个渐进记号的定义：

- Θ(g(n))={ f(n): 存在正常数c1,c2和n0，使对所有的n>=n0，有0<=c1g(n)<=f(n)<=c2g(n) }
- O(g(n))={ f(n): 存在正常数c和n0，使对所有n>=n0，有0<=f(n)<=cg(n) }
- Ω(g(n))={ f(n): 存在正常数c和n0，使对所有n>=n0，有0<=cg(n)<=f(n) }
- o(g(n))={ f(n): 对任意正常数c，存在常数n0>0，使对所有的n>=n0，有0<=f(n)<=cg(n) }
- ω(g(n))={ f(n): 对任意正常数c，存在常数n0>0，使对所有的n>=n0，有0<=cg(n)<f(n) }

通常只研究前三种，直白地说：

- f(n)=Ω(g(n))，表示这个算法是有一个渐近下界的，这个渐近下界为g(n)，算法的运行时间f(n)趋近并大于等于这个g(n)。
- f(n)=Θ(g(n))，表示这个算法是有一个渐近确界的，这个渐近确界为g(n)，算法的运行时间f(n)趋近g(n)。
- f(n)=O(g(n))，表示这个算法是有一个渐近上界的，这个渐近上界为g(n)，算法的运行时间f(n)趋近并小于等于这个g(n)。

![Alt text](/public/img/algorithm/growth-of-fun-1.png)

*这种图比较直观，也比较重要*

# 学习建议

算导第三章及算导全书中的数学公式的证明，可以只了解其结论，或者用到的时候再去查、深入，如果要写写论文则需要深入研究。

# 函数增长速度的对比

![Alt text](/public/img/algorithm/growth-of-fun-2.jpg)

*（运行时间的比较）确定时间t内求解的问题的最大规模。*

上面是网上提供的答案。注意点：

1、最左边一列的是关于n的增长情况描述，值得记住的是这些增长的排列顺序，这是非常有用的，啊，数分学好了会很容易；
2、注意1s内能处理的以n为增长量级的规模是10的6次方，记住这个结果可以推导出其他增长量级的处理规模；
3、注意这里的lg指的是以2为底的对数函数。

- n！的弱上界是n^n，因此增长速度非常快，这意味着单位时间内可求解的问题很小，换言之，超慢
- 2^n这样的指数函数增长非常快，这种算法可以认为超慢
- Θ(n²)和Θ(n³)增长很快，算法很慢，至少优化到nlgn，Θ(n²)的有冒泡排序，直接插入排序，选择排序
- nlgn可以认为是及格的算法吧，一般分治法可以缩小层数为lgn，而每层的复杂度一般为Θ(n)，例如**归并排序算法**、**快速排序算法**
- Θ(n)叫做线性算法，这种算法比较优秀，或者问题本身比较简单，比如求连续求和最大子数组的线性解
- Θ(sqrt(n))当然比Θ(n)更快，不是没有，但这种很少
- lgn就是很优秀的算法了，比如二分查找法，但是这种算法往往对输入数据的格式是有要求的，二分查找要求输入数据有序
- 还有一种是常量，无论规模怎么扩大，都花固定时间，这是为数极少的效率最高的算法了。

![Alt text](/public/img/algorithm/growth-of-fun-3.png)

*函数增长速度的直观图示*