---
layout: post
title: 算法基础-分治与递归，归并排序示例
category: 数据结构与算法
tags: 进阶 数据结构与算法 排序
keywords: 蓝桥 lanqiao 教程 数据结构 算法 归并排序算法
description: 本章我们了解分治法的基本设计思路，并学习归并排序算法。本章末尾有7个习题。
author: 郑未

---
# 必备概念

*分治法(divide-and-conquer)*:有很多算法在结构上是递归的:为了解决一个给定的问 题,算法要一次或多次地递归调用其自身来解决相关的问题。这些算法通常采用分治策略: 将原问题划分成 n 个规模较小而结构与原问题相似的子问题;递归地解决这些子问题,然后 再合并其结果,就得到原问题的解。
容易确定运行时间,是分治算法的优点之一。

*分治模式在每一层递归上都有三个步骤*: 分解(Divide):将原问题分解成一系列子问题; 解决(Conquer):递归地解各子问题。若子问题足够小,则直接求解; 合并(Combine):将子问题的结果合并成原问题的解。 

# 归并排序（合并排序）介绍

*合并排序*(Merge Sort)算法完全依照了分治模式。

分解:将 n 个元素分成各含 n/2 个元素的子序列; 解决:用合并排序法对两个子序列递归地排序;合并:合并两个已排序的子序列以得到排序结果。

在对子序列排序时,其长度为 1 时递归结束。单个元素被视为是已排好序的。 合并排序的关键步骤在于合并步骤中的合并两个已排序子序列。为做合并,引入一个辅助过 程 MERGE(A,p,q,r),其中 A 是个数组,p、q 和 r 是下标,满足p ≤ q < 𝑟。该过程假设子数 组 A[p..q]和 A[q+1..r]都已排好序,并将他们合并成一个已排好序的子数组代替当前子数组 A[p..r]。
MERGE 过程的时间代价为Θ(n),其中 n=r-p+1 是待合并的元素个数。


MERGE 过程:

    MERGE(A, p, q, r)

    1　n1 = q - p + 1

    2　n2 = r - q

    3　let L［1..n1 + 1］ and R［1..n2 + 1］ be new arrays

    4　for i = 1 to n1

    5　　　L［i］ = A［p + i - 1］

    6　for j = 1 to n2

    7　　　R［j］ = A［q + j］

    8　L［n1 + 1］ = ∞

    9　R［n2 + 1］ = ∞

    10　i = 1

    11　j = 1

    12　for k = p to r

    13　　　if L［i］ ≤ R［j］

    14　　　　　A［k］ = L［i］

    15　　　　　i = i + 1

    16　　　else A［k］ = R［j］

    17　　　　　j = j + 1

![Alt text](http://lemon.lanqiao.org:8082/teaching/img/algorithm/dcc-1.jpg)


*当子数组A［9..16］包含序列〈2，4，5，7，1，2，3，6〉时，调用MERGE（A，9，12，16）第10～17行的操作。在复制并插入哨兵后，数组L包含〈2，4，5，7，∞〉，数组R包含〈1，2，3，6，∞〉。A中的浅阴影位置包含它们的最终值，L和R中的浅阴影位置包含有待于被复制回A的值。合在一起，浅阴影位置总是包含原来在A［9..16］中的值和两个哨兵。A中的深阴影位置包含将被覆盖的值，L和R中的深阴影位置包含已被复制回A的值。（a）～（h）在第12～17行循环的每次迭代之前，数组A、L和R以及它们各自的下标k、i和j。（i）终止时的数组与下标。这时，A［9..16］中的子数组已排好序，L和R中的两个哨兵是这两个数组中仅有的两个未被复制回A的元素*

过程MERGE的详细工作过程如下：第1行计算子数组A［p..q］的长度n1，第2行计算子数组A［q+1..r］的长度n2。在第3行，我们创建长度分别为n1+1和n2+1的数组L和R（“左”和“右”），每个数组中额外的位置将保存哨兵。第4～5行的for循环将子数组A［p..q］复制到L［1..n1］，第6～7行的for循环将子数组A［q+1..r］复制到R［1..n2］。第8～9行将哨兵放在数组L和R的末尾。第10～17行图示在图2-3中，通过维持以下循环不变式，执行r-p+1个基本步骤：

在开始第12～17行for循环的每次迭代时，子数组A［p..k-1］按从小到大的顺序包含L［1..n1+1］和R［1..n2+1］中的k-p个最小元素。进而，L［i］和R［j］是各自所在数组中未被复制回数组A的最小元素。

我们必须证明第12～17行for循环的第一次迭代之前该循环不变式成立，该循环的每次迭代保持该不变式，并且循环终止时，该不变式提供了一种有用的性质来证明正确性。

初始化：循环的第一次迭代之前，有k=p，所以子数组A［p..k-1］为空。这个空的子数组包含L和R的k-p=0个最小元素。又因为i=j=1，所以L［i］和R［j］都是各自所在数组中未被复制回数组A的最小元素。

保持：为了理解每次迭代都维持循环不变式，首先假设L［i］≤R［j］。这时，L［i］是未被复制回数组A的最小元素。因为A［p..k-1］包含k-p个最小元素，所以在第14行将L［i］复制到A［k］之后，子数组A［p..k］将包含k-p+1个最小元素。增加k的值（在for循环中更新）和i的值（在第15行中）后，为下次迭代重新建立了该循环不变式。反之，若L［i］>R［j］，则第16～17行执行适当的操作来维持该循环不变式。

终止：终止时k=r+1。根据循环不变式，子数组A［p..k-1］就是A［p..r］且按从小到大的顺序包含L［1..n1+1］和R［1..n2+1］中的k-p=r-p+1个最小元素。数组L和R一起包含n1+n2+2=r-p+3个元素。除两个最大的元素以外，其他所有元素都已被复制回数组A，这两个最大的元素就是哨兵。

为了理解过程MERGE的运行时间是Θ（n），其中n=r-p+1，注意到，第1～3行和第8～11行中的每行需要常量时间，第4～7行的for循环需要Θ（n1+n2)=Θ（n）的时间?，并且，第12～17行的for循环有n次迭代，每次迭代需要常量时间。

现在我们可以把过程MERGE作为归并排序算法中的一个子程序来用。下面的过程MERGE-SORT（A，p，r）排序子数组A［p..r］中的元素。若p≥r，则该子数组最多有一个元素，所以已经排好序。否则，分解步骤简单地计算一个下标q，将A［p..r］分成两个子数组A［p..q］和A［q+1..r］，前者包含n/2个元素，后者包含n/2个元素?。
    
    MERGE-SORT(A, p, r)

    1　if p < r

    2　　　q = (p+r)/2

    3　　　MERGE-SORT(A, p, q)

    4　　　MERGE-SORT(A, q+1, r)

    5　　　MERGE(A, p, q, r)

为了排序整个序列A=〈A［1］，A［2］，…，A［n］〉，我们执行初始调用MERGE-SORT（A，1，A.length），这里再次有A.length=n。图2-4自底向上地说明了当n为2的幂时该过程的操作。算法由以下操作组成：合并只含1项的序列对形成长度为2的排好序的序列，合并长度为2的序列对形成长度为4的排好序的序列，依此下去，直到长度为n/2的两个序列被合并最终形成长度为n的排好序的序列。

![Alt text](http://lemon.lanqiao.org:8082/teaching/img/algorithm/dcc-2.png)

*归并排序在数组A=〈5，2，4，7，1，3，2，6〉上的操作。随着算法自底向上地推进，待合并的已排好序的各序列的长度不断增加*

## 递归表达式

当一个算法中含有对其自身的递归调用时,其运行时间可以用一个递归方程(即递归式) 来表示。

归并算法的递归式:

![Alt text](http://lemon.lanqiao.org:8082/teaching/img/algorithm/dcc-3.png)

D(n)是分解该问题所用时间,C(n)是合并解的时间;对于合并排序算法,a 和 b 都是 2 T(n)在最坏的情况下合并排序 n 个数的运行时间分析:

当 n>1 时,将运行时间如下分解:

分解:这一步仅仅算出子数组的中间位置,需要常量时间,因而 D(n)=Θ(1)

解决:递归地解为两个规模为 n/2 的子问题,时间为2T(n/2)

合并:含有 n 个元素的子数组上,MERGE 过程的运行时间为C(n)=Θ(n)

![Alt text](http://lemon.lanqiao.org:8082/teaching/img/algorithm/dcc-4.png)

在所构造的递归树中,顶层总代价为cn(n个点的集合)。往下每层总代价不变,第i层的任一节点代价为c(n/2的i次方)，共2的i次方个节点因此总代价仍然为cn。最底层有n个节点，每个点代价为c。此树共有lgn+1 层,深度为lgn。因此n层的总代价为:

cn*(lgn+1) = Θ(nlgn)

![Alt text](http://lemon.lanqiao.org:8082/teaching/img/algorithm/dcc-5.png)


# 练习

## 2.3-1:

使用图2-4作为模型，说明归并排序在数组A=〈3，41，52，26，38，57，9，49〉上的操作。

略。

## 2.3-2　

重写过程MERGE，使之不使用哨兵，而是一旦数组L或R的所有元素均被复制回A就立刻停止，然后把另一个数组的剩余部分复制回A。
       
具体代码见[归并算法的具体实现](/数据结构与算法/Merge-Sort)

## 2.3-3

使用数学归纳法证明：当n刚好是2的幂时，以下递归式的解是T(n)=nlgn。

![Alt text](http://lemon.lanqiao.org:8082/teaching/img/algorithm/dcc-6.png)

![Alt text](http://lemon.lanqiao.org:8082/teaching/img/algorithm/dcc-7.png)

## 2.3-4　

我们可以把插入排序表示为如下的一个递归过程。为了排序A［1..n］，我们递归地排序A［1..n-1］，然后把A［n］插入已排序的数组A［1..n-1］。为插入排序的这个递归版本的最坏情况运行时间写一个递归式。

解：

![Alt text](http://lemon.lanqiao.org:8082/teaching/img/algorithm/dcc-8.png)

递归式：

T(n) = 1,当n=1，1个元素无需排序
T(n) = T(n-1)+(n-2) = T(n-1)+Θ(n)，当n>1，最坏情况，在合并时待插入元素和有序数组的每个元素进行比较并交换

这种递归的规模是线性缩小而不是呈指数规模缩小，所以递归层为n,每层时间消耗为Θ(n)，整体复杂度还是Θ(n²)

## 2.3-5　**二分查找**

回顾查找问题（参见练习2.1-3），注意到，如果序列A已排好序，就可以将该序列的中点与v进行比较。根据比较的结果，原序列中有一半就可以不用再做进一步的考虑了。二分查找算法重复这个过程，每次都将序列剩余部分的规模减半。为二分查找写出迭代或递归的伪代码。证明：二分查找的最坏情况运行时间为Θ（lgn）。

解：
伪代码（循环模式）：

![Alt text](http://lemon.lanqiao.org:8082/teaching/img/algorithm/dcc-9.png)

伪代码（递归模式）：

![Alt text](http://lemon.lanqiao.org:8082/teaching/img/algorithm/dcc-10.png)

Java代码（循环模式）：

    import java.util.*;
    public class BinarySearch
    {

      private static int binarySearch0(int[] a, int fromIndex, int toIndex,
        int key)
      {
       int low = fromIndex;
       int high = toIndex - 1;

       while (low <= high)
       {
        int mid = (low + high) >>> 1;
        int midVal = a[mid];

        if (midVal < key)
         low = mid + 1;
       else if (midVal > key)
         high = mid - 1;
       else
         return mid; // key found
     }
       return -(low + 1); // key not found.
     }

     public static void main(String[] args)
     {
       int[] x =
       { 49, 38, 65, 97, 76, 13, 27, 12, 18, 54, 20, 9, 8, 5, 6 };
       System.out.println("begin..." + Arrays.toString(x));

       MergeSort.sort(x, 0, x.length-1);
       System.out.println("final..." + Arrays.toString(x));
       int index = binarySearch0(x, 0, x.length - 1, 27);
       System.out.println(index);
     }
    }

### 复杂度

递归式：T(n) = T(n/2)+Θ(1)，分解会直接丢弃一半的规模，每层递归中只有简单的比较，时间为常数，最坏lgn层，因此最坏情况复杂度为Θ(lgn)，这比线性查找要快。

## 2.3-6　

注意到INSERTION-SORT（插入排序）的第5～7行的while循环采用一种线性查找来（反向）扫描已排好序的子数组A［1..j-1］。我们可以使用二分查找（参见练习2.3-5）来把插入排序的最坏情况总运行时间改进到Θ（nlgn）吗？

见[2.3-6](http://blog.csdn.net/newdye/article/details/8901011)和[2.3-6+](http://mushiqianmeng.blog.51cto.com/3970029/732333/)

## *2.3-7　

描述一个运行时间为Θ（nlgn）的算法，给定n个整数的集合S和另一个整数x，该算法能确定S中是否存在两个其和刚好为x的元素。

[*2.3-7](http://mushiqianmeng.blog.51cto.com/3970029/732739)
