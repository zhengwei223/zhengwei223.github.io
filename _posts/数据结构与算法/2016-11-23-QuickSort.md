---
layout: post
title: 排序专题——快速排序
category: 数据结构与算法
tags: 进阶 数据结构与算法
keywords: 蓝桥 lanqiao 教程 数据结构 算法 快速排序
description: 这一章我们要掌握著名的快速排序算法，以及了解为什么它比较快（比堆排序还要快）
author: 郑未
---

# 算法描述

分治法：

1、分解：数组A[p..r]被划分为两个子数组A[p..q-1]和A[q+1,r]，使得A[q]为大小居中的数，左侧A[p..q-1]中的每个元素都小于等于它，而右侧A[q+1,r]中的每个元素都大于等于它。其中计算下标q也是划分过程的一部分。

2、解决：通过递归调用快速排序，对子数组A[p..q-1]和A[q+1,r]进行排序

3、合并：因为子数组都是原址排序的，所以不需要合并，数组A[p..r]已经有序

    QuickSort(A,p,r)
      if p<r
        q=Partition(A,p,r)
        QuickSort(A,p,q-1)
        QuickSort(A,q+1,r)

# Partition算法

它的任务是①定义一个中心点（枢轴）②把中心点放在数组中的某个位置（一般不是原位置），使得以中心点为分界，把小于它的数放置在左边，把大于它的数放在右边③返回中心点最终在数组中的位置；

因为数组一开始是无序的，这意味着我们要不断调整元素的位置，才能完成上述的任务。

下面是一个头尾双指针往中间扫描的分区算法：

    Partition(A,p,r)
      pivot = A[p] //设中心点为第一个元素
      
      while(p<r)
        while(p<r && arr[r]>=pivot) r--; // 从右侧寻找更小的
        arr[p] = arr[r]  // 小的往左侧已确认部分的边界上调
        while(p<r && arr[p]<=pivot) p++; // 从左侧寻找更大的
        arr[r] = arr[p]  // 大的往右侧已确认部分的边界上调
      arr[p] = pivot
      return p

这里没有用到swap函数，但也有swap过程。
该算法比较简洁精妙，需要好好品味一下。Partition算法的时间复杂度为Θ(n)，因为它对每个元素只扫描一次。

# 性能分析

## 最坏的划分

如果每次划分都是n-1个元素和0个元素进行递归，即每次partition得到的中心点都是第一个元素，那时间度是线性级数，为Θ(n²)。

## 最好的划分

每次子问题的规模都是n/2，那么其时间复杂度为Θ(n²)

## 平衡划分

快排的平均运行时间更接近于其最好情况。


# 随机化版本

每次随机抽取一个元素作为主元（中心点），只需对partition函数做小小的改动即可：

    i = RANDOM(p,r)
    exchange A[p] with A[i]  // 将随机抽取的主元放到首位

#三数取中划分

# 对于规模的优化

当输入数据几乎有序时，插入排序速度很快。可以这样利用这一特点，当对于一个长度小于k的子数组调用快速排序时，直接返回。当上层的快速排序调用返回后，对整个数组运行插入排序来完成排序过程。这一排序算法的期望时间复杂度为O(nk+nlg(n/k))。

# 有相同元素值的快速排序——三分法

# partition的别用——寻找第K大的数

