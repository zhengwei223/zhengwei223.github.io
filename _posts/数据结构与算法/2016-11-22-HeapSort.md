---
layout: post
title: 排序专题——堆与堆排序
category: 数据结构与算法
tags: 进阶 数据结构与算法
keywords: 蓝桥 lanqiao 教程 数据结构 算法 堆排序
description: 这一章我们要掌握堆排序，这是一个依赖于二叉树这种数据结构的算法。
author: 郑未
---

> 排序小结

我们已经掌握了插入排序、冒泡排序、选择排序，他们都是低效排序算法Θ(n^2)，还有归并排序，利用分治递归的手段，以空间换时间，将复杂度降低为Θ(nlgn).

今天，我们要讲堆排序。


# 数组可以看做树，树是一种逻辑结构

![堆的存储](http://lemon.lanqiao.org:8082/teaching/img/algorithm/heap-1.gif)

a[0]就是根节点，假设树的宽度为2（二叉树），它的子节点就是a[1]和a[2]……以此类推：

i结点的父结点下标就为`(i – 1) / 2`。它的左右子结点下标分别为`2 * i + 1`和`2 * i + 2`。

# 堆（二叉堆）是特殊的二叉树

我们这里说的堆，专指二叉堆：

二叉堆是完全二叉树或者是近似完全二叉树。

二叉堆满足二个特性：

1．父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。

2．每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。

当父结点的键值总是大于或等于任何一个子节点的键值时为最大堆。当父结点的键值总是小于或等于任何一个子节点的键值时为最小堆。下图展示一个最小堆：

![最小堆](http://lemon.lanqiao.org:8082/teaching/img/algorithm/heap-2.gif)

# 让数组（二叉树）满足堆的性质——构造堆/堆化

![](http://lemon.lanqiao.org:8082/teaching/img/algorithm/heap-3.gif)

很明显，对叶子结点来说，可以认为它已经是一个合法的堆了即20，60， 65， 4， 49都分别是一个合法的堆。只要从A[4]=50开始向下调整就可以了。然后再取A[3]=30，A[2] = 17，A[1] = 12，A[0] = 9分别作一次向下调整操作就可以了。下图展示了这些步骤：

伪代码：

    MakeMinHeap(a[0...n-1])
      for i=n/2-1 down to 0   // 这些节点的子树已经是合法的最小堆
        MinHeapFixDown(a,i,n)
    
    // 假设某个节点的左右子树分别满足最小堆，现在检测整体是否满足
    // 如果该节点不满足，向下沉，将它的最小子节点上浮
    MinHeapFixDown(a[0...n-1],i,length)
      j=2*i+1,  // 左孩子
      temp=a[i]
      while(j<length)
        if j+1<length&&a[j+1]>a[j])  // 在左右孩子中找最小的  
          j++  // 小孩子
        if a[j]<temp  // 小孩子比自己还小，则小孩子上浮
          a[i]=a[j]
          i = j  // 站到小孩子的位置，大孩子那边可以不管了（没有变动）
          j = 2*i+1  // 指向小孩子的左孩子
        else
          break
      // 循环走完，i的位置就是temp应该放置的位置    
      a[i]=temp  

# 在堆中新增元素

我们规定，新增元素必须先放到最末尾，放置之后可能破坏堆得性质，因此要进行调整：与父节点比较，如果自己更大，无需调整，如果自己更小则上浮，然后继续向上比较；其实这个过程是新增节点插入到一个已经有序的序列的过程——这个新数据的父结点到根结点必然为一个有序的数列，现在的任务是将这个新数据插入到这个有序数据中——这就类似于直接插入排序中将一个数据并入到有序区间中。

伪代码：

    //  新加入结点  其父结点为(n - 1) / 2  
    MinHeapFixup(a[0...n-1],v)  
      a[n] = v  // 扩展数组
      cur = n     // 当前节点
      par = (cur-1)/2  // 父节点
      while(cur > 0)
        if(a[par]>v)
          a[cur] = a[par]
          cur = par
          par = (cur-1)/2
        else
          break
      a[cur] = v

# 删除元素

按定义，堆中每次都只能删除第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点将一个数据的“下沉”过程。下面给出代码：

    MinHeapDeleteNumber(a[0...n-1])
      a[0] = a[n-1]  // 将最后一个元素放到堆顶
      a = a[0...n-2]  // 删除最后一个元素
      MinHeapFixDown(a,0,n-1)  // 对根节点进行向下调整

# 堆排序

首先可以看到堆建好之后堆中第0个数据是堆中最小的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最小的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。

由于堆也是用数组模拟的，故堆化数组后，第一次将A[0]与A[n - 1]交换，再对A[0…n-2]重新恢复堆。第二次将A[0]与A[n – 2]交换，再对A[0…n - 3]重新恢复堆，重复这样的操作直到A[0]与A[1]交换。由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了。

    MinHeapSortToDescendArray(int a[], int n)  
    {  
        for (int i = n - 1; i >= 1; i--)  
        {  
            Swap(a[i], a[0]);  
            MinHeapFixdown(a, 0, i);  
        }  
    }  

注意使用最小堆排序后是递减数组，要得到递增数组，可以使用最大堆。

由于每次重新恢复堆的时间复杂度为O(logN)，共N - 1次重新恢复堆操作，再加上前面建立堆时N / 2次向下调整，每次调整时间复杂度也为O(logN)。二次操作时间相加还是O(N * logN)。故堆排序的时间复杂度为O(N * logN)。
