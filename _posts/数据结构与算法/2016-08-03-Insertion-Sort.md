---
layout: post
title: 算法基础-插入排序算法
category: 数据结构与算法
tags: 进阶 数据结构与算法 排序
keywords: 蓝桥 lanqiao 教程 数据结构 算法 插入排序
description: 插入排序算法是算法入门的起手式。本章末尾有4个习题。
author: 郑未

---

# 问题：

输入：n个数的一个序列〈a1,a2,…,an〉。

输出：输入序列的一个排列〈a′1,a′2,…,a′n〉，满足a′1 ≤ a′2 ≤ … ≤a′n。

# 思路

插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较，如图所示。拿在左手上的牌总是排序好的，原来这些牌是桌子上牌堆中顶部的牌。

![Alt text](http://lemon.lanqiao.org:8082/teaching/img/algorithm/insertion-1.png)

#伪代码

    INSERTION-SORT(A)
    1　for j = 2 to A.length
    2　　key = A［j］
    3　　// Insert A［j］ into the sorted sequence A［1..j - 1］.
    4　　i = j - 1
    5　　while i > 0 and A［i］ > key
    6　　　　A［i+1］ = A［i］
    7　　　　i = i - 1
    8　　A［i + 1］ = key

# 循环不变式

关于循环不变式，我们必须证明三条性质：

初始化：循环的第一次迭代之前，它为真。

保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。

终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的。

当前两条性质成立时，在循环的每次迭代之前循环不变式为真。（当然，为了证明循环不变式在每次迭代之前保持为真，我们完全可以使用不同于循环不变式本身的其他已证实的事实。）注意，这类似于数学归纳法，其中为了证明某条性质成立，需要证明一个基本情况和一个归纳步。这里，证明第一次迭代之前不变式成立对应于基本情况，证明从一次迭代到下一次迭代不变式成立对应于归纳步。

第三条性质也许是最重要的，因为我们将使用循环不变式来证明正确性。通常，我们和导致循环终止的条件一起使用循环不变式。终止性不同于我们通常使用数学归纳法的做法，在归纳法中，归纳步是无限地使用的，这里当循环终止时，停止“归纳”。

让我们看看对于插入排序，如何证明这些性质成立。

# 插入排序的循环不变性质

初始化：首先证明在第一次循环迭代之前（当j=2时），循环不变式成立?。所以子数组A［1..j-1］仅由单个元素A［1］组成，实际上就是A［1］中原来的元素。而且该子数组是排序好的（当然很平凡）。这表明第一次循环迭代之前循环不变式成立。

保持：其次处理第二条性质：证明每次迭代保持循环不变式。非形式化地，for循环体的第4～7行将A［j-1］、A［j-2］、A［j-3］等向右移动一个位置，直到找到A［j］的适当位置，第8行将A［j］的值插入该位置。这时子数组A［1..j］由原来在A［1..j］中的元素组成，但已按序排列。那么对for循环的下一次迭代增加j将保持循环不变式。

第二条性质的一种更形式化的处理要求我们对第5～7行的while循环给出并证明一个循环不变式。然而，这里我们不愿陷入形式主义的困境，而是依赖以上非形式化的分析来证明第二条性质对外层循环成立。

终止：最后研究在循环终止时发生了什么。导致for循环终止的条件是j>A.length=n。因为每次循环迭代j增加1，那么必有j=n+1。在循环不变式的表述中将j用n+1代替，我们有：子数组A［1..n］由原来在A［1..n］中的元素组成，但已按序排列。注意到，子数组A［1..n］就是整个数组，我们推断出整个数组已排序。因此算法正确。

# Java实现

    import java.util.*;
    /**
    插入排序算法
    */
    public class InsertionSort{
      static void sort(int[] arr){
        sort(arr,0,arr.length-1);
      }
      static void sort(int[] arr,int left,int right){
        for (int j = left+1; j<=right ; j++) {
          int key = arr[j];
          int i = j - 1;
          while(i>=left&&arr[i]>key){
            arr[i+1] = arr[i];
            i--;
          }
          arr[i+1] = key;
        }
      }
      public static void main(String[] args) {
        int[] arr = {1,2,6,4,5,3};
        sort(arr);
        System.out.println(Arrays.toString(arr));
      }
    }

# 习题（算法导论）

## 2.1-1

以图 2-2 为模型,说明 INSERTION-SORT 在数组 A=<31,41,59,26,41,58>上的 执行过程。

![Alt text](http://lemon.lanqiao.org:8082/teaching/img/algorithm/insertion-2.jpg)

## 2.1-2　

重写过程INSERTION-SORT，使之按非升序（而不是非降序）排序。
    
    // 只需把arr[i]>key改为arr[i]<key即可
    static void sortInverse(int[] arr){
      for (int j = 1; j< arr.length ; j++) {
        int key = arr[j];
        int i = j - 1;
        while(i>=0&&arr[i]<key){
          arr[i+1] = arr[i];
          i--;
        }
        arr[i+1] = key;
      }
    }

## 2.1-3

考虑下面的查找问题:
输入:一列数 A=<a1 ,a2,...,an >和一个值 v
输出:下标 i,使得 v=A[i],戒者当 v 丌在 A 中出现时为 NIL。
写出针对这个问题的现行查找的伪代码,它顺序地扫描整个序列以查找 v。利用循 环不变式证明算法的正确性。确保所给出的循环丌变式满足三个必要的性质。

    LINEAR-SEARCH(A,v)
    1   for i ← 1  to length[A]
    2     if v=A[i]
    3       return i
    4   return NIL

线性查找算法正确性的证明：

初始化： i=1，子数组为 A[1..i]，只有一个元素 A[1],如果 v=A[1]就返回 1,否则返回 NIL， 算法显然是正确的。

保持：若算法对数组 A[1..i]正确，则在数组增加一个元素  A[i+1]时，只需要多作一次比较， 因此显然对 A[1..i+1]也正确。

终止：算法如果在非最坏情况下定能返回一个值此时查找成功，如果 n 次查找（遍历了所有
的数）都没有成功，则返回 NIL。算法在有限次查找后肯定能够给出一个返回值，要么说明 查找成功并给出下标，要么说明无此值。因此算法正确。

## 2.1-4

有两个各存放在数组 A 和 B 中的 n 位二进制整数,考虑它们的相加问题。两个整数 的和以二进制形式存放在具有(n+1)个元素的数组 C 中。请给出这个问题的形式化描述,并 写出伪代码。

A 存放了一个二进制 n 位整数的各位数值,B 存放了另一个同样是二进制 n 位整数的各位上 的数值,现在通过二进制的加法对这两个数进行计算,结果以二进制形式把各位上的数值存 放在数组 C(n+1 位)中。

    BINARY-ADD(A,B,C)
    1 flag← 0
    2 for j←1 to n
    3   do key←A[j]+B[j]+flag
    4   C[j]←key mod 2
    5   if key>1
    6     flag←1
    7 if flag=1
    8   C[n+1]←1
