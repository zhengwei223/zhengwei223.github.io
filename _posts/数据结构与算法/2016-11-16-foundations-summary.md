---
layout: post
title: 算法基础-总结与补充
category: 数据结构与算法
tags: 进阶 数据结构与算法
keywords: 蓝桥 lanqiao 教程 数据结构 算法 函数的增长
description: 当输入规模足够大，使得只有运行时间的增长量级有关时，我们要研究算法的渐进效率。
author: 郑未

---

# 一 规模与算法

## 1.细算时间消耗

插入排序最坏情况：(n-1)+(n-2)+...+1 = ½n(n-1)，虽然是∈Θ(n²)但是和n²还是有区别的。

我们要注意的就是高阶项前面的常数因子。

归并排序最坏情况：=2n(lgn+1)∈Θ(nlgn)。

我们可以考虑下，在n比较小的时候，插入排序其实时间消耗是＜归并排序的，也就是求k使得

½k(k-1)<2k(lgk+1)，依次带入2的多次幂可以推断k=16时，左边小于右边，k=32时左边大于右边。

不精确地说：问题规模在16以内，用插入排序其实更快，但16及以上问题规模越大，插入排序与归并排序的差别越大。

## 2.算导思考题2.1：归并一定优于插入？

（在归并排序中对小数组采用插入排序）　虽然归并排序的最坏情况运行时间为Θ（nlgn），而插入排序的最坏情况运行时间为Θ（n2），但是插入排序中的常量因子可能使得它在n较小时，在许多机器上实际运行得更快。因此，在归并排序中当子问题变得足够小时，采用插入排序来使递归的叶变粗是有意义的。考虑对归并排序的一种修改，其中使用插入排序来排序**长度为k的n/k个子表**，然后使用标准的合并机制来合并这些子表，这里k是一个待定的值。

a.证明：插入排序最坏情况可以在Θ(nk)时间内排序每个长度为k的n/k个子表。

*长度为k的数组插入排序消耗：½k(k+1),这样的数组有n/k个，二者相乘得：½n(k+1)∈Θ(nk)*

b.表明在最坏情况下如何在Θ(nlg(n/k))时间内合并这些子表。

*某层的每个子数组有序时，单层的合并需要n个时间单位（每个元素都要抓一次），那么有多少层呢？可以考虑递归树的叶子节点个数为n/k因此层数为lg(n/k)+1，所以整体的复杂度为n(lg(n/k)+1)∈Θ(nlg(n/k))*

![Alt text](/public/img/algorithm/summary-1-1)

这是标准的归并算法的merge的过程。最后求出标准归并算法的时间复杂度时，是用层高 乘以 每层的代价。 
其实本题所求代价也用层高 乘以 每层的代价，只是层高没有那么高，因为当到子数组的规模到了n/k的时候，此时的层高应为log(n/k) + 1。故总代价为：(lg(n/k)+1) * n ，即为：θ(nlg(n/k))

c.求k得最大渐进函数，使得修改后的算法的最坏情况运行时间即Θ(nk+nlg(n/k))与标准的归并排序具有相同的运行时间，用Θ表示。

排序时间：½n(k+1)

合并时间：n(lg(n/k)+1)

二者相加为总时间∈Θ(nk+nlg(n/k))，要想这个函数趋近nlgn，k=lgn时，k>lg(n/k)带入为lgn>lg(n/lgn)当lgn>1时这是显然的，此时Θ(nk+nlg(n/k))∈Θ(nlgn)

网上参考：

我解答的过程是首先感受代了几个值感受了一下，

- 当 k = 1 时，θ(nk + n lg(n/k)) = θ(n+ n lgn) = θ(n lgn)，此时和归并算法的时间复杂度一样，但是k取得是最小值。
- 当 k = n/2 时，θ(nk + n lg(n/k)) = θ((n^2)/2+ n lg2)= θ(n^2)，此时为θ(n^2)，大于了归并算法。

很容易发现关键就是k和lgn之间的大小关系，则让 k = θ(lgn) （题中要求用θ符号），则可得时间复杂度：θ(nk + n lg(n/k)) = θ(n lgn + n lg (n/lgn)) =θ(n lgn)（其中 lg(n/lgn) < lgn）。 
故最终答案：k = θ(lgn)

参考：[stack overflow](http://stackoverflow.com/questions/21135163/insertion-sort-for-small-subarrays-in-mergesort)

d.在实践中，我们应该如何选择k？

解答可以参考：[stack overflow ](http://stackoverflow.com/questions/21135163/insertion-sort-for-small-subarrays-in-mergesort)

一段论述比较重要： 
k的取值应该恰好是使 插入算法 比 归并算法 快的最大值。而这个值显然是只和插入算法和归并算法的常量相关，不与输入规模n相关。

还有一段引用比较重要： 

According to the Algorithms (4th edition) book written by Robert Sedgewick and Kevin Wayne

>Switching to insertion sort for small subarrays (length 15 or less, say) will improve the running time of a typical mergesort implementation by 10 to 15 percent.

参考前一小节推论，k为16及以下时，插入排序性能比归并排序性能高出10-15个百分点。

## 3.改进的归并排序（小规模用插入排序）

    static void sortUseInsertion(int[] arr,int p,int r){
      if (p <r) {
        int q = (r+p)/2;
        if(r-p+1<=16){  // 个数小于16 不再递归,使用插入法进行排序
          InsertionSort.sort(arr,p,r);
        }else{
          sort(arr,p,q);
          // System.out.println("left..." + Arrays.toString(arr));
          sort(arr,q+1,r);
          // System.out.println("right..." + Arrays.toString(arr));
          merge(arr,p,q,r);
        }
      }
    }

## 4.大规模问题，还是只看高阶

前面已经解释比较清楚，这里只是再提醒一下大家。

# 二 算法可以组合

## 算导2.3-6：尝试用二分查找改进插入排序

问：
是否可以用二分查找法把插入排序最坏条件下运行时间改善到 Θ(nlgn)？——
a[j+1]往前面的子数组a[0...j]插入时，a[0...j]已经有序，可否使用二分查找法先给a[j+1]定位，这样a[j+1]比较次数就会减少，这是否能将插入算法改进到Θ(nlgn)？

解：可能会好一点，因为a[j+1]不用再一个个比较，节约了比较时间，但插入所引起的元素移动次数还是没变，在内层循环的时间消耗可能能缩小到Θ(lgj+j)，这对总上确界没有影响：

数组排序中影响时间复杂度的因素有两个，一个是寻找位置时的比较，一个是找到位置后插入操作引起的元素移动。

## 算导2.3-7：先排序后查找（确认数组中是否存在两个数的和为X）

题目：

请给出一个运行时间为 Θ(nlgn)的 算法，使之能在给定一个由n个整数构成的集合S和另一个整数x时，判断S中是否存在有两 个其和为x的元素。

这个问题有两个切入点：

1、 Θ(nlgn)，咦？好熟悉 
2、给定和S，那就是对某个数C在集合里找S−C，乱序不好弄啊

考虑到这两点，就有如下思路：
1、先排序，归并法为Θ(nlgn);
2、对每个元素a[i]，用二分法在序列中搜索S-a[i]，总体为Θ(nlgn)

两个Θ(nlgn)还是Θ(nlgn)。

具体代码，大家可以写写。


# 三 分治与递归不是万能药

> 有时有效，有时只是换一种写法而已

## 算导2.3-4：递归并没有什么用

### 题目：

插入排序可以如下改写成一个递归过程：为排序A[1...n]，先递归地排序A[1...n−1]，然后再将A[n]插入到已排序的数组中去。对于插入排序的这一递归版本，为他的运行时间写一个递归式：

### 解答:

    T(n)={
      Θ(1)        如果 n=1
      T(n−1)+Θ(n) 其他.

这里的 Θ(n) 实际上就是数组的插入操作，因为要移动后面的元素，也可以写成：C(n−1)

### 分析：

请考虑这个算法的时间复杂性，是不是比之前的做法更优？——实际上，这并没有什么用，只是换了一种写法而已。这个算法仍然是Θ(n²)；

作为递归的练习，你可以尝试自己写写代码！

## 求斐波那契数列第n项的值

### 伪代码：

    Fibonacci(n)
      if n==0  return 0
      if n==1  return 1
      return Fibonacci(n-1)+Fibonacci(n-2)

### java代码

    public static int get(int n){
      if (n==0) {
        return 0;
      }
      if (n==1) {
        return 1;
      }
      return get(n-1)+get(n-2);
    }

### 分析：简单的递归解法就是一个坑

上述的伪代码和真实代码看起来都很简洁，貌似用递归找到了一种解法，但请问它有没有明显可以改进的性能问题？

求解斐波那契数列当中的n=5时的值这个问题的递归树如下图所示：

![Alt text](/public/img/algorithm/summary-1-2.png)

可见递归算法由于会多次计算同样的子问题而出现效率低下的问题

### 改进

    Fibonacci(a[0...n+1],n)
      if n==0  
        a[0] = 0
        return 0
      if n==1  
        a[1] = 1
        return 1
      if a[n]>0
        return a[n]
      a[n] = Fibonacci(n-1)+Fibonacci(n-2)
      return a[n]

这次改进，我们把运算过的第i项保存在一个数组中，下次用到的时候直接返回，避免重复计算。


### 不用递归

    Fibonacci(n)
      p1 = 0
      p2 = 1
      if n==0  
        return 0
      if n==1  
        return 1
      for i=2 to n 
        sum = p1+p2
        p1=p2
        p2=sum
      return sum  

这样也是可以的，复杂度是线性的Θ(n)

## 递归求阶乘？

### 递归伪代码

    Factorial(n)
      if n==1 return 1
      return n*Factorial(n-1)

  类似地，这里使用递归并非分治法，递归成了一种代码组织方式，对算法的性能并没有提高（但也没有斐波那契递归法那样的影响性能的问题）。

  作为练习，请写出求n的阶乘的递归和非递归代码。

## 有效缩小规模（指数级缩小或丢弃一半的规模）

> 像归并那样可以有效缩小规模，每个子问题是父问题规模的一半，合并子问题所消耗的时间是线性的，这种情况可以有效将算法改进为nlgn;
> 像二分查找法那样，不仅每次将问题规模缩小一半，而且直接丢弃掉另一半，无需合并，这种情况可以有效地将算法改进为lgn


暂时我们将这两种情况作为思考算法复杂度的基准，当我们学习了递归式求解之后，你几乎可以一眼看出某递归算法的时间复杂度。

思考：假设有某种三分法，将问题规模缩小为⅓，同时另外的⅔可以直接丢弃，无需合并，这种情况算法的时间复杂度是什么？


# 四 补充：冒泡排序算法及其他思考题

## 最简单最低效的排序

冒泡法直观，因此感觉上很简单，但是它却是很低效的算法，请根据下面伪代码①写出实际代码②用循环不变式证明算法是正确的③计算该算法的复杂度：

    BubbleSort(a[0...n-1])
      for i=0 to n-1
        for j=n-1 downto i+1
          if a[j]<a[j-1]
            swap(a[j],a[j-1]) // 交换

### 一点点改进

思路：如果内层循环一次交换也没有发生，那就说明数组当前已经有序了，就可以停止排序了
    
    BubbleSort(a[0...n-1])
      for i=0 to n-1
        flag = true
        for j=n-1 downto i+1
          if a[j]<a[j-1]
            flag = false
            swap(a[j],a[j-1]) // 交换
        if flag
          break

## 其他思考题

[算法导论 思考题 2-3 霍纳规则的正确性](http://blog.csdn.net/zslomo/article/details/51175422)

[算法导论 思考题 2-4 求逆序对数目](http://blog.csdn.net/zslomo/article/details/51175628)



