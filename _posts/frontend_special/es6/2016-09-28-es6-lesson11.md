---
layout: post
title: ES6(ES2015)-lesson11
category: es6
tags: es6 es2015
author: 郑未
keywords: lanqiao 蓝桥 培训 教程 前端 es6 es2015
description: 本章主要介绍①二进制和八进制字面量②Promises 对象，其中Promise是本章重重点
---

>内容提要

- 二进制和八进制字面量
- Promises 对象：所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件的结果，结果分为肯定结果和否定结果。该对象用于异步编程非常方便。

# 二进制和八进制字面量

加入对二进制(b)和八进制(o)字面量的支持。

    0b111110111 === 503 // true
    0o767       === 503 // true

# Promises 对象

## 概述

所谓Promise，简单说就是一个容器，里面保存着某个**未来才会结束的事件**的结果，结果分为肯定结果和否定结果。

## 构造语法

    new Promise(executor);
    new Promise(function(resolve, reject) { ... });

参数

**executor**

带有`resolve`、`reject`两个参数的一个函数。这个函数在创建Promise对象的时候会立即得到执行（在Promise构造函数返回Promise对象之前就会被执行），并把成功回调函数（`resolve`）和失败回调函数（`reject`）作为参数传递进来。

调用成功回调函数（`resolve`）和失败回调函数（`reject`）会分别触发promise的成功或失败，它们可以用来保存肯定结果或者否定结果。

这个函数通常被用来执行一些异步操作，操作完成以后可以选择调用成功回调函数（`resolve`）来触发promise的成功状态，或者，在出现错误的时候调用失败回调函数（`reject`）来触发promise的失败。

## 示例1：基本使用

[lesson11-1.js](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson11-1.js)

    var p1 = new Promise(function(resolve,reject){
        resolve('这是一个未来会被使用的值');
    });

    p1.then(function(val){
        console.log(val); //这是一个未来会被使用的值
    });

解读：

- 我们首先创建了一个Promise对象，传入构造器的executor函数将会被立即执行，我们选择调用“成功回调函数`resolve`”，这个函数只负责保存“未来被使用的肯定结果——一个字符串”，但它并不知道该值会被怎么使用。
- `p1`是Promise的实例，`then`的第一个回调函数的参数就是`p1`的肯定结果。

## 示例2：reject及Promise实例的状态

[lesson11-2.js](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson11-2.js)

    var p1 = new Promise(function(resolve,reject){
        resolve('这是一个未来会被使用的值');//试试注释此行
        reject('出现错误，被保存的值');
    });

    p1.then(
        function(val){
            console.log(val); //这是一个未来会被使用的值
        },
        function(val){
            console.log(val);
        }
    );

此例的输出和上例一致，但我们注释掉第二行，输出结果是`出现错误，被保存的值`。此例体现以下结论：

- `resolve`触发成功状态，`reject`触发失败状态，它们都保存一个供未来（`then`）使用的结果。
- `resolve`保存的值（称为肯定结果）供`then`的第一个回调函数使用，`reject`保存的值（称为否定结果）供`then`的第二个回调函数使用。
- `resolve`和`reject`互斥，任其一发生后，Promise实例的状态就确认了。

### Promise实例的状态

- *pending*: 初始状态, 既不是 fulfilled 也不是 rejected
- *fulfilled*: 成功的操作，`resolve`触发
- *rejected*: 失败的操作，`reject`触发

## 示例3：Promise的catch方法

[lesson11-3.js](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson11-3.js)

    var p1 = new Promise(function(resolve,reject){
        reject('出现错误，被保存的值');
    });

    p1.then(
        val=> console.log(val)
    ).catch(
        val=> console.log(val)
    );

要取得否定结果可以用`Promise.prototype.then(onFulfilled, onRejected)`也可以用`Promise.prototype.catch(onRejected)`。

## 示例4：返回值与链式调用

[lesson11-4.js](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson11-4.js)

`then`和`catch`都返回一个新的Promise实例，因此可以进行链式调用：

    //4 链式
    var p1 = new Promise(function(resolve,reject){
        resolve(1); //1
    });

    p1.then(
        val=> val*2   //return 2
    ).then(
        val=> val*2   //return 4
    ).then(
        val=> console.log(val)
    );

输出结果为4，此例体现以下结论：

- 每次`then`都返回一个新的Promise实例
- 新的Promise实例以上次`then`回调函数的返回值作为肯定结果
- 如果`then`没有返回值，Promise新实例沿用原有的结果

## 示例5：jquery-ajax对Promise的支持

日常开发常常会遇到的需求：在多个接口异步请求数据，然后利用这些数据来进行一系列的操作。一般会这样去写：

    $.ajax({
        url: '......',
        success: function (data) {
            $.ajax({
                // 要在第一个请求成功后才可以执行下一步
                url: '......',
                success: function (data) {
                     // ......
                }
            });
        }
    });

这样的写法的原理是，当执行一些异步操作时，我们需要知道操作是否已经完成，所有当执行完成的时候会返回一个回调函数，表示操作已经完成。缺点：

- 在需要多个操作的时候，会导致多个回调函数嵌套，导致代码不够直观，就是常说的 Callback Hell。
- 如果几个异步操作之间并没有前后顺序之分（例如不需要前一个请求的结果作为后一个请求的参数）时，同样需要等待上一个操作完成再实行下一个操作。

jQuery1.8支持Promise语法，改写方案[lesson11-5.js](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson11-5.html)：

    <script src="../js/lib/jquery.min.js"></script>
    <script>
        // 需在浏览器环境下运行
    $.ajax({
        url: 'https://cnodejs.org/api/v1/topics?limit=10',
        dataType: 'json'
      }).then(data=> {
        console.log('STEP 1 SUCCESS');
        return $.ajax({
            url: 'https://cnodejs.org/api/v1/topic/' + data.data[0].id,
            dataType: 'json'
        });
      }).then(obj=> {
        document.write(obj.data.title);
      });
    </script>

大家也可以再去看看[第二章](/es6/es6-lesson2)最后使用fetch那个部分（node环境下好用）。

## Promise.all

### 概述

Promise.all(iterable) 方法返回一个promise，该promise会等iterable参数内的所有promise都被resolve后被resolve，或以第一个promise被reject的原因而reject 。

### 语法 

    Promise.all(iterable);

### 参数

**iterable**

一个可迭代对象，比如Array。


## Promise.race

### 概述

Promise.race(iterable)方法返回一个promise，这个promise在iterable中的任意一个promise被解决或拒绝后，立刻以相同的解决值被解决或以相同的拒绝原因被拒绝。

### 语法

    Promise.race(iterable);

### 参数

**iterable**

一个可迭代对象，例如Array。
