---
layout: post
title: JavaScript入门
category: Web前端入门教程
tags: Web前端
description: JavaScript语言入门介绍
author: 曹小虎
keywords: lanqiao 蓝桥 全栈 教程 Web前端
description: JavaScript是一种所有的Web浏览器都能理解的编程语言，通过编写JavaScript代码，你可以在自己的网页里面加入何种各种动态交互功能，为用户提供更好的体验和更强大的功能。
---

> 本章目标

- 第一行JavaScript代码
- JavaScript概述
- ECMAScript标准
- JavaScript语法
- JavaScript自定义类和对象

# 实验一：JavaScript初体验

目的：借助于Chrome DevTools的控制台工具，熟悉JavaScript语言的强大功能。

## 1.1 写下你的基本信息

&emsp;&emsp;首先，请打开Chrome DevTools，选中控制台“console”面板。你可以把鼠标光标放置到控制台的第一行。


&emsp;&emsp;首先在控制台写下你的姓名，回车，比如我是蓝桥的弟弟“蓝天”：

    "蓝天"

&emsp;&emsp;继续在控制台输入下面的代码,回车，查看控制台输出：

    typeof("蓝天");

&emsp;&emsp;第二步，在控制台输入你的年龄，比如说今年二十二岁：

    22

&emsp;&emsp;同样，控制台输入下面代码，回车：

    typeof(22);

 ![js_tutorial_open_dev_tools_console](/public/img/js/js_tutorial_open_dev_tools_console.gif)



## 1.2 在控制台计算真值表

&emsp;&emsp;我们在高中的数学课上都学过真值表，现在我们就以“*与*”运算为例，在DevTools的控制台里面计算真值表。

&emsp;&emsp;在控制台输入下面的代码：

    /*
      1.JS关键字var开头，表示这是一个定义变量的表达式
      2.p和q两个字母是变量的名称
      3.等号“=”在这里是一个赋值符号
      4.等号“=”右边的“true”和“false”是一个布尔类型的字面量
     */
    //第一段
    var p = true;
    var q = true;
    var r = p&&q;
    console.log(r);
    console.log(typeof(r));
    //第二段
    var p = true;
    var q = false;
    var r = p&&q;
    console.log(p&&q);
    //第三段
    var p = false;
    var q = true;
    var r = p&&q;
    console.log(r);
    console.log(typeof(r));
    //第四段
    var p = false;
    var q = false;
    console.log(p&&q);
    var r = p&&q;
    console.log(r);
    console.log(typeof(r));
    //第五段
    typeof(true);
    typeof(false);

&emsp;&emsp;同学们可以按照图片的演示，在控制台执行第二段到第五段代码,并且留意，运算结果是否符合真值表。

 ![js_tutorial_in_dev_tools_02](/public/img/js/js_tutorial_in_dev_tools_02.gif)

&emsp;&emsp;我们来创建存放姓名年龄的变量：

    var name = "蓝天";
    console.log(name);
    console.log(typeof(name));
    var age = 22;
    console.log(age);
    console.log(typeof(age));

&emsp;&emsp;在控制台运行代码：

 ![js_tutorial_in_dev_tools_03](/public/img/js/js_tutorial_in_dev_tools_03.gif)

## 1.3 函数：领导干部有态度

&emsp;&emsp;有一天，学生会主席打电话叫来了小张、小李和小马三个同学，在他们三个人面前宣布一个紧急任务，然后请他们谈一谈各自需要几天完成。

&emsp;&emsp;我们来看看下面这段代码：

    var zhang = 3; //小张说我要三天时间
    var li = 5 ; //小李说我要五天时间
    var ma =2;  //小马说我可以两晚上不睡觉，两天48小时时间保证完成任务

&emsp;&emsp;我们来看学生会主席心里怎么计算：

    function attitudeOfChairman(dayLimit){
      var expectedDayCount = 3; //这件事最好能三天完成，但是为防万一，当然能提前一点是一点
      if(dayLimit > expectedDayCount){
        console.log("超过三天，时间太长了，我不放心");
      }else if(dayLimit == expectedDayCount){
        console.log("嗯，还不错，值得考虑......");
      }else if(dayLimit < expectedDayCount){
        console.log("好极了，我要跟他谈谈，了解清楚他能否保证质量！");
      }else{
        console.log("情况不明，无法做出有效判断！");
      }
    }

&emsp;&emsp;当然，然后他们三个就把自己的答案挨个报告出去：

    /* 想要知道人家的态度，先得说出自己的答案 */
    attitudeOfChairman(zhang);
    attitudeOfChairman(li);
    attitudeOfChairman(ma);

&emsp;&emsp;在控制台执行这些代码：

 ![js_tutorial_in_dev_tools_04](/public/img/js/js_tutorial_in_dev_tools_04.gif)

&emsp;&emsp;这个时候，如果有人给出其他其他答案，这位学生会主席又会怎么想呢？

    attitudeOfChairman("我心里没底");

&emsp;&emsp;在控制台上执行这段代码：

 ![js_tutorial_in_dev_tools_06](/public/img/js/js_tutorial_in_dev_tools_06.gif)

## 1.4 完成数学计算

&emsp;&emsp;Math是最常见的一个JavaScript标准库提供的一个数学计算工具。

### 认识JS内置对象Math

&emsp;&emsp;我们可以在控制台上很方便地查看对象的内容，[Math对象](http://www.w3school.com.cn/jsref/jsref_obj_math.asp)的属性中有很多是常量，比如圆周率；也有很多是*函数*类型，比如sin、cos这些一眼就能看出来的三角函数。

 ![js_tutorial_in_dev_tools_07](/public/img/js/js_tutorial_in_dev_tools_07.gif)

&emsp;&emsp;

### 计算地球的体积

&emsp;&emsp;已知地球的平均半径是6376.5千米，如何计算地球的大概体积？下面的函数将会计算出地球的大概体积：

    function getVolumeOfSphere(radius){
      //球体体积计算公式
      var volume = (4/3)*(Math.PI)*(Math.pow(radius,3))
      //返回计算结果
      return volume;
    }

&emsp;&emsp;在控制台调用这个函数：

    //用变量保存函数的返回结果
    var v = getVolumeOfSphere(6376.5);
    console.log(v+"立方千米");

&emsp;&emsp;得到实验结果:

 ![js_tutorial_in_dev_tools_08](/public/img/js/js_tutorial_in_dev_tools_08.gif)

&emsp;&emsp;除此之外，我们只要把球体的半径作为参数传入，就可以反复调用“*getVolumeOfSphere*”这个函数，从而得到相关球体的的体积。


### 完成四舍五入运算

&emsp;&emsp;四舍五入算法是最常见的一种保留小数精确性的计算方法，Math对象上就有一个完成这个功能的工具函数。

    console.log(Math.round(0.60)) ;  
    console.log(Math.round(0.50)) ; 
    console.log(Math.round(0.49)) ; 
    console.log(Math.round(-4.40)); 
    console.log(Math.round(-4.60)); 

&emsp;&emsp;在控制台运行上面的代码，可以看到：

 ![js_tutorial_in_dev_tools_09](/public/img/js/js_tutorial_in_dev_tools_09.gif)


## 1.5 今夕何夕：使用日期

&emsp;&emsp;另外一个很重要的[JavaScript内置对象是Date](http://www.w3school.com.cn/jsref/jsref_obj_date.asp)，它主要被用来处理日期和时间。

&emsp;&emsp;我们来演示两个小例子。

### 当前时间

&emsp;&emsp;在控制台输入下面的代码：

    var now = new Date();
    console.log(now.getFullYear());//现在是哪一年？
    /* （0~11，返回0表示1月，返回11表示12月，以此类推） */
    console.log(now.getMonth())//现在是那一月？
    console.log(now.getDate());//几号了？（1~31）
    console.log(now.getHours());//时？
    console.log(now.getMinutes());//分？
    console.log(now.getSeconds());//秒？
    console.log(now.getMilliseconds());//毫秒？
    console.log(now.getTime())//返回 1970 年 1 月 1 日至今的毫秒数

&emsp;&emsp;在控制台执行下面的代码：

 ![js_tutorial_in_dev_tools_10](/public/img/js/js_tutorial_in_dev_tools_10.gif)


### 自定义时间

&emsp;&emsp;已知2016年是一个闰年，我们来定义一个有意思的日期：

     /*
      一年中第二个月的第29天
      注意：JS日期中getDay方法的取值范围是1~31
     */
    var d1 = new Date(2016,1,29);
     /*
      一年中第三个月的第0天
      注意：JS日期中getDay方法的取值范围是1~31
     */
    var d2 = new Date(2016,2,0);

    console.log(d1);
    console.log(d2);
     /* 比较两个日期对象是否“相等” */
    console.log(d1===d2);
     /* 比较两个日期对象是否“相等” */
    console.log(d1==d2);
     /* 比较两个日期对象的时间是否“相等” */
    console.log(d1.getTime()===d2.getTime());
    
     /*
      一年中第三个月的第-1天
      注意：JS日期中getDay方法的取值范围是1~31
     */
    var d3 = new Date(2016,2,-1);
    console.log(d3);
     /* 比较d2是否大于d3 */
    console.log(d2>d3);
     /* 比较d2是否小于d3 */
    console.log(d2<d3);

&emsp;&emsp;在控制台执行以上代码，可以看到：

 ![js_tutorial_in_dev_tools_11](/public/img/js/js_tutorial_in_dev_tools_11.gif)


# 实验一的解读

## 什么是JavaScript

&emsp;&emsp;所有的现代浏览器都内置了一个分析和运行JavaScript代码的小程序，它就是JavaScript引擎。这个引擎不但有独特、复杂的内部结构，而且还会随着浏览器一起升级。

 ![javascript_engines](/public/img/js/javascript_engines.jpg){:width="400px" height="240px"}

### LiveScript

&emsp;&emsp;网景（NetScape）公司是第一家尝试利用新生万维网的商业企业，它的是主要目标是为所有操作系统的用户提供跨平台一致的互联网使用体验。

 ![father_of_javascript](/public/img/js/brendan-eich.jpg){:width="100px" height="80px"}

&emsp;&emsp;大约在1994年的时候，网景公司的制定一了个产品战略：他们的浏览器浏览器产品将要够支持动态、可交互的网页。1995年，他们的领导找来了一个名字叫Brendan Eich的电脑程序员，请他来负责设计和实现这门可以在浏览器里面运行的编程语言。他仅仅花十天时间，就写出第一个版本的脚本（Script）语言，并且给它了个名字“Mocha”。当时这个早期版本的浏览器脚本语言还很不成熟，里面包含有很多bug，甚至有些问题一直保留到今天，仍然被认为是“臭名昭著”，但这都是后话。

&emsp;&emsp;后来网景公司的市场部门把这门语言的名字改为**LiveScript**。

### Sun公司积极参与

 ![javascript-vs-java-difference.jpg](/public/img/js/javascript-vs-java-difference.jpg){:width="400px" height="300px"}

&emsp;&emsp;当时Java语言已经是一门十分流行、广受欢迎的网站后端编程语言了，网景也希望新生的LiveScript语言能够像Java一样流行。考虑到两家在推动早期互联网普及发展方面的合作关系，Sun公司把Java商标的使用权授许给网景，于是原来的LiveScript更名为JavaScript。

&emsp;&emsp;1995年12月4日，网景和Sun公司联合发布了着一门新的浏览器编程语言，他们在公开场合称这门语言是“对HTML和Java语言的补充”。

&emsp;&emsp;Brendan Eich被后人尊成为JavaScript之父。

### 浏览器大战

&emsp;&emsp;坊间早有传闻，大约1994年的时候，财大气粗的微软十分看好网景公司的浏览器业务，因此计划出资收购后者。不知道是什么具体原因，收购的事情没谈下来，微软转回头就开始开发自己的浏览器Internet Explorer(简称IE)。

 ![ie-vs-netscape](/public/img/js/ie-vs-netscape.jpg){:width="300px" height="300px"}

&emsp;&emsp;1996年3月份，第一个引入了JavaScript新特性的现代浏览器Netscape Navigator 2.0浏览器问世。

&emsp;&emsp;微软看到竞争对手的浏览器因引入JavaScript新特性而取得的良好的市场效果，它们快速反应，很短时间之内，果断推出了自己的网页编程语言———**JScript**，随后他们推出的IE3更是成为第一款同时支持JScript编程语言和CSS的商用浏览器，IE浏览器的市场份额紧追Netscape。

&emsp;&emsp;网景和微软两家企业之间发生了以争夺浏览器市场份额为目标的激烈竞争整整持续了几年。最终的结果是，IE浏览器市场份额不断上升，直到形成事实上的垄断优势，而Netscape的浏览器市场份额被不断挤压。面对来自微软的巨大竞争压力，网景公司不得不逐步放弃自己的这款商用浏览器。1998年3月，他们选择把Netscape　Navigator浏览器的源代码公布在网上。

### Web标准的崛起

&emsp;&emsp;一方面，IE4浏览器在抢占市场份额的过程中之所以艺高一筹，有一个很重要的原因是，它比Netscape Navigator 4.0更好地匹配了**W3C**制定的网页标准。这一点不会被任何一个有商业头脑的生意人错过，大战双方通过总结市场上的经验教训，更加深刻地意识到了遵守公开的Web标准的巨大好处。

&emsp;&emsp;反面的教训是，浏览器大战中，微软和网景致力于实现新特性却忽视了修复这些特性中存在的问题。他们不断增加专有的特性，还以不兼容的方式创造与对方浏览器已有特性直接竞争的新特性。那时，开发者在创建网站时不得不应对与日俱增的混乱。他们有时要为两个主要浏览器建立不同但实际上重复的两个站点；有时则干脆选择只支持一种浏览器，另一浏览器用户就无法正常访问同一网站。

&emsp;&emsp;不久，这种糟糕的工作方式就不可避免地遭到了来自开发者的强烈抗议。

### ECMAScript标准

&emsp;&emsp;1996年11月，网景公司将JavaScript提交给欧洲计算机制造商协会进行标准化。

&emsp;&emsp;ECMA-262的第一个版本于1997年6月被Ecma组织采纳[3]。ECMAScript是由ECMA-262标准化的脚本语言的名称。ECMAScript标准成为浏览器内编程语言的标准。JavaScript和JScript与ECMAScript相容，但包含超出ECMAScript的功能。

&emsp;&emsp;ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会）通过ECMA-262标准化的脚本程序设计语言。 这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。

 ![ecmascript-history](/public/img/js/ecmascript-history.png){:width="700px" height="600px"}

&emsp;&emsp;

&emsp;&emsp;

## JS基础

### 字面量

&emsp;&emsp;JavaScript语言的基本数据类型，他们分别是字符串（String）、数字（number）和布尔值（boolean）。

&emsp;&emsp;我们在控制台输入的人名“蓝天”是***字符串字面量***，年龄“24”是***数字字面量***。此外，布尔值“true”和“false”分别是***布尔值字面量***。

&emsp;&emsp;根据MDN社区的定义，所谓字面量就是：由语法表达式定义的常量；或，通过由一定字词组成的语词表达式定义的常量。

>在JavaScript中，你可以使用各种字面量。这些字面量是脚本中按字面意思给出的固定的值，而不是变量。

&emsp;&emsp;除了三种基本数据类型的字面量，以后我们还会学到和用到更多类型的字面量。


### 变量

&emsp;&emsp;与代数一样，JavaScript 变量可用于存放值（比如 x=2）和表达式（比如 z=x+y）。

&emsp;&emsp;变量可以使用短名称（比如 x 和 y），也可以使用描述性更好的名称（比如 age, sum, totalvolume）。

&emsp;&emsp;在JavaScript语言中，声明和定义一个变量需要写出一个以关键词***var***开头、以英文字符（;）结尾的表达式。

- 变量必须以字母开头
- 变量也能以 $ 和 _ 符号开头（不过我们不推荐这么做）
- 变量名称对大小写敏感（y 和 Y 是不同的变量）

&emsp;&emsp;一般情况下，变量的声明和定义都会一气呵成，就像这样：

    var name = "蓝天";

&emsp;&emsp;或者是

    var age = 24;

&emsp;&emsp;结果正如已经看到的。

&emsp;&emsp;然而，在二般情况下，对于一个新的变量也可以只声明、不赋值。就像这样：

    var myWords ;
    console.log(myWords);
    myWords = "学无止境";
    console.log(myWords);

&emsp;&emsp;你在控制台上执行这几行代码，你就会发现，控制台第一次打印“myWords”的时候，打印了一行“undefined”。这可是“未定义”啊！在这种情况下，JS引擎不知道你打算说什么，别无选择，只好报告这是一个“未定义”的变量。

&emsp;&emsp;在JavaScript中，***undefined***是一个非常特殊的字面量，它被用来给“未定义”的变量充当**占位符**。

### 运算符和运算表达式

&emsp;&emsp;逻辑运算符：在进行两个布尔值的“*与*”运算时，我们用到了“*&&*”的运算符。

&emsp;&emsp;数学运算符，比如说乘号（*）、大于号（>）和小于号（<）；

&emsp;&emsp;等性运算符：检查两个变量是否相等的（===）和（==）。

&emsp;&emsp;凡是运算符出现的地方，必定有参与运算的各种字面量和变量。广义地说，运算符和参与运算的字面量或常量合在一起组成一个完整的运算表达式，或赋值、或求、或求乘积、或者比较大小。

&emsp;&emsp;关于这个问题，大家可以参考页面：[MDN 运算符和表达式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators)。

&emsp;&emsp;

&emsp;&emsp;

## function

&emsp;&emsp;JavaScript函数（function）被设计成专门完成一个计算任务的基本运算单位。就像一个机器一样，函数的要做的就是，根据输入，输出计算结果：

 ![Function_as_machine](/public/img/js/Function_as_machine.jpg){:width="300px" height="200px"}

&emsp;&emsp;我们可以在JS代码中通过特殊的语法发起计算任务，这个发起计算任务的动作就是“调用函数一个”。

### 关键字function和函数名

&emsp;&emsp;实验一里，我们定义过两个名称分别是“attitudeOfChairman”和“getVolumeOfSphere”的函数，它们与“*function*”关键字之间都有空格分隔。


### 参数列表和函数返回值

&emsp;&emsp;以实验一计算球体体积的函数为例。

&emsp;&emsp;它可以送外部接收*一个*参数，此参数在函数内部作为球体的半径参与运算。

&emsp;&emsp;函数结尾处，有一个关键字“return”开头的*返回表达式*，计算结果将会因此被送回到调用函数的地方。

&emsp;&emsp;另外一个函数“attitudeOfChairman”，从外部接收一个参数，但是函数体执行完以后没有返回任何内容。这种情况下，如果声明一个新变量来保存函数调用的返回值，那么这个新变量的值就会成为*undefined*。


### 函数体

&emsp;&emsp;包含在一对花括号之间的内容就是函数体，其中包含了函数被调用时要执行的代码。这里往往是一个复杂而且完整的计算过程。


### 函数内置对象arguments

&emsp;&emsp;根据JavaScript规范，所有函数都有一个名字是*arguments*的内置对象。

&emsp;&emsp;你可以把下面的代码插入到“attitudeOfChairman”的函数体的开头，并且重新运行一次。

    console.dir(arguments);
    console.log(arguments);

&emsp;&emsp;结果可以看到*arguments*对象里面，保存了外界调用函数时传入的参数。

 ![js_tutorial_func_arguments_01](/public/img/js/js_tutorial_func_arguments_01.png)


&emsp;&emsp;此外，函数的*arguments*对象还有一些特别的用途。以代码为例，请看：

    function multiNumOfParamsAdd(){
        var tempValue = 0;
        for(var i=0;i<arguments.length;i++){
            tempValue = tempValue + arguments[i];
        }
        return tempValue;//返回计算结果
    }
    
    var result = multiNumOfParamsAdd(2,3,4,5,6,7,8,9);//使用变量"result"来保存函数计算输出
    console.log('the result is:'+result);

    function addTwoArguments(){
        //从arguments对象里面取出前两个参数，计算它们的和
        var result = arguments[0] +arguments[1];
        return result;
    }

    var sum = addTwoArguments(3,6);
    console.log(sum);


### 匿名函数

&emsp;&emsp;匿名函数就是没有名字的函数，这种函数只能在定义它的同时立即调用。

    /*
      没有名字的函数是匿名函数
      调用匿名函数的步骤是：
      1.是用一个小括号把函数定义包装起来
      2.紧随着一对小括号表示函数定义完之后立即调用它
     　3.在第二对小括号里面传入参数
    */
    var myResult =(function (){
        return arguments[0] + arguments[1];
    })(3,4);
    console.log('myResult is:'+myResult);


### 把函数赋值给变量

&emsp;&emsp;函数在JavaScript里面也是一种数据类型，我们可以按照下面的格式定义一个函数类型的变量：

    var myFunc =  function(){
        console.log('这是执行函数留下的痕迹......');
    }
    console.log(typeof myFunc);//function
    
    myFunc();

&emsp;&emsp;把“myFunc”作为参数传入另外一个函数：

    function my2Func(f){
        f();//调用传入的函数
    }
    my2Func(myFunc);//mySecondFunc is invoked!

&emsp;&emsp;

&emsp;&emsp;

## Scope

&emsp;&emsp;JS语言里的Scope，是一个变量、对象和函数组成的集合。

>In JavaScript, scope is the set of variables, objects, and functions you have access to.

### global

&emsp;&emsp;实验一演示了“Math”工具提供的多个常量和数学函数。

&emsp;&emsp;除此之外，我们也演示了使用“Date”函数创建表示日期和时间变量。

&emsp;&emsp;除了在控制台上直接访问“Math”对象和“Date”函数，我们还在自定义的*函数*内部访问它们。其中*getVolumeOfSphere*的函数体里面就用到了（*Math.PI*）和（*Math.pow*）两个数学函数。

 ![js_tutorial_in_dev_tools_12](/public/img/js/js_tutorial_in_dev_tools_12.gif)

&emsp;&emsp;下面是在函数里面创建日期的例子：
 
 ![js_tutorial_in_dev_tools_13](/public/img/js/js_tutorial_in_dev_tools_13.gif)

&emsp;&emsp;JavaScript语言标准库定义了包括“Math”对象和“Date”函数在内的许多函数和对象，它们一起组成一个**global**作用域。详细情况，大家可以查看MDN的[JavaScript语言的标准库](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects)页面。

&emsp;&emsp;其他变量（包括函数类型的变量），只要没有声明和定义在任何其他函数里面，比如实验一里面用过的两个函数*attitudeOfChairman*和*getVolumeOfSphere*，都默认位于**global**作用域。

### local

&emsp;&emsp;在函数执行过程中声明的变量、对象和函数一起组成函数的local（本地）作用域。

&emsp;&emsp;以函数调用过程为参照，它们在函数函数执行完以后会被**清理掉**，因而也可以说是函数的本地（local）变量。

&emsp;&emsp;在getVolumeOfSphere函数内部，我们把计算得到的球体体积赋值给新声明的变量*volume*。函数执行完以后，这个变量就不存在了：在函数外部也找不到它的声明，更不用提什么赋值和定义了！

 ![js_tutorial_in_dev_tools_14](/public/img/js/js_tutorial_in_dev_tools_14.gif)

&emsp;&emsp;

&emsp;&emsp;

# 实验二：从一到多——认识JS数组

目的：借助于Chrome DevTools的控制台工具，掌握JavaScript数组的定义和常用操作。

&emsp;&emsp;我们经常会把一次会议要用到的几份纸质文件资料按*顺序*放进一个文件夹里。在使用JavaScript语言的时候，我们可以用一个数组保存多条数据内容。

&emsp;&emsp;我们将会在数组里面不记名地存入班上任意10名同学英语科目的期末考试成绩。

## 2.1 创建数组

&emsp;&emsp;下面两种办法都可以创建数组。

### 数组字面量

&emsp;&emsp;可以用数组字面量来定义数组。

&emsp;&emsp;代码如下：

     console.time("Array initialize in literal");
     var  testScores = [55,65,74,88,43,22,77,91,66,87];
     console.timeEnd("Array initialize  in literal");
     console.log(testScores);//在控制台查看数组内容
     console.log(testScores.length);//在控制台查看数组长度


### 使用Array函数

&emsp;&emsp;在 JavaScript 中 Array 是一个用来构造数组的全局对象，我们也可以用它（constructor）创建新的数组变量。

&emsp;&emsp;代码如下：

     console.time("Array initialize in constructor");
     var  testScores = new Array(55,65,74,88,43,22,77,91,66,87);
     console.timeEnd("Array initialize  in constructor");
     console.log(testScores);//在控制台查看数组内容
     console.log(testScores.length);//在控制台查看数组长度

&emsp;&emsp;在控制台里面执行代码，可以看到，两种方法创建数组的效果完全相同。

 ![js_tutorial_array_in_dev_tools_1](/public/img/js/js_tutorial_array_in_dev_tools_1.gif)


## 2.2 访问元素

### 访问数组元素

&emsp;&emsp;我们可以用数字下标访问数组里面的单个元素。

&emsp;&emsp;代码如下：

    testScores[0];//数组第一个元素
    testScores[testScores.length-1];//数组最后一个元素
    testScores[testScores.length];//这样不会报错，但是找不到你想要的数据

    testScores[testScores.length] = 99; //向数组末尾加入新元素
    testScores    //查看数组详情
    testScores.push(21); //继续向数组末尾加入新元素
    testScores    //查看数组详情
    testScores.shift();//删除数组第一个元素
    testScores    //查看数组详情
    testScores.pop();//从数组末尾删除元素
    testScores    //查看数组详情
    testScores.length = testScores.length -1;//再从数组末尾删除元素
    testScores    //查看数组详情

    //使用for循环遍历数组元素
    for(var i=0;i<testScores.length;i++){
       console.log(testScores[i]);
    }

    //使用forEach函数遍历数组元素
    testScores.forEach(/* 参数函数开始 */function(e,index,arr){
       console.log("第" + index + '个数组元素的内容是:' + e);
    }/* 参数函数结束 */
    );
    
&emsp;&emsp;上述代码在控制台执行的运行效果如下：

 ![js_tutorial_array_in_dev_tools_02](/public/img/js/js_tutorial_array_in_dev_tools_02.gif)

### 数组工具方法

&emsp;&emsp;JavaScript标准库定义的为每一个数组类型的变量提供有多种工具方法，想知道JS数组的更多方法，请参考[W3School JavaScript Array 对象](http://www.w3school.com.cn/jsref/jsref_obj_array.asp)页面。

&emsp;&emsp;此外，只需要在控制台输入下面的代码，我们就可以在DevTools的控制台上看到Array类型变量支持哪些方法。

    //Array是JS全局作用域的一个函数，我们可以用它（constructor）创建新数组
    console.dir(Array.prototype);

&emsp;&emsp;结果如下：

 ![js_tutorial_array_in_dev_tools_02](/public/img/js/js_tutorial_array_in_dev_tools_03.gif)

&emsp;&emsp;根据这些函数的名字，我们应该大致猜到它们究竟是干什么的。比如说“reverse”就是一个反转数组的方法，“sort”就是一个给数组排序的方法。

&emsp;&emsp;有关数组类型变量的更多方法，请查阅[MDN JavaScript标准库-Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects)页面。

&emsp;&emsp;

&emsp;&emsp;

# 实验二的解读

实验二的主要介绍了JavaScript标准库提供的Array对象的使用方法。

## 关于数组对象

### 数组长度问题

&emsp;&emsp;数组对象的length属性记录了数组中已有元素的个数。

&emsp;&emsp;我可以通过push方法想数组尾部“压入”一个新元素，这时length属性会自动加一；也可以用pop方法从数组末尾“弹出”元素，这时数组长度会自动减一。

&emsp;&emsp;我们甚至可以修改length属性，如果新length值比原来的length值小，数组就会被截断。

&emsp;&emsp;这些都是对数组进行的合法操作。

### 元素类型问题

&emsp;&emsp;我们在声明和定义一个数组变量的时候，并没有明确指出数组元素一定要是什么类型，JS引擎也不会检查这个问题。

&emsp;&emsp;对于JavaScript数组，你可以往里面放任何类型的数据元素。


## 构造函数Array

&emsp;&emsp;Array是一个JavaScript标准库函数，也是所有数组对象的构造函数（constructor）。

### Array.prototype

&emsp;&emsp;Array上有一个prototype属性。

>所有的数组方法都定义在[Array.prototype](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype)身上，和其他的构造函数一样，你可以通过扩展Array的prototype 属性上的方法来给所有数组实例增加方法。 

&emsp;&emsp;可以在控制台上查看Array.prototype对象：

 ![js_tutorial_create_obj_in_dev_tools_03_1](/public/img/js/js_tutorial_create_obj_in_dev_tools_03_1.gif)


## console计时工具

 ![timer](/public/img/js/timer.png)

&emsp;&emsp;在创建数组的代码里面我们用到控制台的计时工具：console.time（开始计时）和console.timeEnd（完成计时）。

&emsp;&emsp;我们记录了用字面量和构造函数创建同一个数组分别消耗的时间，结果发现：这两种方法耗时没有差别。

&emsp;&emsp;有关这个工具的更多信息，请查看[MDN console.time](https://developer.mozilla.org/zh-CN/docs/Web/API/Console/time)页面。

&emsp;&emsp;

&emsp;&emsp;

# 实验三：文字魔术师——操控字符串

目的：通过实验一，我们掌握了用*字面量*定义一个字符串变量的方法。作为一种运行于Web浏览器里的编程语言，JavaScript标准库包含了丰富的应用编程接口（API），可以帮助程序员便捷高效地处理网页上的文字内容。

&emsp;&emsp;本次实验，我们将在Chrome DevTools的控制台里，学习使用JavaScript标准库的String类型对象处理文字内容。具体地说：

 1. 练习字符串常见操作
 2. 用String函数创建字符串对象
 3. 用字符串对象的属性和方法操作字符串内容

## 3.1 常见字符串处理

### 使用字面量的正确姿势

&emsp;&emsp;用一对双引号和一对单引号都可以创建字符串字面量。

&emsp;&emsp;倘若字符串的内容包含单引号或者双引号，此时就要根据情况转义符号：“\”。

    //1.用双引号创建字符串，内容里面包含双引号
    //  如果不用转义符号，控制台会提示JavaScript语法错误
    var s1 = "Chrome浏览器说:"Hello World!"";

    // 正确的方法是：在文字内容里的双引号前面使用“\”转义符号，
    var s2 = "Chrome浏览器说:\"Hello World!\"";
    
    // 文字内容里面可以使用单引号
    var s3 = "Chrome浏览器说:'Hello World!'";

    //用单引号创建字符串字面量，内容里面的双引号无须转义处理
    var s4 = 'Chrome浏览器说:"Hello World!"';

&emsp;&emsp;在控制台执行上述代码：

 ![js_tutorial_string_in_dev_tools_04](/public/img/js/js_tutorial_string_in_dev_tools_04.gif)

### 连接

&emsp;&emsp;把两个甚至多个字符串连接成一个字符串，需要用到的运算符是“+”。

    var s5 = "Hello ";
    var s6 = "World";
    var s7 = s5 + s6;

&emsp;&emsp;在控制台执行代码，可以看到：

 ![js_tutorial_string_in_dev_tools_05](/public/img/js/js_tutorial_string_in_dev_tools_05.gif)

### 比较

&emsp;&emsp;比较两个字符串是否相同需要用到等性运算符“===”和"=="。在比较字符串的运算过程中，这两个符号的效果是一样的。

    var isEqual = (s2===s4);
    isEqual = (s2==s3);

 ![js_tutorial_string_in_dev_tools_06](/public/img/js/js_tutorial_string_in_dev_tools_06.gif)

## 3.2 当字符串成为对象

### 用String函数构造字符串

&emsp;&emsp;我们可以用JavaScript标准库提供的String函数（constructor）创建字符串。

&emsp;&emsp;此时构造函数就返回了一个对象类型的字符串变量。

    //把字符串内容作为参数传入
    var s8 = new String("Chrome浏览器说:\"Hello World!\"");

&emsp;&emsp;在控制台执行代码，可以看到：

 ![js_tutorial_string_in_dev_tools_07](/public/img/js/js_tutorial_string_in_dev_tools_07.gif)

&emsp;&emsp;这种方法创建了一个“object”变量，控制台显示的字符串的**PrimitiveValue**属性。

&emsp;&emsp;字符串对象的“*valueOf*”方法返回了创建对象时传入的***字面值***。

&emsp;&emsp;另外，JS引擎在读取*字符串字面量*时，会悄悄把*字面量*转换成*对象*类型。因此，无论用哪种方法创建字符串变量，我们都能通过新的变量名调用标准库中String类型对象的全部属性、方法。

 ![js_tutorial_string_in_dev_tools_08](/public/img/js/js_tutorial_string_in_dev_tools_08.gif)

&emsp;&emsp;大家可以通过[MDN JavaScript标准库 String](https://developer.mozilla.org/cn/docs/Web/JavaScript/Reference/Global_Objects/String)页面深入了解String对象的属性和方法。

&emsp;&emsp;

## 3.3 转换文字内容

&emsp;&emsp;大家都知道“winston churchill”是谁，但是这个名字的两个单词首字母都没有大写。

&emsp;&emsp;借助JavaScript标准库为String类型提供的方法，我们可以实现这一转换。

### 方法一

    var name = "winston churchill";
    var arr = name.split(" ");
    arr[0] = arr[0].slice(0,1).toUpperCase() + arr[0].slice(1);
    arr[1] = arr[1].slice(0,1).toUpperCase() + arr[1].slice(1);
    name = arr.join(" ");

&emsp;&emsp;在控制台执行代码，可以看到：

 ![js_tutorial_string_in_dev_tools_09](/public/img/js/js_tutorial_string_in_dev_tools_09.gif)

### 其他方法

&emsp;&emsp;除了上面的办法，标准库里面还有一个名字是“replace”的方法，请你考虑怎么用它达到相同目的。

&emsp;&emsp;请仔细阅读文档，考虑有没有其他方法完成这个工作。

&emsp;&emsp;

# 实验三的解读

实验二的主要介绍了JavaScript标准库提供的String对象的使用方法。

## 构造函数String

&emsp;&emsp;String是一个JavaScript标准库函数，也是所有字符串（对象）的构造函数（constructor）。

### String.prototype

&emsp;&emsp;String上有一个prototype属性。

>所有 String 的实例都继承自 String.prototype. 任何String.prototype上的改变都会影响到所有的String实例。

&emsp;&emsp;可以在控制台上查看String.prototype对象：

 ![js_tutorial_create_obj_in_dev_tools_09_1](/public/img/js/js_tutorial_create_obj_in_dev_tools_09_1.gif)


&emsp;&emsp;


# 实验四：象由心生——自定义对象

目的：借助于Chrome DevTools的控制台工具，掌握如何定义一个JavaScript对象。

&emsp;&emsp;现实生活中，一辆汽车就是一个对象。

&emsp;&emsp;我们不仅可以用数字和文本记录某台汽车各个方面的特征，比如颜色、总重，而且可以通过描述一个*过程*来记录它能干什么，比如发动、加速、刹车等等。

 ![objectExplained](/public/img/js/objectExplained.png){:width="700px" height="600px"}

&emsp;&emsp;使用JavaScript语言，把所有与某台汽车有关的属性定义和过程（function）定义组合成一个总体，这就是JavaScript语言的汽车对象——**JavaScript Object**。

## 4.1 使用对象字面量

&emsp;&emsp;创建JavaScript对象最简单的办法就是：使用*对象字面量*。


### 从空对象开始

&emsp;&emsp;最简单的对象是一个空对象。

&emsp;&emsp;一个空对象只需要用一对花括号来表示：

    //由对象字面量定义的空对象
    var myCar = {};
 
 ![js_tutorial_create_obj_in_dev_tools_01](/public/img/js/js_tutorial_create_obj_in_dev_tools_01.gif)

&emsp;&emsp;经过检验，控制台告诉我们：这是一个货真价实的JavaScript对象。

&emsp;&emsp;用*console.dir*方法查看对象的内部结构，可以看到JavaScript引擎在我们的空对象里面加入了一个名称是“*\__proto\__*”的Object类型属性。

&emsp;&emsp;至此，空对象创建好了。


### 描述汽车的基本特征

&emsp;&emsp;我们需要用各种属性和方法如实地描述汽车的特征。比如说，我们用一个字符串来记录汽车的名字。

&emsp;&emsp;为myCar对象增加属性内容。

&emsp;&emsp;代码如下：

    //汽车的名字
    myCar.name = "Fiat";
    //汽车的型号
    myCar.model = "500";
    //汽车的重量
    myCar.weight = 850;
    //描述汽车重量的单位
    myCar.wUnit = "kg";
    //汽车的颜色
    myCar.color = "white";

&emsp;&emsp;在控制台执行上述代码，然后查看myCar的内部结构：

 ![js_tutorial_create_obj_in_dev_tools_02](/public/img/js/js_tutorial_create_obj_in_dev_tools_02.gif)

&emsp;&emsp;然后，挨个查看这些属性的内容：

 ![js_tutorial_create_obj_in_dev_tools_02_1](/public/img/js/js_tutorial_create_obj_in_dev_tools_02_1.gif)

&emsp;&emsp;

### 用函数描述过程

&emsp;&emsp;现实生活中的一台汽车最重要的能力就是，它能根据人的意愿跑起来。

&emsp;&emsp;我们给汽车对象增加一个函数，用函数的计算过程模拟汽车的动态行为。

&emsp;&emsp;比如说，汽车启动的动态过程：

    myCar.start =  function(){
       //控制台语句表明这台车正在启动
       console.log("汽车正在启动......");
    };

&emsp;&emsp;在控制台执行代码，并且检查对象内部结构、调用myCar对象的方法：

 ![js_tutorial_create_obj_in_dev_tools_03](/public/img/js/js_tutorial_create_obj_in_dev_tools_03.gif)

&emsp;&emsp;再接再厉，请你为myCar对象增加更多行为能力：

     myCar.drive =  function(){
       console.log(this.name+ "正在行驶中......");
     };

     myCar.brake = function(){
       console.log(this.name+ "紧急刹车!");
     };

     myCar.stop = function(){
       console.log(this.name+ "已经停稳了......");
     };


### 在方法里访问属性

&emsp;&emsp;我们来做一件简单的事情：把汽车的name属性一起输出到控制台。

&emsp;&emsp;重新定义myCar对象的start方法：

     myCar.start =  function(){
       console.log("在对象内部，'this'这个词指代对象本身:"+(myCar===this));
       console.log(this.name+ "正在行驶中......");
     };

&emsp;&emsp;在控制台重新测试start方法：

 ![js_tutorial_create_obj_in_dev_tools_04](/public/img/js/js_tutorial_create_obj_in_dev_tools_04.gif)

### 动手练一练

&emsp;&emsp;上面我们用JavaScript语言模拟制造一台真实的汽车的过程。

&emsp;&emsp;按照上面的方法，制造一辆汽车大体上需要两步，

1. 模仿：先找到已有的汽车，沿用它们的属性和行为。

2. 创新：根据需要，修改原有的属性和方法，或者给汽车增加新的属性和方法。

&emsp;&emsp;请同学们亲自动手，用这样的方法制造１０台汽车。

 ![car_objects](/public/img/js/car_objects.png){:width="500px" height="400px"}   更多汽车正在拷贝修改当中......

&emsp;&emsp;

## 4.2 使用constructor创建对象

&emsp;&emsp;正如用JavaScript标准库的Array、Date、String函数可以创建对象，我们也可以先定义一个函数，然后把这个自定义函数当成构造器（constructor），创建自己需要的对象。

 ![constructor_pic](/public/img/js/constructor_pic.png){:width="300px" height="200px"}

### 定义函数

&emsp;&emsp;在控制台上执行下面的代码定义构造函数：

    function Car(name,model,weight,wUnit,color,owner){
      this.name = name;
      this.model = model;
      this.weight = weight;
      this.wUnit =wUnit;
      this.color =color;

      this.start =　function(){
      　　console.log("名字是"+this.name+"的汽车正在启动......");
       },
      this.drive = function(){
       console.log(this.name+ "正在行驶中......");
      } ,
      this.brake = function(){
       console.log(this.name+ "紧急刹车!");
      } ,
      this.stop  = function(){
       console.log(this.name+ "已经停稳了......");
      }
    }

&emsp;&emsp;然后在控制台创建执行创建对象的过程：

      //通过构造函数创建对象
      var car2 =new Car("Fiat","500",850,"kg","white");
      //通过构造函数创建对象
      console.dir(car2);

      //查看新对象的构造器
      console.log(car2.constructor);
      //查看新对象的构造器
      console.log(car2 instanceof Car);

&emsp;&emsp;并且查看新建对象的关键属性：

 ![js_tutorial_create_obj_in_dev_tools_05](/public/img/js/js_tutorial_create_obj_in_dev_tools_05.gif)


### 试一试

&emsp;&emsp;同学们可以在控制台尝试去掉“new”关键字，还能否创建一个新的汽车对象：

      var car3 = Car("Ford","500",850,"kg","black");

&emsp;&emsp;另外，在这种情况下，关键字（key word）表示什么？

&emsp;&emsp;

## 4.3 构造函数的prototype对象

&emsp;&emsp;之前在创建数组的时候,我们提到过[Array.prototype](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype)。根据MDN网页的介绍：所有的数组方法都定义在*Array.prototype*身上，和其他的构造函数一样，你可以通过扩展Array的prototype 属性上的方法来给所有数组实例增加方法。

&emsp;&emsp;在创建字符串的时候，我们还提到过[String.prototype](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/prototype)。根据MDN网页的介绍：所有String 的实例都**继承**自*String.prototype*. 任何String.prototype上的改变都会影响到所有的String实例。

&emsp;&emsp;不仅如此，事实上，所有由**函数充当构造子**创建出来的对象，都会从**构造函数的prototype对象**上**继承**属性和方法。

&emsp;&emsp;更严格的讲，继承这个词也有一点不准确。

### 预备工作

&emsp;&emsp;创建一个变量名是*car3*的新对象：

      var car3 = new Car("Ford","500",850,"kg","black");

&emsp;&emsp;我们用等性运算符“*===*”查看car2和car3上同名方法：

    //car2和car3是由同一个构造子创建的两个对象 
    console.log('car2.start === car3.start:' + (car2.start === car3.start));
    console.log('car2.drive === car3.drive:' + (car2.drive === car3.drive));
    console.log('car2.brake === car3.brake:' + (car2.brake === car3.brake));
    console.log('car2.stop === car3.stop:' + (car2.stop === car3.stop));

&emsp;&emsp;在控制台上执行操作，可以看到：car2和car3上的每一个同名方法都分别指向**两个不同**的函数定义。

 ![js_tutorial_create_obj_in_dev_tools_06](/public/img/js/js_tutorial_create_obj_in_dev_tools_06.gif)


### 修改Car函数的prototype

&emsp;&emsp;依次执行代码，重新定义构造函数：

      function Car(name,model,weight,wUnit,color,owner){
       this.name = name;
       this.model = model;
       this.weight = weight;
       this.wUnit =wUnit;
       this.color =color;
      }

      Car.prototype.start　=　function(){
      　　console.log("名字是"+this.name+"的汽车正在启动......");
      },
      Car.prototype.drive = function(){
       console.log(this.name+ "正在行驶中......");
      } ,
      Car.prototype.brake = function(){
       console.log(this.name+ "紧急刹车!");
      } ,
      Car.prototype.stop  = function(){
       console.log(this.name+ "已经停稳了......");
      }

      var car4 =new Car("BYD","500",850,"kg","white");
      var car5 =new Car("桑塔纳2000","500",850,"kg","black");

&emsp;&emsp;在控制台执行代码：

 ![js_tutorial_create_obj_in_dev_tools_07](/public/img/js/js_tutorial_create_obj_in_dev_tools_07.gif)



## 4.3 修改对象

&emsp;&emsp;正如“世界上没有两片完全相同的叶子”，有这样一句话老司机们一定认同：“世界上没有两辆完全相同的汽车”。

&emsp;&emsp;在上路几年之后，每一辆汽车从内到外，每天都在发生各自不同的变化。与此同时，哪怕是出自同一条生产线的不同汽车，也会被车主以不同方法维护、改装。

&emsp;&emsp;类似的，我们可以直接修改JavaScript对象的属性和方法。

### 新增属性

&emsp;&emsp;我们可以在对象定义好以后，给单独一台汽车增加属性：

    car2.owner = 'John';
    console.dir(car2);


### 删除属性

&emsp;&emsp;从单独的一台汽车上删除一个属性：

    delete (car2.model)
    console.dir(car2);
    console.dir(car3);

在控制台执行两段代码，可以看到：

 ![js_tutorial_create_obj_in_dev_tools_07](/public/img/js/js_tutorial_create_obj_in_dev_tools_07.gif)

&emsp;&emsp;

&emsp;&emsp;

# 实验四的解读

&emsp;&emsp;

&emsp;&emsp;

## 关于对象字面量

### 一次定义多个属性和方法

&emsp;&emsp;在实验里面，我们从一个空对象开始，一步一步给对象增加属性和方法，然而，这种做法委实耗时。

&emsp;&emsp;实际上，我们完全可以使用对象字面量一次性定义多个属性和方法。

&emsp;&emsp;下面的代码就实现了这种做法:

    var myCar2 = 
     {   　　
     /*属性名*/ /*冒号*/ /*属性值*/   /*属性定义分隔符*/
      name        :       "Fiat",
      model       :       "500" ,
      weight      :        850  , 
      wUnit       :       "kg"  ,
      color       :       "white" ,
     /*方法名*/ /*冒号*/ /*函数定义*/　/*方法定义分隔符*/
      start       :  　　　function(){
      　　console.log("名字是"+myCar.name+"的汽车正在启动......");
       } ,
      drive : function(){
       console.log(this.name+ "正在行驶中......");
       },
      brake : function(){
       console.log(this.name+ "紧急刹车!");
       },
      stop  : function(){
       console.log(this.name+ "已经停稳了......");
      }
    　　};


&emsp;&emsp;在控制台一次执行start、drive、brake和stop方法，可以看到以下输出：

 ![myCar_console_output](/public/img/js/myCar_console_output.png){:width="500px" height="400px"}


## constructor

### 构造函数做了什么

&emsp;&emsp;构造函数Car的执行过程就是给新对象添加属性和方法的过程。

&emsp;&emsp;使用构造函数“Car”创建对象过程大致分为以下四步:

    /* 第一步：创建一个空对象 */
    var temp ={};
    /* 第二步：空对象作为作用域，调用构造函数“Car”*/
    Car.apply(temp,["Fiat","500",850,"kg","white"]/*从构造子参数列表传入的对象属性...*/);
    /* 第三步：指定新对象的构造子（constructor）是函数"Car"*/
    temp.__proto__. = Car.prototype;
    /* 第四步：把新对象赋值给“car2”*/
    var car2 = temp;

&emsp;&emsp;constructor函数“Car”函数体里面的的关键字“**this**”，就是新创建的空对象。


### 位于构造函数prototype上的方法

&emsp;&emsp;在实验里，我们在构造函数的prototype上定义了多个对象实例的方法。

&emsp;&emsp;这样，就可以从保存对象实例的变量名调用到相关的方法。

&emsp;&emsp;我们来多了解一下其中的细节。

&emsp;&emsp;首先在控制台运行以下代码：

    console.dir(car4);
    console.dir(car5);
    //关键点0:新对象的__proto__属性的数据类型也是对象
    console.dir(car4.__proto__);
    console.dir(car5.__proto__);
    //关键点1:新对象的__proto__属性和构造函数Car的prototype是同一个对象
    console.log('car4.__proto__ === Car.prototype:' + (car4.__proto__ === Car.prototype));
    console.log('car5.__proto__ === Car.prototype:' + (car5.__proto__ === Car.prototype));
    //关键点2：因而，两个新对象的__proto__也是同一个对象
    console.log('car4.__proto__ === car5.__proto__:'+ (car4.__proto__ === car5.__proto__));

    console.log('car4.start === car5.start:' + (car4.start === car5.start));
    console.log('car4.drive === car5.drive:' + (car4.drive === car5.drive));
    console.log('car4.brake === car5.brake:' + (car4.brake === car5.brake));
    console.log('car4.stop === car5.stop:' + (car4.stop === car5.stop));

&emsp;&emsp;在调试工具里面查看构造函数（constructor function）的prototype，可以看到：

 ![func_car_prototype](/public/img/js/func_car_prototype.png){:width="500px" height="400px"}

&emsp;&emsp;在调试工具里面监控“car2”变量的详情可以看到：

 ![car2_method_on_prototype](/public/img/js/car2_method_on_prototype.png){:width="500px" height="400px"}

&emsp;&emsp;在调试工具里面监控“car2”变量的详情可以看到：

 ![car3_detail_about_prototype](/public/img/js/car3_detail_about_prototype.png){:width="500px" height="400px"}

>总结：<br/>
  1. 当我们调用car4或者car5对象上的方法时，JS引擎能自动到对象内部的“**\__proto\__**”属性上找到相同名字的方法；<br/>
  2. 被调用的方法里面的关键字“**this**”始终跟发起方法调用的新对象（在这里分别是car4和car5）是同一回事。

&emsp;&emsp;

&emsp;&emsp;

# 实验五：扩展Date对象

目的：借助于Chrome DevTools的控制台工具，掌握如何定义一个JavaScript对象。

&emsp;&emsp;我们已经掌握如何用构造函数（constructor）创建数组和字符串对象，也知道各自构造函数的prototype属性特征。

&emsp;&emsp;日期对象的构造函数是JavaScript标准库函数Date。Date也有一个prototype属性，饿哦们可以通过它给所有日期对象增加新方法。

## 给日期对象增加新方法

### 复制日期对象

&emsp;&emsp;当两个变量指向同一个对象的时候，通过其中一个变量修改对象，则另外一个变量的值也会受到影响：

    var date1 = new Date(2008, 1, 10);
    var date2 = date1;
    console.log("date1:{"+date1 + "},date2:{" + date2+"}");
    date2.setDate(20);
    console.log("date1:{"+date1 + "},date2:{" + date2+"}");

&emsp;&emsp;我们来定义一个复制日期对象的方法：

    Date.prototype.copy = function () {
      return new Date(this.getTime());
    };

&emsp;&emsp;然后用它来生成一个新的日期对象：

    var oldDate = new Date(2008, 1, 10);
    var newDate = oldDate.copy();
    console.log("oldDate:{"+oldDate + "},newDate:{" + newDate+"}");
    newDate.setDate(20);
    console.log("oldDate:{"+oldDate + "},newDate:{" + newDate+"}");

&emsp;&emsp;**copy**方法返回了一个跟原对象内容一样的新对象，修改newDate不会影响原来的对象：

 ![date_copy_effect](/public/img/js/date_copy_effect.png){:width="600px" height="500px"}

### 获取月日信息

&emsp;&emsp;下面我们来定义几个方法，用他们来查询一个给定日期对象的月份名称，还有它是本周星期几的方法。

&emsp;&emsp;第一步：定义两个基本数组：

    Date.prototype.DAYNAMES = 
       ["Sunday", "Monday", "Tuesday", "Wednesday", 
       "Thursday","Friday", "Saturday"];
    Date.prototype.MONTHNAMES = 
       ["January", "February", "March", "April", "May", "June", 
       "July", "August", "September", "October", "November","December"];

&emsp;&emsp;第二步，在Date.prototype上定义相关方法：

    Date.prototype.getWeekDayName = function() {
      return this.DAYNAMES[this.getDay()];
    };
    
    Date.prototype.getFullMonthName = function() {
      return this.MONTHNAMES[this.getMonth()];
    };

&emsp;&emsp;测试：

    var example_date = new Date(2008, 1, 20);
    console.log("WeekDayName: " + example_date.getWeekDayName() +
      ",\tMonth Name: " + example_date.getFullMonthName());

    var current_date = new Date();
    console.log("WeekDayName: " + current_date.getWeekDayName() +
      ",\tMonth Name: " + current_date.getFullMonthName());

&emsp;&emsp;控制台输出：

 ![date_get_weekday_month_name_test](/public/img/js/date_get_weekday_month_name_test.png){:width="600px" height="500px"}

### 日期时间显示格式

&emsp;&emsp;极端一天里的具体时间，有12小时分段计时法和24小时计时法。

&emsp;&emsp;接下来我们分别定义两个方法来完成这两个功能。

&emsp;&emsp;12小时分段计时法：

    Date.prototype.to12HourTimeString = function () {
    var h = thi  s.getHours();
      var m = "0" + this.getMinutes();
      var s = "0" + this.getSeconds();
    
      var ap = "am";
    
      if (h >= 12) {
       ap = "pm";
    
       if (h >= 13)
       h -= 12;
    
      } else if (h == 0)
       h = 12;
      }
    
      h = "0" + h;
      return h.slice(-2) + ":" +
       m.slice(-2) + ":" +
       s.slice(-2) + " " + ap;
    };

&emsp;&emsp;24小时计时法：

    Date.prototype.to24HourTimeString = function () {
      var h = "0" + this.getHours();
      var m = "0" + this.getMinutes();
      var s = "0" + this.getSeconds();
      return h.slice(-2) + ":" + m.slice(-2) + ":" + s.slice(-2);
    };

&emsp;&emsp;测试：

    var dte = new Date(2008, 1, 20, 19, 30, 5);
    console.log(dte.to12HourTimeString() + "||" + dte.to24HourTimeString());
    var currentDate = new Date();
    console.log(currentDate.to12HourTimeString() + "||" + currentDate.to24HourTimeString());

### 查询当月天数

&emsp;&emsp;我们来进行一个有趣的测试。

&emsp;&emsp;向上溢出：

    var d = new Date(2016, 9, 31);
    console.log('2016年10月31日:'+d);

    var d = new Date(2016, 9, 32);
    console.log('2016年10月32日:'+d);

    var d = new Date(2016, 9, 33);
    console.log('2016年10月33日:'+d);

    var d = new Date(2016, 9, 34);
    console.log('2016年10月34日:'+d);

&emsp;&emsp;向上一个月溢出：

    var d = new Date(2016, 9, 1);
    console.log('2016年10月1日:'+d);

    var d = new Date(2016, 9, 0);
    console.log('2016年10月0日:'+d);

    var d = new Date(2016, 9, -1);
    console.log('2016年10月-1日:'+d);

&emsp;&emsp;闰年是很特殊的情况：

    var d = new Date(2008, 2, 0);
    console.log('2008年3月0日:'+d);

    var d = new Date(2012, 2, 0);
    console.log('2012年3月0日:'+d);

    var d = new Date(2016, 2, 0);
    console.log('2016年3月0日:'+d);

&emsp;&emsp;获取当月最后一天的数字(这个月有多少天)，不需要考虑什么闰年、大小月，只需要获取到下一个月第０天的日期对象，它就代表了当月的最后一天：

    Date.prototype.lastday = function() {
      var d = new Date(this.getFullYear(), this.getMonth() + 1, 0);
      return d.getDate();
    };

&emsp;&emsp;测试：

    var d = new Date(2008, 1, 5);
    console.log('2008年2月5日,当月天数：'+d.lastday());

    var d = new Date(2016, 1, 10);
    console.log('2016年2月10日,当月天数：'+d.lastday());

    var d = new Date(2016, 5, 5);
    console.log('2016年6月5日,当月天数：'+d.lastday());

    var d = new Date(2016, 9, 5);
    console.log('2016年10月5日,当月天数：'+d.lastday());


&emsp;&emsp;控制台输出：

 ![date_getlastday_test](/public/img/js/date_getlastday_test.png){:width="600px" height="500px"}

### 计算两个日期的间隔天数

&emsp;&emsp;实际应用开发的过程中，我们经常会遇到要根据两个日期计算它们之间的天数的需求。

&emsp;&emsp;第一步，在对象的prototype上定义一个常量，它表示一天所包含的毫秒数：

    Date.prototype.msPERDAY = 1000 * 60 * 60 * 24;

&emsp;&emsp;第二步，定义具体方法：

    Date.prototype.getDaysBetween = function(d) {
      d = d.copy();//复制一个新对象
    
      d.setHours(this.getHours(), this.getMinutes(), this.getSeconds(),
      this.getMilliseconds());//对齐时间
    
      var diff = d.getTime() - this.getTime();//获取两个日期时间之间相差的毫秒数
      return (diff)/this.msPERDAY;//this.msPERDAY可以访问到第一步定义的常量
    };

&emsp;&emsp;测试：
    
    function displayInfo(days){
     if (days > 0)
       console.log("The given day is " + days + " after today.");
     else if(days < 0)
       console.log("The given day is " + Math.abs(days) + " before today.");
     else
       console.log("Just today !!");
    }

    var today = new Date();
    var d1 = new Date(1921, 6,1);
    var d2 = new Date(1949, 9, 1);
    var d3 = new Date(2049,6,1);
 
    var days1 = today.getDaysBetween(d1);
    displayInfo(days1);
    var days2 = today.getDaysBetween(d2);
    displayInfo(days2);
    var days3 = today.getDaysBetween(d3);
    displayInfo(days3);

### 给定日期一年里过去的天数

&emsp;&emsp;结合已有的知识，我们还可以扩展一个方法，用于计算给定日期一年里已经过去的天数：

    Date.prototype.getDayOfYear = function() {
    //找到当年第一天的日期对象:
      var start = new Date(this.getFullYear(), 0, 1);
    //要把当年第一天也加进去
      var count = this.getDaysBetween(start) ;
      var dayOfYear =Math.abs(count) + 1;
      return dayOfYear;
    };

&emsp;&emsp;测试：

    var today = new Date();
    var dayOfYear = today.getDayOfYear();
    console.log('今天是本年度的第' + dayOfYear + "天！");


