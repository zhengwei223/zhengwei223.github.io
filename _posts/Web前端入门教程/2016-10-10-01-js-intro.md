---
layout: post
title: JavaScript入门
category: Web前端入门教程
tags: Web前端
description: JavaScript语言入门介绍
author: 曹小虎
keywords: lanqiao 蓝桥 全栈 教程 Web前端
description: JavaScript是一种所有的Web浏览器都能理解的编程语言，通过编写JavaScript代码，你可以在自己的网页里面加入何种各种动态交互功能，为用户提供更好的体验和更强大的功能。
---

> 本章目标

- 第一行JavaScript代码
- JavaScript概述
- ECMAScript标准
- JavaScript语法
- JavaScript自定义类和对象

# 实验一：JavaScript初体验

目的：借助于Chrome DevTools的控制台工具，熟悉JavaScript语言的强大功能。

## 1.1 写下你的基本信息

&emsp;&emsp;首先，请打开Chrome DevTools，选中控制台“console”面板。你可以把鼠标光标放置到控制台的第一行。


&emsp;&emsp;首先在控制台写下你的姓名，回车，比如我是蓝桥的弟弟“蓝天”：

    "蓝天"

&emsp;&emsp;继续在控制台输入下面的代码,回车，查看控制台输出：

    typeof("蓝天");

&emsp;&emsp;第二步，在控制台输入你的年龄，比如说今年二十二岁：

    22

&emsp;&emsp;同样，控制台输入下面代码，回车：

    typeof(22);

 ![js_tutorial_open_dev_tools_console](/public/img/js/js_tutorial_open_dev_tools_console.gif)



## 1.2 在控制台计算真值表

&emsp;&emsp;我们在高中的数学课上都学过真值表，现在我们就以“*与*”运算为例，在DevTools的控制台里面计算真值表。

&emsp;&emsp;在控制台输入下面的代码：

    /*
      1.JS关键字var开头，表示这是一个定义变量的表达式
      2.p和q两个字母是变量的名称
      3.等号“=”在这里是一个赋值符号
      4.等号“=”右边的“true”和“false”是一个布尔类型的字面量
     */
    //第一段
    var p = true;
    var q = true;
    var r = p&&q;
    console.log(r);
    console.log(typeof(r));
    //第二段
    var p = true;
    var q = false;
    var r = p&&q;
    console.log(p&&q);
    //第三段
    var p = false;
    var q = true;
    var r = p&&q;
    console.log(r);
    console.log(typeof(r));
    //第四段
    var p = false;
    var q = false;
    console.log(p&&q);
    var r = p&&q;
    console.log(r);
    console.log(typeof(r));
    //第五段
    typeof(true);
    typeof(false);

&emsp;&emsp;同学们可以按照图片的演示，在控制台执行第二段到第五段代码,并且留意，运算结果是否符合真值表。

 ![js_tutorial_in_dev_tools_02](/public/img/js/js_tutorial_in_dev_tools_02.gif)

&emsp;&emsp;我们来创建存放姓名年龄的变量：

    var name = "蓝天";
    console.log(name);
    console.log(typeof(name));
    var age = 22;
    console.log(age);
    console.log(typeof(age));

&emsp;&emsp;在控制台运行代码：

 ![js_tutorial_in_dev_tools_03](/public/img/js/js_tutorial_in_dev_tools_03.gif)

## 1.3 函数：领导干部有态度

&emsp;&emsp;有一天，学生会主席打电话叫来了小张、小李和小马三个同学，在他们三个人面前宣布一个紧急任务，然后请他们谈一谈各自需要几天完成。

&emsp;&emsp;我们来看看下面这段代码：

    var zhang = 3; //小张说我要三天时间
    var li = 5 ; //小李说我要五天时间
    var ma =2;  //小马说我可以两晚上不睡觉，两天48小时时间保证完成任务

&emsp;&emsp;我们来看学生会主席心里怎么计算：

    function attitudeOfChairman(dayLimit){
      var expectedDayCount = 3; //这件事最好能三天完成，但是为防万一，当然能提前一点是一点
      if(dayLimit > expectedDayCount){
        console.log("超过三天，时间太长了，我不放心");
      }else if(dayLimit == expectedDayCount){
        console.log("嗯，还不错，值得考虑......");
      }else if(dayLimit < expectedDayCount){
        console.log("好极了，我要跟他谈谈，了解清楚他能否保证质量！");
      }else{
        console.log("情况不明，无法做出有效判断！");
      }
    }

&emsp;&emsp;当然，然后他们三个就把自己的答案挨个报告出去：

    /* 想要知道人家的态度，先得说出自己的答案 */
    attitudeOfChairman(zhang);
    attitudeOfChairman(li);
    attitudeOfChairman(ma);

&emsp;&emsp;在控制台执行这些代码：

 ![js_tutorial_in_dev_tools_04](/public/img/js/js_tutorial_in_dev_tools_04.gif)

&emsp;&emsp;这个时候，如果有人给出其他其他答案，这位学生会主席又会怎么想呢？

    attitudeOfChairman("我心里没底");

&emsp;&emsp;在控制台上执行这段代码：

 ![js_tutorial_in_dev_tools_06](/public/img/js/js_tutorial_in_dev_tools_06.gif)

## 1.4 编写有数学计算能力的功能单元

&emsp;&emsp;Math是最常见的一个JavaScript内置对象。

### 认识JS内置对象Math

&emsp;&emsp;我们可以在控制台上很方便地查看对象的内容，[Math对象](http://www.w3school.com.cn/jsref/jsref_obj_math.asp)的属性中有很多是常量，比如圆周率；也有很多是*函数*类型，比如sin、cos这些一眼就能看出来的三角函数。

 ![js_tutorial_in_dev_tools_07](/public/img/js/js_tutorial_in_dev_tools_07.gif)

&emsp;&emsp;

### 计算地球的体积

&emsp;&emsp;已知地球的平均半径是6376.5千米，如何计算地球的大概体积？下面的函数将会计算出地球的大概体积：

    function getVolumeOfSphere(radius){
      //球体体积计算公式
      var volume = (4/3)*(Math.PI)*(Math.pow(radius,3))
      //返回计算结果
      return volume;
    }

&emsp;&emsp;在控制台调用这个函数：

    //用变量保存函数的返回结果
    var v = getVolumeOfSphere(6376.5);
    console.log(v+"立方千米");

&emsp;&emsp;得到实验结果:

 ![js_tutorial_in_dev_tools_08](/public/img/js/js_tutorial_in_dev_tools_08.gif)

&emsp;&emsp;除此之外，我们只要把球体的半径作为参数传入，就可以反复调用“*getVolumeOfSphere*”这个函数，从而得到相关球体的的体积。


### 完成四舍五入运算

&emsp;&emsp;四舍五入算法是最常见的一种保留小数精确性的计算方法，Math对象上就有一个完成这个功能的工具函数。

    console.log(Math.round(0.60)) ;  
    console.log(Math.round(0.50)) ; 
    console.log(Math.round(0.49)) ; 
    console.log(Math.round(-4.40)); 
    console.log(Math.round(-4.60)); 

&emsp;&emsp;在控制台运行上面的代码，可以看到：

 ![js_tutorial_in_dev_tools_09](/public/img/js/js_tutorial_in_dev_tools_09.gif)


## 1.5 今夕何夕：使用日期

&emsp;&emsp;另外一个很重要的[JavaScript内置对象是Date](http://www.w3school.com.cn/jsref/jsref_obj_date.asp)，它主要被用来处理日期和时间。

&emsp;&emsp;我们来演示两个小例子。

### 当前时间

&emsp;&emsp;在控制台输入下面的代码：

    var now = new Date();
    console.log(now.getFullYear());//现在是哪一年？
    /* （0~11，返回0表示1月，返回11表示12月，以此类推） */
    console.log(now.getMonth())//现在是那一月？
    console.log(now.getDate());//几号了？（1~31）
    console.log(now.getHours());//时？
    console.log(now.getMinutes());//分？
    console.log(now.getSeconds());//秒？
    console.log(now.getMilliseconds());//毫秒？
    console.log(now.getTime())//返回 1970 年 1 月 1 日至今的毫秒数

&emsp;&emsp;在控制台执行下面的代码：

 ![js_tutorial_in_dev_tools_10](/public/img/js/js_tutorial_in_dev_tools_10.gif)


### 自定义时间

&emsp;&emsp;已知2016年是一个闰年，我们来定义一个有意思的日期：

     /*
      一年中第二个月的第29天
      注意：JS日期中getDay方法的取值范围是1~31
     */
    var d1 = new Date(2016,1,29);
     /*
      一年中第三个月的第0天
      注意：JS日期中getDay方法的取值范围是1~31
     */
    var d2 = new Date(2016,2,0);

    console.log(d1);
    console.log(d2);
     /* 比较两个日期对象是否“相等” */
    console.log(d1===d2);
     /* 比较两个日期对象是否“相等” */
    console.log(d1==d2);
     /* 比较两个日期对象的时间是否“相等” */
    console.log(d1.getTime()===d2.getTime());
    
     /*
      一年中第三个月的第-1天
      注意：JS日期中getDay方法的取值范围是1~31
     */
    var d3 = new Date(2016,2,-1);
    console.log(d3);
     /* 比较d2是否大于d3 */
    console.log(d2>d3);
     /* 比较d2是否小于d3 */
    console.log(d2<d3);

&emsp;&emsp;在控制台执行以上代码，可以看到：

 ![js_tutorial_in_dev_tools_11](/public/img/js/js_tutorial_in_dev_tools_11.gif)


# 实验一的解读

## JS基础

### 字面量

&emsp;&emsp;JavaScript语言的基本数据类型，他们分别是字符串（String）、数字（number）和布尔值（boolean）。

&emsp;&emsp;我们在控制台输入的人名“蓝天”是***字符串字面量***，年龄“24”是***数字字面量***。此外，布尔值“true”和“false”分别是***布尔值字面量***。

&emsp;&emsp;根据MDN社区的定义，所谓字面量就是：由语法表达式定义的常量；或，通过由一定字词组成的语词表达式定义的常量。

>在JavaScript中，你可以使用各种字面量。这些字面量是脚本中按字面意思给出的固定的值，而不是变量。

&emsp;&emsp;除了三种基本数据类型的字面量，以后我们还会学到和用到更多类型的字面量。


### 变量

&emsp;&emsp;与代数一样，JavaScript 变量可用于存放值（比如 x=2）和表达式（比如 z=x+y）。

&emsp;&emsp;变量可以使用短名称（比如 x 和 y），也可以使用描述性更好的名称（比如 age, sum, totalvolume）。

&emsp;&emsp;在JavaScript语言中，声明和定义一个变量需要写出一个以关键词***var***开头、以英文字符（;）结尾的表达式。

- 变量必须以字母开头
- 变量也能以 $ 和 _ 符号开头（不过我们不推荐这么做）
- 变量名称对大小写敏感（y 和 Y 是不同的变量）

&emsp;&emsp;一般情况下，变量的声明和定义都会一气呵成，就像这样：

    var name = "蓝天";

&emsp;&emsp;或者是

    var age = 24;

&emsp;&emsp;结果正如已经看到的。

&emsp;&emsp;然而，在二般情况下，对于一个新的变量也可以只声明、不赋值。就像这样：

    var myWords ;
    console.log(myWords);
    myWords = "学无止境";
    console.log(myWords);

&emsp;&emsp;你在控制台上执行这几行代码，你就会发现，控制台第一次打印“myWords”的时候，打印了一行“undefined”。这可是“未定义”啊！在这种情况下，JS引擎不知道你打算说什么，别无选择，只好报告这是一个“未定义”的变量。

&emsp;&emsp;在JavaScript中，***undefined***是一个非常特殊的字面量，它被用来给“未定义”的变量充当**占位符**。

### 运算符和运算表达式

&emsp;&emsp;逻辑运算符：在进行两个布尔值的“*与*”运算时，我们用到了“*&&*”的运算符。

&emsp;&emsp;数学运算符，比如说乘号（*）、大于号（>）和小于号（<）；

&emsp;&emsp;等性运算符：检查两个变量是否相等的（===）和（==）。

&emsp;&emsp;凡是运算符出现的地方，必定有参与运算的各种字面量和变量。广义地说，运算符和参与运算的字面量或常量合在一起组成一个完整的运算表达式，或赋值、或求、或求乘积、或者比较大小。

&emsp;&emsp;关于这个问题，大家可以参考页面：[MDN 运算符和表达式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators)。

&emsp;&emsp;

&emsp;&emsp;

## JS函数

&emsp;&emsp;JavaScript函数（function）被设计成专门完成一个计算任务的基本运算单位。就像一个机器一样，函数的要做的就是，根据输入，输出计算结果：

 ![Function_as_machine](/public/img/js/Function_as_machine.jpg){:width="300px" height="200px"}

&emsp;&emsp;我们可以在JS代码中通过特殊的语法发起计算任务，这个发起计算任务的动作就是“调用函数一个”。

### 关键字function和函数名

&emsp;&emsp;实验一里，我们定义过两个名称分别是“attitudeOfChairman”和“getVolumeOfSphere”的函数，它们与“*function*”关键字之间都有空格分隔。


### 参数列表和函数返回值

&emsp;&emsp;以实验一计算球体体积的函数为例。

&emsp;&emsp;它可以送外部接收*一个*参数，此参数在函数内部作为球体的半径参与运算。

&emsp;&emsp;函数结尾处，有一个关键字“return”开头的*返回表达式*，计算结果将会因此被送回到调用函数的地方。

&emsp;&emsp;另外一个函数“attitudeOfChairman”，从外部接收一个参数，但是函数体执行完以后没有返回任何内容。这种情况下，如果声明一个新变量来保存函数调用的返回值，那么这个新变量的值就会成为*undefined*。


### 函数体

&emsp;&emsp;包含在一对花括号之间的内容就是函数体，其中包含了函数被调用时要执行的代码。这里往往是一个复杂而且完整的计算过程。


### 函数内置对象arguments

&emsp;&emsp;根据JavaScript规范，所有函数都有一个名字是*arguments*的内置对象。

&emsp;&emsp;你可以把下面的代码插入到“attitudeOfChairman”的函数体的开头，并且重新运行一次。

    console.dir(arguments);
    console.log(arguments);

&emsp;&emsp;结果可以看到*arguments*对象里面，保存了外界调用函数时传入的参数。

 ![js_tutorial_func_arguments_01](/public/img/js/js_tutorial_func_arguments_01.png)


&emsp;&emsp;此外，函数的*arguments*对象还有一些特别的用途。以代码为例，请看：

    function multiNumOfParamsAdd(){
        var tempValue = 0;
        for(var i=0;i<arguments.length;i++){
            tempValue = tempValue + arguments[i];
        }
        return tempValue;//返回计算结果
    }
    
    var result = multiNumOfParamsAdd(2,3,4,5,6,7,8,9);//使用变量"result"来保存函数计算输出
    console.log('the result is:'+result);

    function addTwoArguments(){
        //从arguments对象里面取出前两个参数，计算它们的和
        var result = arguments[0] +arguments[1];
        return result;
    }

    var sum = addTwoArguments(3,6);
    console.log(sum);


### 匿名函数

&emsp;&emsp;匿名函数就是没有名字的函数，这种函数只能在定义它的同时立即调用。

    /*
      没有名字的函数是匿名函数
      调用匿名函数的步骤是：
      1.是用一个小括号把函数定义包装起来
      2.紧随着一对小括号表示函数定义完之后立即调用它
     　3.在第二对小括号里面传入参数
    */
    var myResult =(function (){
        return arguments[0] + arguments[1];
    })(3,4);
    console.log('myResult is:'+myResult);


### 把函数赋值给变量

&emsp;&emsp;函数在JavaScript里面也是一种数据类型，我们可以按照下面的格式定义一个函数类型的变量：

    var myFunc =  function(){
        console.log('这是执行函数留下的痕迹......');
    }
    console.log(typeof myFunc);//function
    
    myFunc();

&emsp;&emsp;把“myFunc”作为参数传入另外一个函数：

    function my2Func(f){
        f();//调用传入的函数
    }
    my2Func(myFunc);//mySecondFunc is invoked!

&emsp;&emsp;

## JavaScript的作用域

&emsp;&emsp;实验一我们演示了“Math”工具提供的多个常量和数学函数。

&emsp;&emsp;除此之外，我们也演示了使用“Date”函数创建表示日期和时间变量。

&emsp;&emsp;除了在控制台上直接访问“Math”对象和“Date”函数，我们还在自定义的*函数*内部访问它们。其中*getVolumeOfSphere*的函数体里面就用到了（*Math.PI*）和（*Math.pow*）两个数学函数。

 ![js_tutorial_in_dev_tools_12](/public/img/js/js_tutorial_in_dev_tools_12.gif)

&emsp;&emsp;下面是在函数里面创建日期的例子：
 
 ![js_tutorial_in_dev_tools_13](/public/img/js/js_tutorial_in_dev_tools_13.gif)

&emsp;&emsp;JS语言里的作用域，其实就是一个变量、对象和函数的集合。

>In JavaScript, scope is the set of variables, objects, and functions you have access to.


### local

&emsp;&emsp;在函数执行过程中声明的变量、对象和函数一起组成函数的local（本地）作用域。

&emsp;&emsp;以函数调用过程为参照，它们在函数函数执行完以后会被**清理掉**，因而也可以说是函数的本地（local）变量。

&emsp;&emsp;在getVolumeOfSphere函数内部，我们把计算得到的球体体积赋值给新声明的变量*volume*。函数执行完以后，这个变量就不存在了：在函数外部也找不到它的声明，更不用提什么赋值和定义了！

 ![js_tutorial_in_dev_tools_14](/public/img/js/js_tutorial_in_dev_tools_14.gif)


### global

&emsp;&emsp;JavaScript语言标准库预定义了包括“Math”对象和“Date”函数在内的许多函数和对象，它们一起组成了一个**global**作用域。详细情况，大家可以查看MDN的[JavaScript语言的标准库](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects)页面。

&emsp;&emsp;其他变量（包括函数类型的变量），只要没有声明和定义在任何其他函数里面，比如实验一里面用过的两个函数*attitudeOfChairman*和*getVolumeOfSphere*，都默认位于**global**作用域。


&emsp;&emsp;

&emsp;&emsp;

# 实验二：从一到多——认识JS数组

目的：借助于Chrome DevTools的控制台工具，掌握JavaScript数组的定义和常用操作。

&emsp;&emsp;我们经常会把一次会议要用到的几份纸质文件资料按*顺序*放进一个文件夹里。在使用JavaScript语言的时候，我们可以用一个数组保存多条数据内容。

&emsp;&emsp;我们将会在数组里面不记名地存入班上任意10名同学英语科目的期末考试成绩。

## 2.1 创建数组

&emsp;&emsp;下面两种办法都可以创建数组。

### 数组字面量

&emsp;&emsp;可以用数组字面量来定义数组。

&emsp;&emsp;代码如下：

     console.time("Array initialize in literal");
     var  testScores = [55,65,74,88,43,22,77,91,66,87];
     console.timeEnd("Array initialize  in literal");
     console.log(testScores);//在控制台查看数组内容
     console.log(testScores.length);//在控制台查看数组长度


### 使用Array函数

&emsp;&emsp;在 JavaScript 中 Array 是一个用来构造数组的全局对象，我们也可以用它（constructor）创建新的数组变量。

&emsp;&emsp;代码如下：

     console.time("Array initialize in constructor");
     var  testScores = new Array(55,65,74,88,43,22,77,91,66,87);
     console.timeEnd("Array initialize  in constructor");
     console.log(testScores);//在控制台查看数组内容
     console.log(testScores.length);//在控制台查看数组长度

&emsp;&emsp;在控制台里面执行代码，可以看到，两种方法创建数组的效果完全相同。

 ![js_tutorial_array_in_dev_tools_1](/public/img/js/js_tutorial_array_in_dev_tools_1.gif)


## 2.2 访问数组

### 访问数组元素

&emsp;&emsp;我们可以用数字下标访问数组里面的单个元素。

&emsp;&emsp;代码如下：

    testScores[0];//数组第一个元素
    testScores[testScores.length-1];//数组最后一个元素
    testScores[testScores.length];//这样不会报错，但是找不到你想要的数据

    testScores[testScores.length] = 99; //向数组末尾加入新元素
    testScores    //查看数组详情
    testScores.push(21); //继续向数组末尾加入新元素
    testScores    //查看数组详情
    testScores.shift();//删除数组第一个元素
    testScores    //查看数组详情
    testScores.pop();//从数组末尾删除元素
    testScores    //查看数组详情
    testScores.length = testScores.length -1;//再从数组末尾删除元素
    testScores    //查看数组详情

    //使用for循环遍历数组元素
    for(var i=0;i<testScores.length;i++){
       console.log(testScores[i]);
    }

    //使用forEach函数遍历数组元素
    testScores.forEach(/* 参数函数开始 */function(e,index,arr){
       console.log("第" + index + '个数组元素的内容是:' + e);
    }/* 参数函数结束 */
    );
    
&emsp;&emsp;上述代码在控制台执行的运行效果如下：

 ![js_tutorial_array_in_dev_tools_02](/public/img/js/js_tutorial_array_in_dev_tools_02.gif)

### 数组的便捷工具

&emsp;&emsp;JavaScript标准库定义的为每一个数组类型的变量提供有多种工具方法，想知道JS数组的更多方法，请参考[W3School JavaScript Array 对象](http://www.w3school.com.cn/jsref/jsref_obj_array.asp)页面。

&emsp;&emsp;此外，只需要在控制台输入下面的代码，我们就可以在DevTools的控制台上看到Array类型变量支持哪些方法。

    //Array是JS全局作用域的一个函数，我们可以用它（constructor）创建新数组
    console.dir(Array.prototype);

&emsp;&emsp;结果如下：

 ![js_tutorial_array_in_dev_tools_02](/public/img/js/js_tutorial_array_in_dev_tools_03.gif)

&emsp;&emsp;根据这些函数的名字，我们应该大致猜到它们究竟是干什么的。比如说“reverse”就是一个反转数组的方法，“sort”就是一个给数组排序的方法。

&emsp;&emsp;有关数组类型变量的更多方法，请查阅[MDN JavaScript标准库-Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects)页面。


# 实验二的解读

# 实验三：文字魔术师——操控String变量

目的：在Chrome DevTools的控制台里，学习使用JavaScript标准库的String类型对象处理文字内容。

>通过实验一，我们已经了掌握使用字面量定义一个字符串变量的方法。作为一种运行于Web浏览器里的编程语言，JavaScript标准库包含了丰富的应用编程接口（API），可以帮助程序员便捷高效地处理网页上的文字内容。

## 3.1 创建字符串对象

## 3.2 文字处理实例

# 实验四：象由心生——自定义JS对象


# 实验四的解读

# 实验五：扩展Date对象

# 1. 第一行JavaScript代码

&emsp;&emsp;早期网站前端技术的发展过程是先有HTML，后有CSS，最后才有JavaScript。HTML语言的作用是定义网页的结构和内容，CSS可以帮助开发者在一个地方统一定义网页的显示效果。人们最后决定在网页里面使用JavaScript，则是为了让网页“动起来”，更准确的说就是能根据人类在浏览器上进行的操作做出适当的“反馈”，跟那个正在访问网页的人“互动”起来。

&emsp;&emsp;在这一小节的最开始，我们将通过几个简单的小例子，帮助你认识到，JavaScript怎么能让网页动起来，又是怎么跟人“互动”起来。为了快速起步，我们将会在Chrome浏览器Developer Tools的控制台里面直接演示、运行JavaScript代码。

## 1.1 首选入门编程语言

### 无需安装配置运行环境

 ![javascript_engines](/public/img/js/javascript_engines.jpg){:width="400px" height="240px"}

&emsp;&emsp;为了支持JavaScript在浏览器内的运行，所有的现代浏览器都内置了一个JavaScript引擎，它可以非常高效、快速地分析、运行你的JavaScript代码。说它小是因为它被安装放置在本来就不大的浏览器软件里面。实际上，不单单是这个引擎有独特、复杂的内部结构，更主要的还在于，它会随着浏览器每一次的版本升级，被优化、升级，从而变得更强大、更高效。

&emsp;&emsp;关于对比不同类型JS引擎的这个问题，有兴趣的同学可以阅读[JS 引擎比较](https://developer.mozilla.org/zh-CN/docs/Mozilla/Projects/SpiderMonkey/Comparision_of_JS_engines)这篇文章，虽然我知道你肯定看不懂其中的内容，但我还是强烈建议你去见识一下JS引擎这个问题到底是多大的一个问题！有了这次的烧脑经验，你以后肯定会更加珍惜和抓住这来之不易的机会，发自内心地认真写好每一行JS代码。

### 在做中学

&emsp;&emsp;在学习的过程中，你愿意做一个考古学家还是一个建筑师？

&emsp;&emsp;当考古学家就意味着你要先投入大量时间到前人的工作成果里面去，你要知道很多他们总结出来的概念和理论，做很多别人认为重要、并且为你设计好的测试练习，等这之后，通常已经是不短的一段时间，你才能开始上手完成自己想要完成的作品。你一定很熟悉这种学习方法，但是大多数初学者对此也相当畏惧。这是传统学校课程的学习方法，学校的老师总是恨不得让你一夜之间掌握前人总结现来的全部知识、定理。但是，在没有任何动手经验的情况下，你确定自己听得懂他们在说什么吗？

&emsp;&emsp;当建筑师却大不一样，你可以首先在最短时间内掌握基本的规定动作，为自己的作品搭建基本框架，然后边做边学。最有效的学习方法需要能让你在学习的过程中，根据自己的进度等等实际情况，不断提出问题、解决问题、验证问题并且总结经验、提炼概念，同时养成动手能力，真正避免尴尬的纸上谈兵。它符合人类日常生活中的认识规律和学习规律。

&emsp;&emsp;这一切，在拥有了一个现代浏览器之后，你都可以借助于视觉可见的浏览器界面，还有从简单到复杂、从现象到本质的思维闭环，快速掌握使用一门编程语言的主要技能。

&emsp;&emsp;你可以在开发者工具的JS控制台里面直接编写、运行JavaScript。

### 进行服务器编程

&emsp;&emsp;近年来，NodeJS的出现让JavaScript语言已经从当初只能运行在浏览器里面的语言，变成了真正的一门Web应用编程语言。人们把NodeJS程序包安装到充当Web服务器的计算机上，程序员们可以用JavaScript语言编写专门的Web服务器程序，比如说访问网络、打开文件、查询数据库等等。NodeJS社区现在十分火爆，应用前景一片光明。

&emsp;&emsp;想一想，你不需要去学其他任何编程语言！只需要掌握一门JavaScript语言，你就可以从前到后一口气写出一个大型的企业网站。是不是很爽？



### 其他好处 

&emsp;&emsp;钱途无量。有经验的JavaScript程序员薪资一直在增长。市场上发布出来的JavaScript工作岗位也一直在增长。

&emsp;&emsp;丰富的学习资源。

&emsp;&emsp;广阔的应用前景。

## 1.2 改变网页内容

## 1.3 让网页跟人交互

# 2. JavaScript起源


 ![js_logo](/public/img/js/js_logo.png){:width="100px" height="80px"}

&emsp;&emsp;这一个章节的主要内容就是讲故事，告诉大家更多关于这一门技术背景知识。这些背景知识将会直接帮助你更好地理解和掌握与之相关的基本概念，并且让你深入理解互联网发展历史中所包含的现实逻辑。

&emsp;&emsp;我相信肯定有很多人都事先听说过Java，并且知道它最早由Sun公司（这家企业后来被Oracle收购）推出的广受欢迎的网络编程语言。JavaScript这个名词跟Java有什么关系，这个问题无论如何也无法绕开，现在我就抓紧时间来把它解释清楚。

## 2.1 JavaScript诞生

### 网景的LiveScript

&emsp;&emsp;网景（NetScape）公司是第一家尝试利用新生万维网的商业企业，它的是主要目标是为所有操作系统的用户提供跨平台一致的互联网使用体验。

 ![father_of_javascript](/public/img/js/brendan-eich.jpg){:width="100px" height="80px"}

&emsp;&emsp;大约在1994年的时候，网景公司的制定一了个产品战略：他们的浏览器浏览器产品将要够支持动态、可交互的网页。1995年，他们的领导找来了一个名字叫Brendan Eich的电脑程序员，请他来负责设计和实现这门可以在浏览器里面运行的编程语言。他仅仅花十天时间，就写出第一个版本的脚本（Script）语言，并且给它了个名字“Mocha”。当时这个早期版本的浏览器脚本语言还很不成熟，里面包含有很多bug，甚至有些问题一直保留到今天，仍然被认为是“臭名昭著”，但这都是后话。

&emsp;&emsp;后来网景公司的市场部门把这门语言的名字改为**LiveScript**。

### Sun公司积极参与

 ![javascript-vs-java-difference.jpg](/public/img/js/javascript-vs-java-difference.jpg){:width="400px" height="300px"}

&emsp;&emsp;当时Java语言已经是一门十分流行、广受欢迎的网站后端编程语言了，网景也希望新生的LiveScript语言能够像Java一样流行。考虑到两家在推动早期互联网普及发展方面的合作关系，Sun公司把Java商标的使用权授许给网景，于是原来的LiveScript更名为JavaScript。

&emsp;&emsp;1995年12月4日，网景和Sun公司联合发布了着一门新的浏览器编程语言，他们在公开场合称这门语言是“对HTML和Java语言的补充”。

&emsp;&emsp;Brendan Eich被后人尊成为JavaScript之父。

## 2.2 ECMAScript标准

&emsp;&emsp;首先解释一下ECMA这个名词，它的英文全称是European Computer Manufacturer’s Association，简称“欧洲计算机制造商联合会”。

&emsp;&emsp;我们基本上都猜得到，ECMAScript就个单词所代表的意思表明，它是一种以ECMA组织冠名的脚本语言了。

&emsp;&emsp;这是一门什么样的脚本语言？它跟JavaScript有什么关系？想要搞清楚这个问题，我们就必须提到网景公司当时最大的的竞争对手微软公司（Microsoft）,以及发生在两者之间、围绕着抢夺浏览器市场份额而展开的“浏览器大战”。

### 浏览器大战

&emsp;&emsp;坊间早有传闻，大约1994年的时候，财大气粗的微软十分看好网景公司的浏览器业务，因此计划出资收购后者。不知道是什么具体原因，收购的事情没谈下来，微软转回头就开始开发自己的浏览器Internet Explorer(简称IE)。

 ![ie-vs-netscape](/public/img/js/ie-vs-netscape.jpg){:width="300px" height="300px"}

&emsp;&emsp;1996年3月份，第一个引入了JavaScript新特性的现代浏览器Netscape Navigator 2.0浏览器问世。

&emsp;&emsp;微软看到竞争对手的浏览器因引入JavaScript新特性而取得的良好的市场效果，它们快速反应，很短时间之内，果断推出了自己的网页编程语言———**JScript**，随后他们推出的IE3更是成为第一款同时支持JScript编程语言和CSS的商用浏览器，IE浏览器的市场份额紧追Netscape。

&emsp;&emsp;网景和微软两家企业之间发生了以争夺浏览器市场份额为目标的激烈竞争整整持续了几年。最终的结果是，IE浏览器市场份额不断上升，直到形成事实上的垄断优势，而Netscape的浏览器市场份额被不断挤压。面对来自微软的巨大竞争压力，网景公司不得不逐步放弃自己的这款商用浏览器。1998年3月，他们选择把Netscape　Navigator浏览器的源代码公布在网上。

### Web标准的崛起

&emsp;&emsp;一方面，IE4浏览器在抢占市场份额的过程中之所以艺高一筹，有一个很重要的原因是，它比Netscape Navigator 4.0更好地匹配了**W3C**制定的网页标准。这一点不会被任何一个有商业头脑的生意人错过，大战双方通过总结市场上的经验教训，更加深刻地意识到了遵守公开的Web标准的巨大好处。

&emsp;&emsp;反面的教训是，浏览器大战中，微软和网景致力于实现新特性却忽视了修复这些特性中存在的问题。他们不断增加专有的特性，还以不兼容的方式创造与对方浏览器已有特性直接竞争的新特性。那时，开发者在创建网站时不得不应对与日俱增的混乱。他们有时要为两个主要浏览器建立不同但实际上重复的两个站点；有时则干脆选择只支持一种浏览器，另一浏览器用户就无法正常访问同一网站。

&emsp;&emsp;不久，这种糟糕的工作方式就不可避免地遭到了来自开发者的强烈抗议。

### ECMAScript标准

&emsp;&emsp;1996年11月，网景公司将JavaScript提交给欧洲计算机制造商协会进行标准化。

&emsp;&emsp;ECMA-262的第一个版本于1997年6月被Ecma组织采纳[3]。ECMAScript是由ECMA-262标准化的脚本语言的名称。ECMAScript标准成为浏览器内编程语言的标准。JavaScript和JScript与ECMAScript相容，但包含超出ECMAScript的功能。

&emsp;&emsp;ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会）通过ECMA-262标准化的脚本程序设计语言。 这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。

 ![ecmascript-history](/public/img/js/ecmascript-history.png){:width="700px" height="600px"}


### ECMAScript现状以及前景

 ![ecma_script_scope](/public/img/js/ecma_script_scope.jpg){:width="250px" height="250px"}


### 微软

### Google

### Mozilla

## 2.3 未来的Web浏览器编程

# 3.JavaScript基本语法

## 3.1 基本数据类型

&emsp;&emsp;数据类型在编程语言的世界里是非常重要的概念。只有选择正确的数据类型，才能得到有意义的计算结果。

&emsp;&emsp;JavaScript语言有４种原始数据类型：字符串（String）类型、数字（number）类型、布尔（boolean）类型、未定义（undefined）类型。


### 字符串

&emsp;&emsp;想要声明一个新的变量，你需要用到关键词“**var**”（**variable**）。

&emsp;&emsp;“＝”表示一个给变量赋值的表达式，等号左边是变量名，等号右边是变量值：

    //声明一个变量
    var someValue　;  
　　　　//一次赋值
    someValue = "Foo";　
    console.log(typeof someValue); //strig
　　　　//二次赋值　
    someValue = 'Bar';
　　　　//变量可以多次赋值
    console.log(someValue);//　Bar
    console.log(typeof someValue); //strig


&emsp;&emsp;上面的例子里，JS引擎根据变量值中用到的双引号的写法，推断它的数据类型是字符串。我们用到了JS语言里面的**typeof**运算符，他可以告诉我们变量的类型信息。 

### 数字

&emsp;&emsp;JS引擎会把小数或者整数写法的变量，推断为数字类型。
    
    var num1 = 3.14;
    console.log(typeof num1); //number
    num1 = 100;
    console.log(typeof num1); //number

### 布尔型

&emsp;&emsp;布尔类型的数据只有两个值，true和false,主要用于流程分支选择:

    var flag1 = true;
    flag = false;
    console.log(typeof flag1); //boolean

### undefined 

&emsp;&emsp;声明变量但不赋值,JS引擎不知道变量是什么值，更不知道什么类型：

    var otherValue ;
    console.log(otherValue);//undefined
    console.log(typeof otherValue);

### JS引擎自动判断数据类型

&emsp;&emsp;JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据同一个变量，可以表示不同类型数据：

    var someValue = 100;
    console.log(typeof number);//string
    someValue ="Foo";
    console.log(typeof someValue);//string

### 声明一个常量

&emsp;&emsp;我们在初中教材里的代数基础知识里面学到过常数和变数的概念。与之类似，在编程语言的世界里，同时也有常量和变量的概念。

&emsp;&emsp;声明一个常量需要以“cnst”(constant)符号开头。

&emsp;&emsp;声明一个常量同时必须给它赋值。

    //声明一个常量，但是没有赋值，这段代码刚开始会执行错误
    const otherValue　;  
    otherValue = "Foo";　　
　　　　
　　　　/*
    如果尝试修改常量，JS引擎会提示错误：
    Uncaught TypeError: Assignment to constant variable.
    */
    otherValue = "Bar";
    console.log(otherValue);　


## 3.2 基本运算符

### 数字运算

    var num1 = 10;
    var num2 =5;
    console.log(num1+num2);//加法
    console.log(num1-num2);//减法
    console.log(num1*num2);//乘法
    console.log(num1/num2);//除法
    console.log(num1%num2);//求余数
    console.log(num1++);//自增１
    console.log(num1--);//自减一

### 赋值运算

&emsp;&emsp;最基本的赋值运算符就是“＝”，除此以外还有几个特殊的赋值符号。

### 字符串运算

&emsp;&emsp;“+”符号也可以被用来连接字符串。

    var firstWord = 'Hello';
    var sencondWord = 'World!';
    var wholeSentence = firstWord + secondWord;
    console.log(wholeSentence);

&emsp;&emsp;如果是在一个字符串和一个数字中间使用“+”的连接符号，结果会是在怎样？

    var firstWord = 'Hello';
    var num1 = 999;
    var result = firstWord + num1;
    console.log(result);
    console.log(typeof result);

### 布尔运算

&emsp;&emsp;在对两个变量比较大小的时候，会产生一个布尔型运算结果。

    var result = 4>3;
    console.log(result);
    console.log(typeof result);
    result = 4<3;
    console.log(result);
    console.log(typeof result);


## 3.3 条件语句

&emsp;&emsp;所有编程语言都有条件语句。

### if...else条件语句

    var someValue = 24 ;

    var otherValue = 23;

    /*
    一.一个最简单的if条件语句
    
    １．被检测的表达式用小括号包裹
    ２．检查表达式的结果是一个布尔值
    ３．如果表达式是一个“true”的时候
    ４．控制台会打印“first consition”
    */
    if(someValue < 30){
        //被执行的代码块被放在一对花括号里面
        console.log('first case');
    }
    
    
    
    /*
    二. 可选的else if语句
    
    1.if语句检测的表达式结果是false
    2.继续检查else if的条件表达式
    3.如果表达式结果是true
    4.控制台打印“second case”
    */
    if(someValue > 30){//条件１
        console.log('first case');//代码块３
    }else if(someValue<30){//条件２
        console.log('second case');//代码块２
    }else if(someValue == 24){//条件３
        console.log('third case');//代码块３
    }

    
    /*
    三.多个else if语句的情况
    1.按照从上到下的顺序
    2.条件２成立，代码块２被执行
    3.代码块２以下的所有语句会被跳过忽略
    
      思考：如何才能让控制台打印"third case"?
    */
    if(someValue > 30){//条件１
        console.log('first case');//代码块１
    }else if(someValue<30){//条件２
        console.log('second case');//代码块２
    }else if(someValue === 24){//条件３
        console.log('third case');//代码块３
    }
    
    /*
    四.末尾else语句
    如果前面几个条件都不满足，
    控制台会打印"fourth case"
    
    */
    if(someValue > 30){//条件１
        console.log('first case');//代码块１
    }else if(someValue===30){//条件２
        console.log('second case');//代码块２
    }else if(someValue === 25){//条件３
        console.log('third case');//代码块３
    }else{//末尾else语句
        console.log('fourth case');//代码块4
    }
    
    /*
    五.复杂的if条件表达式
    　1.两个表达式同时为true（不同表达式用两个“＆”符号连接），
    　　条件５成立
    　　执行代码块５
    */
    if(someValue>20 && otherValue>20){//条件５
        console.log('fifth case');//代码块５
    }
    
    /*
    　2.布尔值取反
    */
    var flag = false;
    if(!flag){
        console.log('if flag is not true, this code will be executed!');
    }else{
        console.log('if flag is true, this code will be executed!');
    }
    
    /*
    五.复杂的if条件表达式
    　1.两个表达式任意一个为true（不同表达式用“||”符号连接），
    　　条件6成立
    　　执行代码块6
    */
    if(someValue === 24 ||otherValue ===24){//条件６
        console.log('sixth case');
    }
    
    /*
    六. 常用的几个比较运算符
    　　1.大于 ">"
    */
    console.log(9>7);
    
    /*
    　　２.小于 "<"
    */
    console.log(9<7);
    
    
    /*
    　　３.等于 "=="
    */
    console.log(5==5);
    
    /*
    　　４.不等于 "!="
    */
    console.log(5!=5);
    
    /*
    　　５.全等于 "==="
    */
    var myResult = "";
    myResult = (someValue ===24) ? "equal" : "not equal";
    console.log(myResult);

    myResult = (someValue ==="24") ? "equal" : "not equal";
    console.log(myResult);
    
    /*
    　　６.不全等 "!=="
    */
    console.log("5"!==5);
    
    
    /*
     七.JavaScript的真值和假值
      1.几个特别的假值
    */
    
    var testResult = (false) ? "truthy" : "falsey";
    console.log(testResult);
    
    testResult = typeof 24/"Bob";
    console.log(testResult);
    testResult = (24/"Bob") ? "truthy" : "falsey" ;
    console.log(testResult);

    testResult = undefined ? "truthy" : "falsey" ;
    console.log(testResult);
    
    
    
    /*
      2.几个特别的真值
    */
    var someUndefinedValue;
    testResult = typeof someUndefinedValue ?  "truthy" : "falsey" ;
    console.log(testResult);
    
    testResult = (someValue ===24) ?  "truthy" : "falsey" ;
    console.log(myResult);
    
    testResult = (someValue ==="24") ?  "truthy" : "falsey" ;
    console.log(myResult);

    //testResult = (someValue !=="24") ?  "truthy" : "falsey" ;
    //console.log(myResult);

 
### switch语句

&emsp;&emsp;switch是一个JavaScript关键字,这个语句跟if语句可以相互替换。

&emsp;&emsp;下面是一个简单的示例:

    var userName = "Rimmer";
    
    /*
    switch是一个JavaScript关键字,
    1.小括号里面的switch表达式只会被计算一次
    2.switch表达式的值跟每一个case表达式的值比较
    3.如果两个值匹配相等,继续执行与case表达式关联的代码块
    4.每个case分之最后都有一个"break"关键字
    5.如果所有case分支都不能被匹配，直接执行default语句
    6.switch语句执行完毕
    */
    switch(userName){
        case "Lister":
        console.log("Care for a good curry?");
        break;
    
        case "Rimmer":
        console.log("Welcome back, smeg head!");
        break;
    
        default:
        console.log("Are you an emohawk?");
    }

&emsp;&emsp;如果switch表达式直接写成布尔值的"true",还可以通过在case表达是里面加入复杂语句的办法实现switch分支。请看下面的例子:

    var rightNow = new Date();
    var currentHour = rightNow.getHours();
    
    switch(true){
        case (currentHour >8 && currentHour <12):
        console.log("Morning, sunshine!");
        break;
    
        case (currentHour === 12):
        console.log("Lunch time!");
        break;
    
        case (currentHour >12 && currentHour <18):
        console.log("Fight the urge to siesta!");
        break;
    
        default:
        console.log("Careful sparky, they'll think you as a hard worker!");    
    }

## 3.4 循环语句


### while循环

    var i = 0;
    /*
    while后面小括号里面的while表达式
    1.测试while表达式是否为true:如果为true,继续第2步;否则跳到第5步
    2.如果为true,执行while代码块逻辑
    3.更新变量i的值,重复第１步
    4.直接跳出while循环
    */
    while(i<10){//１.检测while表达式
        console.log('current value i is ['+i+']');//2.while代码块逻辑
        i++;//3.更新变量i的值
    }
    console.log('while loop execution done!');//4.跳出while循环



### do...while循环

    var j =0 ;
    /*
    1.执行do后面花括号里面的代码块
    2.更新变量i的值
    3.测试while表达式是否为true:如果为true,继续第1步;否则跳到第5步
    4.直接跳出while循环
    */
    do{
       console.log('current value j is ['+j+']');//1.while代码块逻辑
       j++;   //2.更新变量i的值
    }while(j<10);//3.检测while表达式
    console.log('do while loop execution done!');//4.跳出while循环



### for循环

    /*
    1.声明并且初始化变量k=0
    2.检测k<10是否为true:如果是走第３步；反之，走第5步
    3.执行花括号里面的代码块
    4.k值自增１，重复第２步
    5.跳出for循环
    */
    for(var k = 0; k<10; k++ ){
       console.log('current value k is ['+k+']');
    }
    console.log('for loop execution done!');


## 3.5 函数

&emsp;&emsp;JavaScript函数（function）被设计成专门完成一个计算任务的基本运算单位。就像一个机器一样，函数的要做的就是，根据输入，输出计算结果：

 ![Function_as_machine](/public/img/js/Function_as_machine.jpg){:width="300px" height="200px"}

&emsp;&emsp;我们可以在JS代码中通过特殊的语法发起计算任务，这个发起计算任务的动作就是“调用函数一个”。



### 简单函数

&emsp;&emsp;我们必须先掌握如何定义一个简单函数。

    /*
    一.定义一个简单函数：
    1.JavaScript关键字"function"声明一个函数需要用
    2."fucntion"关键字之后空格，“myNewFunction”是函数名
    3.函数名之后，一对小括号里面是函数的参数列表
    4.一对花括号里面的是函数被调用时要执行的代码
    */
    function myNewFunction(){
        console.log('Hello, this is my first functuin!');
    }

&emsp;&emsp;然后在JS代码里面直接调用函数：

    /*
     5.调用函数的时候，你需要在函数名后面加上一对小括号
       这对小括号就是调用函数的运算符
    */
    myNewFunction();

&emsp;&emsp;还可以在HTML页面里面调用同一个函数:

    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" 
       "http://www.w3.org/TR/html4/strict.dtd">
    <HTML>
    <HEAD>
    <script type="text/javascript">
    function myNewFunction(){
        console.log('Hello, this is my first functuin!');
    }
    </script>
    </HEAD>
    <BODY>
       <h1>Invoke a function by button on html page</h1>
       <input type="submit" value="Click Me" onclick="myNewFunction();">
       </input>
    </BODY>
    </HTML>

[点击复制按钮并在打开新窗口粘贴、运行以上代码](/public/tiyEditor.html)  



### 带参数的函数

&emsp;&emsp;函数通过参数列表从外界接收输入。

    /*
     二.定义一个有参数的函数
     1.参数列表放在一对小括号里面
     2.多个参数用逗号隔开
    */
    function add (a,b){
        console.log('the value of a in add function is:'+a);
        console.log('the value of b in add function is:'+b);  
        var result = a + b;
        console.log('the result is:'+result);
    }

    /*
     调用函数的时候，
     你需要参考函数定义的参数列表，
     在一对花括号之间，把你的输入值传给函数
    */
    add(4,9);



### 函数内置对象arguments

&emsp;&emsp;所有的函数都有一个系统为它创建的内置对象，名字是arguments。这是一个类似数组的对象，里面保存了外界传给函数的全部参数：

    function multiNumOfParamsAdd(){
        var tempValue = 0;
        for(var i=0;i<arguments.length;i++){
            tempValue = tempValue +arguments[i];
        }
        return tempValue;//返回计算结果
    }
    
    var result = multiNumOfParamsAdd(2,3,4,5,6,7,8,9);//使用变量"result"来保存函数计算输出
    console.log('the result is:'+result);

&emsp;&emsp;arguments对象里面的元素数字下标从0开始算起，下面的例子里，我们从arguments对象里面取出前两个参数，计算它们的和，通过关键字“**return**”把结果返回到函数被调用的地方：

    function addTwoArguments(){
        var result = arguments[0] +arguments[1];
        return result;
    }

    var sum = addTwoArguments(3,6);//这里用一个新变量保存函数调用返回的结果



### 匿名函数

&emsp;&emsp;匿名函数就是没有名字的函数，这种函数只能在定义它的同时立即调用。

    /*
      没有名字的函数是匿名函数
      调用匿名函数的步骤是：
      1.是用一个小括号把函数定义包装起来
      2.紧随着一对小括号表示函数定义完之后立即调用它
     　3.在第二对小括号里面传入参数
    */
    var myResult =(function (){
        return arguments[0] + arguments[1];
    })(3,4);
    console.log('myResult is:'+myResult);



### 函数也是一种数据

&emsp;&emsp;函数在JavaScript里面也是一种数据类型，这一点我们可以通过"typeof"运算符得到证实：

    function mySecondFunc(){
        console.log('mySecondFunc is invoked!');
    }
    console.log(typeof mySecondFunc);//function

&emsp;&emsp;既然是数据，肯定也可以把它当成参数传到别的函数里面去，然后那个函数里面调用被传进来的函数：

    function myThirdFunc(f){
        f();//调用一个函数的方法就是："函数名()"
    }
    myThirdFunc(mySecondFunc);//mySecondFunc is invoked!

---

# 4.JavaScript组合数据类型

## 4.1 对象

&emsp;&emsp;本来“对象”这个词没有任何特殊含义，就像我们中国人经常用到的“东西”这个词，我们可以说“张三不是个东西”，甚至还可以说“张三是个XX东西”。这两种说法都没有错误。因为“东西”这个“概念”，从逻辑学的角度来说，叫做内涵无限小、外延无限大，说白了“东西就是框，什么都能装”。

&emsp;&emsp;“对象”这个词，在现代汉语词典里面的含义是：“行动或思考时作为目标的人或事物”，比如说张三的女朋友就可以说是他的“对象”，因为张三肯定把它的女朋友当成思考和行动的目标。

 ![thinking_einstein](/public/img/js/thinking_einstein.jpg){:width="200px" height="100px"}

&emsp;&emsp;好了，言归正传，我们回到编程语言的世界。

&emsp;&emsp;在特定情景下，我们人类经常会遇到“一堆”相互之间关系密切的**基本类型数据**，我们还必须考虑跟这些数据有关的**计算过程**。为了更简单、直接的描述我们要思考的这个“东西”，或者说是“事物”，我们采用了一种方法：把它们按照某个秩序，“组合”在一起，记录成一种特别的**复合数据类型**，就是“对象”。在编程语言的世界里，有一个流行说法是，“一切都是对象”。



### 汽车是一个对象

&emsp;&emsp;让我们从一辆汽车开始，描述一个JavaScript对象：

 ![objectExplained](/public/img/js/objectExplained.png){:width="700px" height="600px"}

&emsp;&emsp;凡是汽车都有汽车的样子，我们把汽车**静态**特征用JavaScript语言的基本类型数据描述出来，就是对象的**属性**，然后把所有汽车能完成的**动作**和**功能**用函数模拟出来，就是对象的“方法”。

&emsp;&emsp;如果你认同莱布尼茨的话，“世界上没有两片完全相同的叶子”，那么你一定认可“世界上没有两辆完全相同的汽车”。在上路几年之后，每一辆汽车的内部属性（属性，property）会发生不一样的变化，比如主轴磨损；同一品牌的不同汽车，也会被车主以不同方法操作使用，引起行驶能力的巨大差异：类似，在JavaScript语言中，不同的对象也可以保存不同的**内部状态**，甚至不同的**外部行为**。


### 定义一个空对象

&emsp;&emsp;定义一个对象最简单的方法是使用一对花括号：

    var emptyObj = {};//空对象内部不包含任何属性和方法
    
    console.log(typeof emptyObj);//object

### 包含属性和方法的汽车对象

&emsp;&emsp;一个非空对象的属性和方法放在“{”和“}”之间：

    /*
     1. 用关键词var开头声明一个名称为myCar的变量
     2. 同一个对象的所有数据都要放在一对花括号之间
     3．不同的属性或者方法之间用逗号作为分隔符
     4. 属性名和属性值之间用冒号作为分隔符
    */
    var myCar //声明变量
    = 
    {//标示对象定义开始的边界    　　
        name    /*属性名*/    　
         :  　   /*冒号分隔符*/
         "Fiat" /*属性值*/
         ,      /*逗号作为属性之间的分隔符*/
        model :"500",
        weight: 850,
        wUnit:"kg",
        color:"white",
        owner:"John",
         /*在对象内部定义方法*/
         /*方法定义开始*/
        start : /*方法名*/
        function(){/*方法对应的函数*/
          console.log(this.owner+ " is starting his car");
        }     
        ,/*方法之间的分隔符*/   
        drive : function(){
          console.log(this.owner+ " is driving his car");        
        },
        brake : function(){
          console.log(this.owner+ " braked his car");         
        },
        stop  : function(){
          console.log(this.owner+ " has stopped his car");            
        }
         /*方法定义结束*/
    　　}//标示对象定义结束的边界
    　　;//语句结束

&emsp;&emsp;然后可以用下面的语法访问对象属性、调用对象方法：

    consolw.log(typeof myCar);//object
    //对象名＋“.”+属性名
    var carName = myCar.name;
    console.log(carName);
    
    //对象名＋“.”+方法名＋“()”
    myCar.start();

&emsp;&emsp;除了在对象内部定义属性和方法，我们还可以从外部给对象增加属性和方法:

    myCar.stillUsable = false;
    myCar.breakdown = function(){
      console.log(this.owner + "'s car is broken down.....");
    };
    
    console.log(myCar.stillUsable);//false
    myCar.breakdown();//John's car is broken down.....



### 把函数当模板批量创建对象

&emsp;&emsp;JavaScript是一种语法非常灵活的面向对象语言。除了用一对花括号（“{}”）定义对象以外，你还可以先定义一个函数（function）,作为模板,用JavaScript关键字**new**调用函数、创建对象。

&emsp;&emsp;用这种方法定义属性和方法需要在函数内部用到关键字“**this**”。

    function Car(name,model,weight,wUnit,color,owner){
      this.name = name;
      this.model = model;
      this.weight = weight;
      this.wUnit =wUnit;
      this.color =color;
      this.owner =owner;

      //在函数内部声明对象的方法
      this.start = function(){/*方法对应的函数*/
          console.log(this.owner+ " is starting his car");
        };
    
      this.drive = function(){
          console.log(this.owner+ " is driving his car");        
        };
    
      this.brake = function(){
         console.log(this.owner+ " braked his car");  
        };
    
      this.stop = function(){
        console.log(this.owner+ " has stopped his car");  
        };
    }
      
      //创建对象的方法：用关键字"new"调用函数、传入对象属性
      var car2 =new Car("Fiat","500",850,"kg","white","John");
      console.log(car2.name);//Fiat
      console.log(car2.owner);//John
      car2.drive();//John is driving his car
      //用关键字"new"调用函数，把函数当做“模板”
      //可以方便地批量创建相同“类型”的对象
      //这种方法创建的一类对象具有完全相同的一组属性名和方法名
      var car3 = new Car("Ford","500",850,"kg","black","Jack");
      console.log(car3.name);//Ford
      console.log(car3.owner);//Jack
      car3.drive();//Jack is driving his car



### 用匿名函数创建单个对象

&emsp;&emsp;这里的函数相当于匿名函数，只能在它被创建的时候被调用一次。不同于用模板反复调用函数创建对象的方法，虽然这个apple也是从“函数”创建，但是它的模板只能被调用用一次，因此这样生成的对象独一无二，没有“同类”。

    var apple = new function() {
        this.type = "macintosh";
        this.color = "red";
        this.getInfo = function () {
            return this.color + ' ' + this.type + ' apple';
        };
    }

     apple.color = "reddish";//从外部修改color属性
     console.log(apple.getInfo());//reddish macintosh apple


### 遍历查询对象属性

&emsp;&emsp;对于任意一个JavaScript对象，我们都可以通过“**for...in**”循环遍历出它内部的属性和方法。

    var apple = new function() {
        this.type = "macintosh";
        this.color = "red";
        this.getInfo = function () {
            return this.color + ' ' + this.type + ' apple';
        };
    }

     for(var key in apple){
       console.log('属性名'+key+':属性值'+apple[key]);
     }

      /*
      for循环将会输出以下内容：
      属性名:type,属性值:macintosh
      属性名:color,属性值:red
      属性名:getInfo,属性值:function () {
            return this.color + ' ' + this.type + ' apple';
        }
      */

## 4.2 用JS常用对象提高编程效率

### Object

### Date日期对象

### String等基本数据类型对象

### Math对象

### 其他对象 

## 4.3 用数组存储多个对象

### 简单数组

### 多维数组

### 数组也是一个对象

# 5.用对象描述“类”的关系

## 5.1 变量作用域和闭包

## 5.2 原型继承

## 5.3 构造函数继承

## 5.4 混合集成

# 实验一：用JS对象描述汽车

## 目的

### 用对象字面量定义对象

### 用函数模板定义对象

### 用Object.create创建对象

## 准备工作

### 什么是对象

&emsp;&emsp;本来“对象”这个词没有任何特殊含义，就像我们中国人经常用到的“东西”这个词，我们可以说“张三不是个东西”，甚至还可以说“张三是个XX东西”。这两种说法都没有错误。因为“东西”这个“概念”，从逻辑学的角度来说，叫做内涵无限小、外延无限大，说白了“东西就是框，什么都能装”。

&emsp;&emsp;“对象”这个词，在现代汉语词典里面的含义是：“行动或思考时作为目标的人或事物”，比如说张三的女朋友就可以说是他的“对象”，因为张三肯定把它的女朋友当成思考和行动的目标。

 ![thinking_einstein](/public/img/js/thinking_einstein.jpg){:width="200px" height="100px"}

&emsp;&emsp;好了，言归正传，我们回到编程语言的世界。

&emsp;&emsp;在特定情景下，我们人类经常会遇到“一堆”相互之间关系密切的**基本类型数据**，我们还必须考虑跟这些数据有关的**计算过程**。为了更简单、直接的描述我们要思考的这个“东西”，或者说是“事物”，我们采用了一种方法：把它们按照某个秩序，“组合”在一起，记录成一种特别的**复合数据类型**，就是“对象”。在编程语言的世界里，有一个流行说法是，“一切都是对象”。

### 装配一个汽车对象

&emsp;&emsp;让我们从一辆汽车开始，描述一个JavaScript对象：

 ![objectExplained](/public/img/js/objectExplained.png){:width="700px" height="600px"}

&emsp;&emsp;凡是汽车都有汽车的样子，我们把汽车**静态**特征用JavaScript语言的基本类型数据描述出来，就是对象的**属性**，然后把所有汽车能完成的**动作**和**功能**用函数模拟出来，就是对象的“方法”。

&emsp;&emsp;如果你认同莱布尼茨的话，“世界上没有两片完全相同的叶子”，那么你一定认可“世界上没有两辆完全相同的汽车”。在上路几年之后，每一辆汽车的内部属性（属性，property）会发生不一样的变化，比如主轴磨损；同一品牌的不同汽车，也会被车主以不同方法操作使用，引起行驶能力的巨大差异：类似，在JavaScript语言中，不同的对象也可以保存不同的**内部状态**，甚至不同的**外部行为**。

### 用模板批量建造汽车

## 步骤

### 定义一个空对象

&emsp;&emsp;首先我们要从简单到复杂构建一个对象。最简单的对象是一个空对象。一个空对象只需要用一对花括号来表示：

    var myCar = {};//这是一个最简单的空对象
 
&emsp;&emsp;用“**typeof**”运算符检查这个变量，结果表明它已经是一个“**对象**”了。
   
    console.log(typeof myCar);//object
    console.log(myCar instanceof Object);//true


&emsp;&emsp;在控制台上查看对象的内部结构:

    console.dir(myCar)

&emsp;&emsp;可以看到一个JavaScript空对象的基本定义。


### 对象属性

&emsp;&emsp;要用JavaScript对象描述真实生活中的汽车，就需要如实的描述出汽车的关键特征，或者说是属性。

&emsp;&emsp;我们用一个字符串来记录汽车的名字，具体做法如下：

    var myCar = {
     /*属性名*/ /*冒号分隔符*/ /*属性值*/
      name           :          "Fiat"
     };
    
    console.log(myCar.name);//Fiat
    console.log(typeof myCar.name);//string
    console.log(myCar instanceof Object);//true

&emsp;&emsp;在控制台查看汽车对象的内部结构，就能看到汽车的名字属性：

    console.dir(myCar)


### 更多属性

&emsp;&emsp;真实的汽车，除了名称以外，还会有型号、重量、颜色等等其他属性。

&emsp;&emsp;因此，我们把这些特征属性记录到汽车对象里：

    var myCar = 
     {   　　
     /*属性名*/ /*冒号*/ /*属性值*/   /*属性定义分隔符*/
      name        :       "Fiat"      ,
      model       :       "500"       ,
      weight      :        850        ,
      wUnit       :        "kg"       ,
      color       :        "white"
    　　};

&emsp;&emsp;在控制台查看对象内部细节：

    console.dir(myCar)

### 让汽车动起来

&emsp;&emsp;现实生活中的一台汽车最重要的能力就是，它能根据人的意愿跑起来。

&emsp;&emsp;我们给汽车对象增加一个函数，用函数的计算过程模拟汽车的动态行为。

&emsp;&emsp;比如说，汽车启动的动态过程：

    var myCar = 
     {   　　
     /*属性名*/ /*冒号*/ /*属性值*/   /*属性定义分隔符*/
      name        :       "Fiat"       ,
      model       :       "500"        ,
      weight      :       850          , 
      wUnit       :       "kg"         ,
      color       :       "white"      ,
      start       :        function(){
       //控制台语句表明这台车正在启动
       console.log("汽车正在启动......");
       }
    　　};

    //console.log(myCar);

&emsp;&emsp;在控制台打印这个属性，用“**typeof**”运算符来检查它的类型：

       console.log(myCar.start);
       console.log(typeof(myCar.start)) //function

&emsp;&emsp;最后，我们只要调用这个函数，就可以模拟汽车的启动过程：

       myCar.start();//

### this关键字

&emsp;&emsp;现在这个“汽车”对象已经能通过向控制台输出语句来模拟启动动作了，现实生活中汽车的动态行为往往会“检查”甚至“修改”它的其他普通属性，比如说邮箱里还剩余多少汽油，这就是一个已经计算出来、并且保存好的一个数字属性。

&emsp;&emsp;我们只要做一件简单的事情：要把汽车的名字一起输出到控制台。

&emsp;&emsp;修改myCar对象的start方法。原来代码是：

       //控制台语句表明这台车正在启动
       console.log("汽车正在启动......");

&emsp;&emsp;修改以后的代码是:

       //控制台语句表明这台车正在启动
       console.log("名字是"+myCar.name+"的汽车正在启动......");

&emsp;&emsp;调用汽车的start方法：

       myCar.start();//

&emsp;&emsp;除了用“**myCar.name**”访问对象的属性，我们还可以用“**this**”关键字，因为在对象内部，“**this**”就是对象的代名词：

    console.log("在对象内部，'this'这个词指代对象本身:"+(myCar===this));
    console.log("名字是"+myCar.name+"的汽车正在启动......");


### 模拟汽车的更多行为

&emsp;&emsp;类似的，我们可以在对象上模拟汽车的其他动作。

&emsp;&emsp;把下面的几个方法加入“myCar”对象里面：

     drive : function(){
       console.log(this.name+ "正在行驶中......");
     },
     brake : function(){
       console.log(this.name+ "紧急刹车!");
     },
     stop  : function(){
       console.log(this.name+ "已经停稳了......");
     }


### 完整代码

&emsp;&emsp;下面是模拟了真实汽车的JavaScript代码:

    var myCar = 
     {   　　
     /*属性名*/ /*冒号*/ /*属性值*/   /*属性定义分隔符*/
      name        :       "Fiat"       ,
      model       :       "500"        ,
      weight      :       850          , 
      wUnit       :       "kg"         ,
      color       :       "white"      ,
     /*方法名*/ /*冒号*/ /*函数定义*/   　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　/*方法定义分隔符*/
      start       :  　　　function(){
      　　console.log("在对象内部，'this'这个词指代对象本身:"+(myCar===this));
      　　console.log("名字是"+myCar.name+"的汽车正在启动......");
       　}  　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　,
      drive : function(){
      　console.log("在对象内部，'this'这个词指代对象本身:"+(myCar===this));
       console.log(this.name+ "正在行驶中......");
       }  　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　,
      brake : function(){
      　console.log("在对象内部，'this'这个词指代对象本身:"+(myCar===this));
       console.log(this.name+ "紧急刹车!");
       }  　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　,
      stop  : function(){
      　console.log("在对象内部，'this'这个词指代对象本身:"+(myCar===this));
       console.log(this.name+ "已经停稳了......");
      }
    　　};

      myCar.start();
      myCar.drive();
      myCar.brake();
      myCar.stop();

&emsp;&emsp;在控制台执行代码以后，我们会看到以下内容：

 ![myCar_console_output](/public/img/js/myCar_console_output.png){:width="500px" height="400px"}

### 动手练一练

&emsp;&emsp;上面我们用JavaScript语言模拟制造一台真实的汽车的过程。

&emsp;&emsp;按照上面的方法，制造一辆汽车大体上需要两步，

1. 模仿：先找到已有的汽车，沿用它们的属性和行为。

2. 创新：根据需要，修改原有的属性和方法，或者给汽车增加新的属性和方法。

&emsp;&emsp;请同学们亲自动手，用这样的方法制造１０台汽车。

 ![car_objects](/public/img/js/car_objects.png){:width="500px" height="400px"}   更多汽车正在拷贝修改当中......

### 用function批量制造对象

&emsp;&emsp;够了，想必你早已经厌倦了这种没完没了的手工复制！

&emsp;&emsp;既然所有的汽车都有“相似”的属性，而且能表现出“一样”功能，那为什么不让JavaScript引擎来为你完成重复性的工作？

&emsp;&emsp;只需要定义一个函数（function），也能达到快速、批量地建造同一类对象的目的。

 ![constructor_pic](/public/img/js/constructor_pic.png){:width="300px" height="200px"}

    function Car(name,model,weight,wUnit,color,owner){
      this.name = name;
      this.model = model;
      this.weight = weight;
      this.wUnit =wUnit;
      this.color =color;

      this.start　=　function(){
      　　console.log("名字是"+this.name+"的汽车正在启动......");
       },
      this.drive = function(){
       console.log(this.name+ "正在行驶中......");
      } ,
      this.brake = function(){
       console.log(this.name+ "紧急刹车!");
      } ,
      this.stop  = function(){
       console.log(this.name+ "已经停稳了......");
      }
    }

&emsp;&emsp;创建新对象的语法是：

      var car2 =new Car("Fiat","500",850,"kg","white");

&emsp;&emsp;在控制台查看对象内容：

      console.dir(car2);

&emsp;&emsp;调用汽车的不同方法：

      car2.start();
      car2.drive();
      car2.brake();
      car2.stop();

&emsp;&emsp;在这里，函数Car的执行过程就是给新对象添加属性和方法的过程，在控制台查看新对象的constructor（构造子）属性，我们会发现，函数“Car”就是新对象的构造子：

      console.log(car2.constructor);
      console.log(car2 instanceof Car);

### 构造函数做了什么

&emsp;&emsp;简单地讲，这个对象创建过程大致分为以下四步:

    /* 第一步：创建一个空对象 */
    var temp ={};
    /* 第二步：空对象作为作用域，调用构造函数“Car”*/
    Car.apply(temp,["Fiat","500",850,"kg","white"]/*从构造子参数列表传入的对象属性...*/);
    /* 第三步：指定新对象的构造子（constructor）是函数"Car"*/
    temp.prototype.constructor = Car;
    /* 第四步：把新对象赋值给“car2”*/
    var car2 = temp;

&emsp;&emsp;“建造者”函数“Car”内部用到的关键字“**this**”，实质上就是这个新创建的对象。

&emsp;&emsp;有了“**Car**”这个自动运行的“建造者”，你只需要准备好“原材料”，就可以不费吹灰之力地创建更多新对象了！

    
      var car3 = new Car("Ford","500",850,"kg","black");
      console.log(car3);
      console.log(car3.constructor);
      console.log(car3 instanceof Car);
      car3.start();
      car3.drive();
      car3.brake();
      car3.stop();

&emsp;&emsp;在控制台执行代码以后，我们会看到以下内容：

 ![new_car_console_output](/public/img/js/new_car_console_output.png){:width="500px" height="400px"}

### 试一试

&emsp;&emsp;同学们可以在控制台尝试去掉“new”关键字，还能否创建一个新的汽车对象：

      var car3 = Car("Ford","500",850,"kg","black");

&emsp;&emsp;另外，在这种情况下，关键字（key word）表示什么？

## 知识延伸

### 增加和删除对象属性

&emsp;&emsp;我们可以在第一次对象定义完成之后，给单独一台汽车增加一个属性，比如说：

    car2.owner = 'John';
    console.dir(car2);
    console.dir(car3);

&emsp;&emsp;同时还可以从单独的一台汽车上删除一个属性：

    delete (car2.model)
    console.dir(car2);
    console.dir(car3);

### 使用构造函数的prototype属性

&emsp;&emsp;基于已经存在的代码，我们来做一个测试：

    //每一辆车上都有“功能”一样的方法 
    //这些“功能”一样的方法存在重复定义
    console.log('car2.start === car3.start:' + (car2.start === car3.start));
    console.log('car2.drive === car3.drive:' + (car2.drive === car3.drive));
    console.log('car2.brake === car3.brake:' + (car2.brake === car3.brake));
    console.log('car2.stop === car3.stop:' + (car2.stop === car3.stop));

&emsp;&emsp;有没有办法，给“同一类型”的所有对象只定义一套方法呢？

&emsp;&emsp;第一步，constructor函数里不定义start、drive、brake、stop方法

      function Car(name,model,weight,wUnit,color,owner){
       this.name = name;
       this.model = model;
       this.weight = weight;
       this.wUnit =wUnit;
       this.color =color;
      }

&emsp;&emsp;第二步，找到并且查看构造函数的“**prototype**”属性：
      
      console.dir(Car.prototype);
      consloe.log(typeof Car.prototype);

&emsp;&emsp;第三步，在这个“**prototype**”属性上面相关方法：

      Car.prototype.start　=　function(){
      　　console.log("名字是"+this.name+"的汽车正在启动......");
      },
      Car.prototype.drive = function(){
       console.log(this.name+ "正在行驶中......");
      } ,
      Car.prototype.brake = function(){
       console.log(this.name+ "紧急刹车!");
      } ,
      Car.prototype.stop  = function(){
       console.log(this.name+ "已经停稳了......");
      }

&emsp;&emsp;同样的方法，用构造函数创建汽车对象：

    var car4 =new Car("BYD","500",850,"kg","white");
    var car5 =new Car("桑塔纳2000","500",850,"kg","black");

&emsp;&emsp;检查这些新对象能不能像以前一样工作：

      car4.start();
      car4.drive();
      car4.brake();
      car4.stop();

      car5.start();
      car5.drive();
      car5.brake();
      car5.stop();

 ![constructor_prototype_use_result](/public/img/js/constructor_prototype_use_result.png){:width="500px" height="400px"}

### prototype对象上找到需要的方法

&emsp;&emsp;我们来解释一下究竟发生了什么。

&emsp;&emsp;先看控制台：

    console.dir(car4);
    console.dir(car5);
    //关键点0:新对象的__proto__属性的数据类型也是对象
    console.dir(car4.__proto__);
    console.dir(car5.__proto__);
    //关键点1:新对象的__proto__属性和构造函数Car的prototype是同一个对象
    console.log('car4.__proto__ === Car.prototype:' + (car4.__proto__ === Car.prototype));
    console.log('car5.__proto__ === Car.prototype:' + (car5.__proto__ === Car.prototype));
    //关键点2：因而，两个新对象的__proto__也是同一个对象
    console.log('car4.__proto__ === car5.__proto__:'+ (car4.__proto__ === car5.__proto__));

    console.log('car4.start === car5.start:' + (car4.start === car5.start));
    console.log('car4.drive === car5.drive:' + (car4.drive === car5.drive));
    console.log('car4.brake === car5.brake:' + (car4.brake === car5.brake));
    console.log('car4.stop === car5.stop:' + (car4.stop === car5.stop));

&emsp;&emsp;在调试工具里面查看构造函数（constructor function）的prototype，可以看到：

 ![func_car_prototype](/public/img/js/func_car_prototype.png){:width="500px" height="400px"}

&emsp;&emsp;在调试工具里面监控“car2”变量的详情可以看到：

 ![car2_method_on_prototype](/public/img/js/car2_method_on_prototype.png){:width="500px" height="400px"}

&emsp;&emsp;在调试工具里面监控“car2”变量的详情可以看到：

 ![car3_detail_about_prototype](/public/img/js/car3_detail_about_prototype.png){:width="500px" height="400px"}


&emsp;&emsp;我们发现：

&emsp;&emsp;第一，当我们调用car4或者car5对象上的方法时，JS引擎能自动到对象内部的“**\__proto\__**”属性上找到相同名字的方法；

&emsp;&emsp;第二，被调用的方法里面的关键字“**this**”始终跟发起方法调用的新对象（在这里分别是car4和car5）是同一回事。


# 实验二：兔子也是一种动物

## 目的

### 通过对象的"__proto__"属性实现继承

### 通过构造函数的“prototype”属性实现继承

## 准备工作

### JS语言面向对象编程

&emsp;&emsp;父类和子类的概念

### 继承

&emsp;&emsp;子类复用了父类的特征和能力

### 多态

&emsp;&emsp;相对于父类子类的特征和能力有所增加和变化

## 步骤

### 兔子是一种动物

&emsp;&emsp;刚开始的时候，我们不加思考地把“兔子”和“动物”分成两种事物对待。

&emsp;&emsp;突然有一天我们意识到，在漫长的生物进化历史里面，兔子**继承**了很多属于“动物”的特征（属性）和功能（方法）。“动物”代表一个范围更大的一个类型，“兔子”代表一个范围更小的类型，“兔子”也是一种“动物”。

&emsp;&emsp;下面我们通过一个简单的例子，让描述兔子的对象直接把描述“动物”的对象里面的特征（属性）和功能（方法）“继承”过来......

 ![inherit_by_proto](/public/img/js/inherit_by_proto.png){:width="200px" height="300px"} 

&emsp;&emsp;代码如下：

    var animal = { eats: true }
    var rabbit = { jumps: true }

    rabbit.__proto__ = animal
    console.log('动物都能进食，兔子能不能进食？' + rabbit.eats);
    console.dir(rabbit) 

&emsp;&emsp;我们可以在控制台看到：

 ![rabbit_can_eat](/public/img/js/rabbit_can_eat.png){:width="500px" height="400px"}

&emsp;&emsp;当JS引擎在rabbit对象上找不到“eats”属性的时候，它会自动到同一个对象的“\__proto\__”属性上面查找：

![attr_search_on_proto](/public/img/js/attr_search_on_proto.png){:width="200px" height="300px"}

### 兔子吃午餐了

&emsp;&emsp;现在这里正好有两只兔子等着吃午餐：

    //名为full的属性为false,表示它正在饿肚子
    var rabbitA = { full : false  };
    rabbitA.__proto__ = rabbit;
    var rabbitB = { full : false  };
    rabbitB.__proto__ = rabbit;

&emsp;&emsp;第一步，看看它们是不是冒牌货的兔子：

    console.log('动物都能进食。兔子A，要不要吃东西？'+ rabbitA.eats);
    console.log('兔子都很会蹦跶。兔子A,给咱蹦跶几下？'+ rabbitA.jumps);
    console.dir(rabbitA);
    console.log('动物都能进食。兔子B，要不要吃东西？'+ rabbitB.eats);
    console.log('兔子都很会蹦跶。兔子B,给咱蹦跶几下？'+ rabbitB.jumps);
    console.dir(rabbitB);

&emsp;&emsp;第二步，为了做对比实验，我们给兔子A喂食，不给兔子B喂食：

    //修改rabbitA名称是“full”的属性
    rabbitA.full =true;
    //都吃饱了，既不能再吃，也不能蹦跶起来了
    rabbitA.eats = false;
    rabbitA.jumps = false;
    /* 很遗憾，rabbitB什么也没吃 ...... */

&emsp;&emsp;第三步，查看实验结果：

    console.log('rabbitA肚子变圆鼓了没？' + rabbitA.full);
    console.log('rabbitA还能不能再吃？' + rabbitA.eats);
    console.log('rabbitA还能不能再蹦跶？' + rabbitA.jumps);
    //给rabbitA全身检查
    console.dir(rabbitA);

&emsp;&emsp;然后来看看兔子先生B：

    console.log('rabbitB肚子变圆鼓了没？' + rabbitB.full);
    console.log('rabbitB还能不能再吃？' + rabbitB.eats);
    console.log('rabbitB还能不能再蹦跶？'  + rabbitB.jumps);
    //给rabbitB全身检查
    console.dir(rabbitB);



## 延伸

### JS变量作用域

### 私有属性

# 实验二：扩展标准Date对象

## 目的

###　学习用prototype给Date类型对象扩展属性和方法

## 准备工作

### 熟悉Date类型API

### 了解prototype作用原理

## 步骤

### 复制日期对象

&emsp;&emsp;当两个变量指向同一个对象的时候，通过其中一个变量修改对象，则另外一个变量的值也会受到影响：

    var date1 = new Date(2008, 1, 10);
    var date2 = date1;
    console.log("date1:{"+date1 + "},date2:{" + date2+"}");
    date2.setDate(20);
    console.log("date1:{"+date1 + "},date2:{" + date2+"}");

&emsp;&emsp;我们来定义一个复制日期对象的方法：

    Date.prototype.copy = function () {
      return new Date(this.getTime());
    };

&emsp;&emsp;然后用它来生成一个新的日期对象：

    var oldDate = new Date(2008, 1, 10);
    var newDate = oldDate.copy();
    console.log("oldDate:{"+oldDate + "},newDate:{" + newDate+"}");
    newDate.setDate(20);
    console.log("oldDate:{"+oldDate + "},newDate:{" + newDate+"}");

&emsp;&emsp;**copy**方法返回了一个跟原对象内容一样的新对象，修改newDate不会影响原来的对象：

 ![date_copy_effect](/public/img/js/date_copy_effect.png){:width="600px" height="500px"}


### 获取月日信息

&emsp;&emsp;下面我们来定义几个方法，用他们来查询一个给定日期对象的月份名称，还有它是本周星期几的方法。

&emsp;&emsp;第一步：定义两个基本数组：

    Date.prototype.DAYNAMES = 
       ["Sunday", "Monday", "Tuesday", "Wednesday", 
       "Thursday","Friday", "Saturday"];
    Date.prototype.MONTHNAMES = 
       ["January", "February", "March", "April", "May", "June", 
       "July", "August", "September", "October", "November","December"];

&emsp;&emsp;第二步，在Date.prototype上定义相关方法：

    Date.prototype.getWeekDayName = function() {
      return this.DAYNAMES[this.getDay()];
    };
    
    Date.prototype.getFullMonthName = function() {
      return this.MONTHNAMES[this.getMonth()];
    };

&emsp;&emsp;测试：

    var example_date = new Date(2008, 1, 20);
    console.log("WeekDayName: " + example_date.getWeekDayName() +
      ",\tMonth Name: " + example_date.getFullMonthName());

    var current_date = new Date();
    console.log("WeekDayName: " + current_date.getWeekDayName() +
      ",\tMonth Name: " + current_date.getFullMonthName());

&emsp;&emsp;控制台输出：

 ![date_get_weekday_month_name_test](/public/img/js/date_get_weekday_month_name_test.png){:width="600px" height="500px"}


### 日期时间显示格式

&emsp;&emsp;极端一天里的具体时间，有12小时分段计时法和24小时计时法。

&emsp;&emsp;接下来我们分别定义两个方法来完成这两个功能。

&emsp;&emsp;12小时分段计时法：

    Date.prototype.to12HourTimeString = function () {
    var h = thi  s.getHours();
      var m = "0" + this.getMinutes();
      var s = "0" + this.getSeconds();
    
      var ap = "am";
    
      if (h >= 12) {
       ap = "pm";
    
       if (h >= 13)
       h -= 12;
    
      } else if (h == 0)
       h = 12;
      }
    
      h = "0" + h;
      return h.slice(-2) + ":" +
       m.slice(-2) + ":" +
       s.slice(-2) + " " + ap;
    };

&emsp;&emsp;24小时计时法：

    Date.prototype.to24HourTimeString = function () {
      var h = "0" + this.getHours();
      var m = "0" + this.getMinutes();
      var s = "0" + this.getSeconds();
      return h.slice(-2) + ":" + m.slice(-2) + ":" + s.slice(-2);
    };

&emsp;&emsp;测试：

    var dte = new Date(2008, 1, 20, 19, 30, 5);
    console.log(dte.to12HourTimeString() + "||" + dte.to24HourTimeString());
    var currentDate = new Date();
    console.log(currentDate.to12HourTimeString() + "||" + currentDate.to24HourTimeString());

### 查询当月天数

&emsp;&emsp;我们来进行一个有趣的测试。

&emsp;&emsp;向上溢出：

    var d = new Date(2016, 9, 31);
    console.log('2016年10月31日:'+d);

    var d = new Date(2016, 9, 32);
    console.log('2016年10月32日:'+d);

    var d = new Date(2016, 9, 33);
    console.log('2016年10月33日:'+d);

    var d = new Date(2016, 9, 34);
    console.log('2016年10月34日:'+d);

&emsp;&emsp;向上一个月溢出：

    var d = new Date(2016, 9, 1);
    console.log('2016年10月1日:'+d);

    var d = new Date(2016, 9, 0);
    console.log('2016年10月0日:'+d);

    var d = new Date(2016, 9, -1);
    console.log('2016年10月-1日:'+d);

&emsp;&emsp;闰年是很特殊的情况：

    var d = new Date(2008, 2, 0);
    console.log('2008年3月0日:'+d);

    var d = new Date(2012, 2, 0);
    console.log('2012年3月0日:'+d);

    var d = new Date(2016, 2, 0);
    console.log('2016年3月0日:'+d);

&emsp;&emsp;获取当月最后一天的数字(这个月有多少天)，不需要考虑什么闰年、大小月，只需要获取到下一个月第０天的日期对象，它就代表了当月的最后一天：

    Date.prototype.lastday = function() {
      var d = new Date(this.getFullYear(), this.getMonth() + 1, 0);
      return d.getDate();
    };

&emsp;&emsp;测试：

    var d = new Date(2008, 1, 5);
    console.log('2008年2月5日,当月天数：'+d.lastday());

    var d = new Date(2016, 1, 10);
    console.log('2016年2月10日,当月天数：'+d.lastday());

    var d = new Date(2016, 5, 5);
    console.log('2016年6月5日,当月天数：'+d.lastday());

    var d = new Date(2016, 9, 5);
    console.log('2016年10月5日,当月天数：'+d.lastday());


&emsp;&emsp;控制台输出：

 ![date_getlastday_test](/public/img/js/date_getlastday_test.png){:width="600px" height="500px"}

### 计算两个日期的间隔天数

&emsp;&emsp;实际应用开发的过程中，我们经常会遇到要根据两个日期计算它们之间的天数的需求。

&emsp;&emsp;第一步，在对象的prototype上定义一个常量，它表示一天所包含的毫秒数：

    Date.prototype.msPERDAY = 1000 * 60 * 60 * 24;

&emsp;&emsp;第二步，定义具体方法：

    Date.prototype.getDaysBetween = function(d) {
      d = d.copy();//复制一个新对象
    
      d.setHours(this.getHours(), this.getMinutes(), this.getSeconds(),
      this.getMilliseconds());//对齐时间
    
      var diff = d.getTime() - this.getTime();//获取两个日期时间之间相差的毫秒数
      return (diff)/this.msPERDAY;//this.msPERDAY可以访问到第一步定义的常量
    };

&emsp;&emsp;测试：
    
    function displayInfo(days){
     if (days > 0)
       console.log("The given day is " + days + " after today.");
     else if(days < 0)
       console.log("The given day is " + Math.abs(days) + " before today.");
     else
       console.log("Just today !!");
    }

    var today = new Date();
    var d1 = new Date(1921, 6,1);
    var d2 = new Date(1949, 9, 1);
    var d3 = new Date(2049,6,1);
 
    var days1 = today.getDaysBetween(d1);
    displayInfo(days1);
    var days2 = today.getDaysBetween(d2);
    displayInfo(days2);
    var days3 = today.getDaysBetween(d3);
    displayInfo(days3);



### 给定日期一年里过去的天数

&emsp;&emsp;结合已有的知识，我们还可以扩展一个方法，用于计算给定日期一年里已经过去的天数：

    Date.prototype.getDayOfYear = function() {
    //找到当年第一天的日期对象:
      var start = new Date(this.getFullYear(), 0, 1);
    //要把当年第一天也加进去
      var count = this.getDaysBetween(start) ;
      var dayOfYear =Math.abs(count) + 1;
      return dayOfYear;
    };

&emsp;&emsp;测试：

    var today = new Date();
    var dayOfYear = today.getDayOfYear();
    console.log('今天是本年度的第' + dayOfYear + "天！");

## 知识延伸












