---
layout: post
title: ES6(ES2015)-lesson6
category: es6
tags: es6 es2015
author: 郑未
keywords: lanqiao 蓝桥 培训 教程 前端 es6 es2015
p_cate: 前端那些事儿
description: 本章主要介绍es6生成器（generator）的用法
---
>内容提要

- 生成器

# 生成器

示例代码：[lesson6-1.js](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson6-1.js)

## 实验

生成器通过使用`function*`和`yield`简化迭代器的编写， 形如`function*`的函数声明返回一个生成器实例.
生成器是迭代器的子类型。

上代码：

    function* fibonacci() {
      var pre = 0, cur = 1;
      for (;;) {
        var temp = pre;
        pre = cur;
        cur += temp;
        yield cur;  //每次调用迭代器的返回，类似return
      }
    }
    var fibIter = fibonacci();
    for (let i = 0;i < 5;i++) {
      console.log(fibIter.next());
    }
    /*~
    { value: 1, done: false }
    { value: 2, done: false }
    { value: 3, done: false }
    { value: 5, done: false }
    { value: 8, done: false }
    ~*/


## 解读

`fibonacci`看起来很像一个函数，我们称之为生成器函数，它与普通函数有很多共同点，但是二者有如下区别：

- 普通函数使用`function`声明，而生成器函数使用`function*`声明。
- 在生成器函数内部，有一种类似`return`的语法：关键字`yield`。二者的区别是，普通函数只可以`return`一次，而生成器函数可以`yield`多次（当然也可以只`yield`一次）。在生成器的执行过程中，遇到`yield`表达式立即暂停，后续可恢复执行状态。

这就是普通函数和生成器函数之间最大的区别，普通函数不能自暂停，生成器函数可以。

## 生成器做了什么？

当你调用一个生成器时，它并非立即执行，而是返回一个已暂停的生成器对象（上述实例代码中的`fibIter`）。
你可将这个生成器对象视为一次函数调用，只不过立即冻结了，它恰好在生成器函数的最顶端的第一行代码之前冻结了。

每当你调用生成器对象的`.next()`方法时，函数调用将其自身解冻并一直运行到下一个`yield`表达式，再次暂停。

`next`的返回结果是有`value`和`done`属性的对象，`value`是值，`done`为是否结束的标志。

# 生成器是迭代器！

我们希望用上述代码完成一个斐波那契迭代器，我们需要定义一个对象，拥有一个会被自动调用来产生迭代器实例的函数，名为`[Symbol.iterator]`，`[Symbol.iterator]`函数需要返回一个迭代器实例（任何含有`next`方法的实例都可以称为迭代器实例），因为生成器就是迭代器，所以这里我们返回生成器即可，代码框架如下：

    var fibonacci = {
      [Symbol.iterator]: function*() {  //生成器就是迭代器
        
      }
    }
    //迭代器可以用for-of遍历
    for (var n of fibonacci) {
      if (n > 10)
        break;
      console.log(n);
    }

接下来将`fibonacci`函数内容填入生成器中即可，完整代码如下[lesson6-2.js](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson6-2.js)：

    var fibonacci = {
        [Symbol.iterator] : function*() {
          var pre = 0, cur = 1;
          for (;;) {
            var temp = pre;
            pre = cur;
            cur += temp;
            yield cur;  //每次调用迭代器的返回，类似return
          }
        }
    }
    for (let v of fibonacci) {
        if(v > 100)
            break;
      console.log(v);
    }

for-of会自动调用迭代器的next方法，不用for-of需要手工调用迭代器的next方法。