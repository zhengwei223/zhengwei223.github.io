---
layout: post
title: ES6(ES2015)-lesson3
category: es6
tags: es6 es2015
author: 郑未
keywords: lanqiao 蓝桥 培训 教程 前端 es6 es2015
p_cate: 前端那些事儿
description: 这一章主要讲解Destructuring——解构赋值
---
>内容提要

- 解构 Destructuring

# 什么是解构赋值？

解构赋值允许按模式匹配来为变量赋值，通常用于数组和对象字面值。

# 数组解构赋值

## 例一：数组解构赋值

```
'use strict'
//数组的解构赋值
var [a,b,c] = [1,2,3];
console.log(a,b,c);  //输出 1 2 3
```
第三行提取数组中的元素分别赋给变量`a b c`，看起来像是分解了数组并赋值给变量，因此称之为结构赋值。

## 例二：对任意深度的嵌套数组进行解构

```
var [foo, [[bar], baz]] = [1, [[2], 3]];
console.log(foo);
// 1
console.log(bar);
// 2
console.log(baz);
// 3
```

## 例三：留空跳过被解构数组中的某些元素

    var [,,third] = ["foo", "bar", "baz"];
    console.log(third);
    // "baz"

## 例四：通过“不定参数”模式捕获数组中的所有尾随元素

    var [head, ...tail] = [1, 2, 3, 4];
    console.log(tail);
    // [2, 3, 4]


# 对象的解构赋值

## 例一：对象字面值解构赋值

```
var { foo:foo1, bar:bar1 } = { foo: "lorem", bar: "ipsum" };
console.log(foo1);
// "lorem"
console.log(bar1);
// "ipsum"
```

如果变量名和对象的属性名一致，上例可以简写为：

```
var { foo, bar } = { foo: "lorem", bar: "ipsum" };
console.log(foo);
// "lorem"
console.log(bar);
// "ipsum"
```

## 例二：任意深度对象解构

```
//任意深度
var complicatedObj = {
  arrayProp: [
    "Zapp",
    { second: "Brannigan" }
  ]
};
var { arrayProp: [first, { second }] } = complicatedObj;
console.log(first);
// "Zapp"
console.log(second);
// "Brannigan"
```

## 例三：用于参数

```
function g({p1:name,p2:age}){
    console.log(name,age)
}
g({p1:'zhangsan',p2:20});  // zhangsan 20
```

指定默认值：

```
function r({name,age=20}){
    console.log(name,age)
}
r({name:'zhangsan'});  // zhangsan 20
```

# 解构值不是对象、数组或迭代器

当你尝试解构null或undefined时，你会得到一个类型错误：

    var {blowUp} = null;
    // TypeError: null has no properties（null没有属性）

然而，你可以解构其它原始类型，例如：布尔值、数值、字符串，但是你将得到undefined：

    var {wtf} = NaN;
    console.log(wtf);
    // undefined

你可能对此感到意外，但经过进一步审查你就会发现，原因其实非常简单。当使用对象赋值模式时，被解构的值需要被强制转换为对象。大多数类型都可以被转换为对象，但null和undefined却无法进行转换。当使用数组赋值模式时，被解构的值一定要包含一个迭代器。

# 多重返回值

JavaScript语言中尚未整合多重返回值的特性，但是无须多此一举，因为你自己就可以返回一个数组并将结果解构：

    function returnMultipleValues() {
      return [1, 2];
    }
    var [foo, bar] = returnMultipleValues();

或者，你可以用一个对象作为容器并为返回值命名，可自行尝试。

# 使用解构导入部分CommonJS模块

你是否尚未使用ES6模块？还用着CommonJS的模块呢吧！没问题，当我们导入CommonJS模块X时，很可能在模块X中导出了许多你根本没打算用的函数。通过解构，你可以显式定义模块的一部分来拆分使用，同时还不会污染你的命名空间：

    const { SourceMapConsumer, SourceNode } = require("source-map");

（如果你使用ES6模块，你一定知道在import声明中有一个相似的语法。）