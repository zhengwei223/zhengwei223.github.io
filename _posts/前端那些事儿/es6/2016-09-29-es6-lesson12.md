---
layout: post
title: ES6(ES2015)-lesson12
category: es6
tags: es6 es2015
author: 郑未
keywords: lanqiao 蓝桥 培训 教程 前端 es6 es2015
p_cate: 前端那些事儿
description: 本章主要介绍①反射(Reflect)API②尾调用(Tail Calls)
---

>内容提要

- Reflect是内建对象，它提供了系列方法可以拦截JavaScript的操作。这些方法和[proxy handlers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler#Methods)一致。关于代理，[第八章](/es6/es6-lesson8)有所论述。
- （ES6）保证尾部调用时栈不会无限增长，这使得递归算法在面对未作限制的输入时，能够安全地执行。

# 反射API

和别的全局对象不一样，Reflect对象不能用new来构造，它的所有属性和方法都是静态的。

## Reflect.apply() 

用于反射调用函数并传参。

### 语法

    Reflect.apply(target, thisArgument, argumentsList)

- target:目标函数
- thisArgument:目标对象，用于绑定函数上下文中的this
- argumentsList:可迭代的参数列表

### 返回值

和在对象上调用方法的返回值一样。

### 说明

ES5中，我们通常使用`Function.prototype.apply()`来为函数指定上下文中的this并传入参数。

    let a = Math.floor.apply(undefined, [1.75]);
    console.log(a);//1

Reflect API更加简洁。

### 示例

    Reflect.apply(Math.floor, undefined, [1.75]); 
    // 1;

    Reflect.apply(String.fromCharCode, undefined, [104, 101, 108, 108, 111]);
    // "hello"

    Reflect.apply(RegExp.prototype.exec, /ab/, ["confabulation"]).index;
    // 4

    Reflect.apply("".charAt, "ponies", [3]);
    // "i"


## Reflect.has()

### 描述

`Reflect.has`用于检查某属性是否在某对象中.和`in`操作符类似。

### 语法

    Reflect.has(target, propertyKey)

- target:目标对象
- propertyKey:用于检测的属性名

### 返回值

布尔型：属性是否在对象中存在

### 示例

    Reflect.has({x: 0}, "x"); // true
    Reflect.has({x: 0}, "y"); // false

    // returns true for properties in the prototype chain 
    Reflect.has({x: 0}, "toString");

    // Proxy with .has() handler method
    obj = new Proxy({}, {
      has(t, k) { return k.startsWith("door"); }
    });
    Reflect.has(obj, "doorbell"); // true
    Reflect.has(obj, "dormitory"); // false

## 其他方法

请自行阅读[MDN文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect#Methods)

# 尾调用

（ES6）保证尾部调用时栈不会无限增长，这使得递归算法在面对未作限制的输入时，能够安全地执行。

    function factorial(n, acc = 1) {
        'use strict';
        if (n <= 1) return acc;
        return factorial(n - 1, n * acc);
    }

    // 栈溢出存在于现在绝大多数的实现中，
    // 但是在 ES6 中，针对任意的输入都很安全
    factorial(100000)