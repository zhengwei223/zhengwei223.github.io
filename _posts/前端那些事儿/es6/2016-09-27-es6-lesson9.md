---
layout: post
title: ES6(ES2015)-lesson9
category: es6
tags: es6 es2015
author: 郑未
keywords: lanqiao 蓝桥 培训 教程 前端 es6 es2015
p_cate: 前端那些事儿
description: 本章主要介绍es6新增的数据类型——Symbols 符号
---

>内容提要

- Symbols 符号

# 简介

ES6引入Symbol的原因：防止属性名的冲突（ES5的对象属性名都是字符串，容易造成属性名的冲突）。

ES6引入一种新的原始数据类型：Symbol，表示独一无二的值。它是javascript语言的第七种数据类型，前六种是：`Undefined`、`Null`、`Boolean`、`String`、`Number`、`Object`。前五种是原始数据类型，`Object`是引用数据类型。

Symbol值是通过`Symbol`函数生成的。

    let s = Symbol();
    typeof s  //"symbol"

**注：Symbol函数前不能使用new命令，否则会报错。报错的原因就是：生成的Symbol是一个原始类型的值，而不是对象，所以不能添加属性。它是一种类似于字符串的数据类型。**

Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。

    var s1 = Symbol('foo');
    var s2 = Symbol('bar');

    s1 // Symbol(foo)
    s2 // Symbol(bar)

    s1.toString() // "Symbol(foo)"
    s2.toString() // "Symbol(bar)"

**注：Symbol函数的参数只是表示对当前Symbol值的描述，因此相同参数的Symbol函数的返回值是不相等的。**

    // 没有参数的情况
    var s1 = Symbol();
    var s2 = Symbol();

    s1 === s2 // false

    // 有参数的情况
    var s1 = Symbol("foo");
    var s2 = Symbol("foo");

    s1 === s2 // false

Symbol值不能与其他类型的值进行运算。

    var sym = Symbol('My symbol');
    "your symbol is " + sym;
    // Error: Cannot convert a Symbol value to a string

但是Symbol值可以转为字符串。

    var sym = Symbol('My symbol');

    String(sym) // 'Symbol(My symbol)'
    sym.toString() // 'Symbol(My symbol)'

小结：①Symbol是原始数据类型②它代表独一无二的值

# 用法：属性名(属性的标识符)

## 实验

由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。
[lesson9-1.js](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson9-1.js)

例一：

    class MyClass{
        constructor(privateData){
            this[Symbol()] = privateData;
        }
      
    }

    var obj1 = new MyClass('hello');
    console.log(obj1[Symbol()]);//undefined

在这个例子中，我们在构造器中声明了一个属性（*属性名是`Symbol()`产生的值，我们不知道确切的值*）并为其赋值，随后实例化对象并访问其属性。由于属性名是另一个`Symbol()`产生的值且每个Symbol都独一无二，所以新Symbol和旧Symbol不是同一个，所以得到的结果是`undefined`。

为了能再次访问到这个值，我们可以这样做，例二：

    var key = Symbol();
    class MyClass{
        constructor(privateData){
            this[key] = privateData;
        }
      
    }

    var obj1 = new MyClass('hello');
    console.log(obj1[key]);//hello

**注： Symbol值作为对象属性名时，不能用点运算符。作为对象属性名，总是放在方括号里面就好了。**

## 深入：Symbol属性的特点&获取对象的所有属性

Symbol作为属性名，该属性不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`返回。

`Object.getOwnPropertyNames()`:获取所有的属性名，不包括prototy中的属性，返回一个数组。
`Object.keys()`
和`getOwnPropertyNames`方法类似，但是获取**所有的可枚举**的属性，也返回一个数组。

示例如下：

    //---3---
    var key = Symbol();
    class MyClass{
        constructor(privateData){
            this.name = '';
            this.age = 0;
            this[key] = privateData;
        }
      
    }

    var obj1 = new MyClass('hello');
    console.log(Object.keys(obj1));//[ 'name', 'age' ]

可以看到`Object.keys(obj1)`返回的属性名组成的数组中并没有`key`。

可以使用`Object.getOwnPropertySymbols`方法，它返回一个数组，成员是当前对象的所有用作属性名的Symbol值。

`console.log(Object.getOwnPropertySymbols(obj1));//[ Symbol() ]`

有一个新的API`Reflect.ownKeys`方法可以返回所有键名，包括常规的和Symbol：

    console.log(Object.keys(obj1));//[ 'name', 'age' ]
    console.log(Object.getOwnPropertySymbols(obj1));//[ Symbol() ]
    console.log(Reflect.ownKeys(obj1));//[ 'name', 'age', Symbol() ]

## 伪私有属性

由于以Symbol值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的属性或方法。

    var size = Symbol('size');

    class Collection {
      constructor() {
        this[size] = 0;
      }

      add(item) {
        this[this[size]] = item;
        this[size]++;
      }

      static sizeOf(instance) {
        return instance[size];
      }
    }

    var x = new Collection();
    Collection.sizeOf(x) // 0

    x.add('foo');
    Collection.sizeOf(x) // 1

上面代码中，对象x的size属性是一个Symbol值，所以`Object.keys(x)`、`Object.getOwnPropertyNames(x)`都无法获取它。这就造成了一种非私有的内部属性的效果。

# Symbol.for()，Symbol.keyFor()

`Symbol.for`方法：接受一个字符串作为参数，并且创建的Symbol值是全局的，如果我们已经有一个Symbol值了，并且想重新使用，那么就可以利用这个方法来获取。
`Symbol.for`的工作原理就是：搜索有没有以该参数作为名称的Symbol值，如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。

    var s1 = Symbol.for('foo');
    var s2 = Symbol.for('foo');

    s1 === s2   // true

注意：

    Symbol.for("bar") === Symbol.for("bar")
    // true

    Symbol("bar") === Symbol("bar")
    // false

`Symbol.keyFor`方法：返回一个已登记的Symbol值的key。

    var s1 = Symbol.for("foo");
    Symbol.keyFor(s1) // "foo"

    var s2 = Symbol("foo");
    Symbol.keyFor(s2) // undefined

# 内置符号

ES6提供了11个内置的Symbol值，它们都用作对象的属性或方法，指向语言内部使用的属性或方法。

## 1.Symbol.hasInstance

`instanceof`运算符第二个运算子是一个类型，运算时会调用这个类型的`[Symbol.hasInstance]`**静态**方法，判断某对象是否为该类型的实例。
`foo instanceof Foo`在语言内部，实际调用的是`Foo[Symbol.hasInstance](foo)`。

——你可以利用它自定义针对某个类型的`instanceof`行为：

    'use strict'
    class MyArray {  
       static [Symbol.hasInstance](instance){
        console.log(`-----${instance}`);
        return Array.isArray(instance);
      }
    }
    console.log([1,2,3] instanceof MyArray); // true

或许babel并未支持，写本文时，实际运行结果为`false`。

## 2.Symbol.isConcatSpreadable

内置的`Symbol.isConcatSpreadable`符号用于配置某对象作为`Array.prototype.concat()`方法的参数时是否展开其数组元素。

### 描述

`isConcatSpreadable` 符号 (`Symbol.isConcatSpreadable`) 可以直接定义为对象属性或继承而来，它是布尔类型。它可以控制数组或类似数组（array-like）的对象的行为：

- 对于数组对象，默认情况下，用于concat时，会按数组元素展开然后进行连接（数组元素作为新数组的元素）。重置Symbol.isConcatSpreadable可以改变默认行为。
- 对于类似数组的对象，用于concat时，该对象整体作为新数组的元素，重置Symbol.isConcatSpreadable可改变默认行为。

### 示例

#### 数组

默认情况下，`Array.prototype.concat()` 展开其元素连接到结果中：

    var alpha = ['a', 'b', 'c'], 
        numeric = [1, 2, 3]; 

    var alphaNumeric = alpha.concat(numeric); 

    console.log(alphaNumeric); // 结果: ['a', 'b', 'c', 1, 2, 3]

设置Symbol.isConcatSpreadable为false：

    var alpha = ['a', 'b', 'c'], 
        numeric = [1, 2, 3]; 

    numeric[Symbol.isConcatSpreadable] = false;
    var alphaNumeric = alpha.concat(numeric); 

    console.log(alphaNumeric); // 结果: ['a', 'b', 'c', [1, 2, 3] ]

#### Array-like 对象

对于类数组 (array-like)对象，默认不展开。期望展开其元素用于连接，需要设置 `[Symbol.isConcatSpreadable]` 为`true`：

    var x = [1, 2, 3];

    var fakeArray = { 
      [Symbol.isConcatSpreadable]: true, 
      length: 2, 
      0: "hello", 
      1: "world" 
    }

    x.concat(fakeArray); // [1, 2, 3, "hello", "world"]

## 3.Symbol.iterator

`Symbol.iterator`为每一个对象定义了默认的迭代器。该迭代器可以被 `for...of` 循环结构使用。

### 描述

每当一个对象被迭代的时候（例如，在 for...of 循环的开始），他的 @@iterator 方法就会被调用一次（传入0个参数），同时返回的迭代器将被用来获取被迭代出来的值。

一些内建类型拥有默认的迭代器行为，其他类型（如 Object ）则没有。下表中的内建类型拥有默认的@@iterator方法：

- Array.prototype@@iterator
- TypedArray.prototype@@iterator
- String.prototype@@iterator
- Map.prototype@@iterator
- Set.prototype@@iterator

### 示例

用户自定义迭代器

我们可以像下面这样创建自定义的迭代器：

    var myIterable = {}
    myIterable[Symbol.iterator] = function* () {
        yield 1;
        yield 2;
        yield 3;
    };
    console.log([...myIterable]) // [1, 2, 3]

[迭代器](/es6/es-lesson5)及[生成器](/es6/es-lesson6)在之前章节讲过，可以再去看看.

## 4-11.更多内容

可以在[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)找到全部的内置符号及其说明。