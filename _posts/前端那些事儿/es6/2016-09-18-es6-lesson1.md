---
layout: post
title: ES6(ES2015)-lesson1
category: es6
tags: es6 es2015
author: 郑未
keywords: lanqiao 蓝桥 培训 教程 前端 es6 es2015
p_cate: 前端那些事儿
description: 这一章讲解①箭头函数和②class关键字的用法
---
>内容提要

- 箭头函数:箭头函数使用“=>”语法，本质是一个匿名函数又和function语法不同
- 类的用法:ES6中的类（class），比之前的基于prototype的模式要简单很多。Classes支持继承、super调用、实例方法、静态方法和构造器。

#  0.Introduction

ECMAScript 2015 is an ECMAScript standard that was ratified in June 2015.
ES2015 is a significant update to the language, and the first major update to the language since ES5 was standardized in 2009. Implementation of these features in major JavaScript engines is underway now.

See the [ES2015 standard](http://www.ecma-international.org/ecma-262/6.0/index.html) for full specification of the ECMAScript 2015 language.

# 1.箭头函数与this

本例完整代码：[lesson1-1.js](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson1-1.js)

箭头函数使用“=>”语法，本质是一个匿名函数又和function语法不同，箭头前是函数参数，箭头后面的表达式或者语句（块）是函数体。和函数不同，箭头函数和其外部函数共享同一个this。

例1：
理解本例你可能需要了解[Array.prototype.map()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map)，该方法返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。

```
var arr = [0,2,4,6,8,10];

var odds = arr.map(v => v+1);
console.log(odds); //[ 1, 3, 5, 7, 9, 11 ]

//等同于这样的写法
odds = arr.map(function(v){
	return v+1;
});
console.log(odds); //[ 1, 3, 5, 7, 9, 11 ]

var nums = arr.map((v,i) => v + i);
console.log(nums);  //[ 0, 3, 6, 9, 12, 15 ]

//等同于这样的写法
nums = arr.map(function(v,i){
	return v+i;
});
console.log(nums);  //[ 0, 3, 6, 9, 12, 15 ]

var fives = [];
nums.forEach(v => {
	if(v % 5 == 0){
		fives.push(v);
	}
});
console.log(fives);  //[ 0, 15 ]

//-------this-------
var bob = {
  _name: "Bob",
  _friends: [],
  printFriends() {
    this._friends.forEach(f =>
      console.log(this._name + " knows " + f));
  }
};
bob._friends = ['zhangsan','lisi','wangwu'];
bob.printFriends();
//输出  
//Bob knows zhangsan
//Bob knows lisi
//Bob knows wangwu

//如果我们这样写
bob = {
  _name: "Bob",
  _friends: [],
  printFriends() {
    this._friends.forEach(function(f){
      console.log(this._name + " knows " + f);
	});  
  }
};
bob._friends = ['zhangsan','lisi','wangwu'];
bob.printFriends();
//输出
//undefined knows zhangsan
//undefined knows lisi
//undefined knows wangwu
//因为匿名函数内的this是函数本身
```

通过示例，可以看到剪头函数与其外围环境共用一个this。

# 2.Classes #

本例代码：[lesson1-2.js](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson1-2.js)

## 基本用法

ES6中的类（class），比之前的基于prototype的模式要简单很多。Classes支持继承、super调用、实例方法、静态方法和构造器。

```
'use strict'

class Animal{
	constructor(name,color){
		this.name = name;
		this.color = color;
	}
	
	toString(){
		return '名字：' + this.name + ',颜色：' + this.color;
	}
}

class Pig extends Animal{
	constructor(name,color){
		super(name,color);
	}
	//重写
	toString(){
		return Pig.typeName() + '，' + super.toString();
	}
	static typeName(){
		return '猪';
	}
}

var info = new Pig('小白','白色').toString();
console.log(info); // 猪，名字：小白,颜色：白色
```

示例中，我们用到了`class`关键字来定义一个类型，`extends`关键字表示继承，`constructor`声明构造器，`super`函数调用父类构造器，`super`指向父对象调用父类函数，`static`声明静态函数用类直接调用，`new`关键字实例化一个对象。

## getters & setters

可以通过 `get` 和 `set` 关键字来定义 getters 和 setters :

    class People {
        constructor(name) { //构造函数
              this._name = name;
        }
        get name() {
            return this._name.toUpperCase();
        }
        set name(name) {
            this._name = name;
        }
        sayName() {
            console.log(this.name);
        }
    }
    var p = new People("tom");
    console.log(p.name);    //调用getName，返回TOM
    console.log(p._name);    //直接访问属性
    p.sayName();    //调用getName，返回TOM

**注：区分 `this._name`（无读写器，直接访问属性） 和 `this.name`（有读写器，用读写器）。**

要注意一点，不要这样写：

    set name(name) {
        this.name = name;
    }

因为给 `this.name` 赋值的时候会调用 `set name` ，这样会导致无限递归直到栈溢出。

