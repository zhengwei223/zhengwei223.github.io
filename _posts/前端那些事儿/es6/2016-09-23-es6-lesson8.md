---
layout: post
title: ES6(ES2015)-lesson8
category: es6
tags: es6 es2015
author: 郑未
keywords: lanqiao 蓝桥 培训 教程 前端 es6 es2015
p_cate: 前端那些事儿
description: 本章主要介绍①es6的新数据结构Map+Set+WeakMap+WeakSet②代理
---
>内容提要

- Map + Set + WeakMap + WeakSet，带键的集合
- Proxies 代理，用于拦截目标对象的调用，做一些前置或后置的处理，类似Java等语言都有这方面的支持

# 新增的数据结构

请看[lesson8-1](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson8-1.js)的代码和注释：

    // Sets基本用法
    var s = new Set();
    s.add("hello").add("goodbye").add("hello");
    console.log(`s.size === ${s.size}`);
    console.log(`s.has("hello") === ${s.has("hello")}`);

    // Maps基本用法
    var m = new Map();
    m.set("hello", 42);
    m.set(s, 34);
    console.log(`m.get(s) == ${m.get(s)}`);

    // Weak Maps
    var wm = new WeakMap();
    wm.set(s, { extra: 42 });
    console.log(`wm.get(s) == ${wm.get(s).extra}`);
    console.log(`wm.size === ${wm.size}`);//undefined

    // Weak Sets
    var ws = new WeakSet();
    ws.add({ data: 42 });
    // 由于所加入的对象没有其他引用，故在此集合内不会保留之。

    console.log(`ws.size === ${ws.size}`);  //undefined

## WeakMap

WeakMap对象是键/值对的集合，且其中的键是弱引用的。其键只能是对象，而值则可以是任意的。
WeakMap中,每个键对自己所引用对象的引用是 "弱引用", 这意味着,如果没有其他引用和该键引用同一个对象,这个对象将会被当作垃圾回收.

正由于这样的弱引用，WeakMap 的 key 是非枚举的 (没有方法能给出所有的 key)。如果key 是可枚举的话，其列表将会受垃圾回收机制的影响，从而得到不确定的结果. 因此,如果你想要这种类型对象的 key 值的列表，你应该使用 Map。

### 语法：

    new WeakMap([iterable])

### 参数

`iterable`：Iterable 是一个数组（2元数组）或者可遍历的且其元素是键值对的对象。每个键值对会被加到新的 WeakMap 里。

### 描述

WeakMap 的 key 只能是对象类型。 原始数据类型 是不能作为 key 的（比如 Symbol）。

## WeakSet

一个 WeakSet 对象是一个无序的集合, 可以用它来存储任意的对象值, 并且对这些对象值保持弱引用.

### 语法

     new WeakSet([iterable]);

### 参数

`iterable`:
如果传入一个可迭代对象作为参数, 则该对象的所有迭代值都会被自动添加进生成的 WeakSet 对象中.

### 描述

WeakSet 对象是一些对象值的集合, 并且其中的每个对象值都只能出现一次.

它和 Set 对象的区别有两点:

- WeakSet 对象中只能存放对象值, 不能存放原始值, 而 Set 对象都可以.
- WeakSet 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素.

# Proxies 代理

## 基本使用

ES6规范定义了一个全新的全局构造函数：代理（`Proxy`）。它可以接受两个参数：目标对象（`target`）与句柄对象（`handler`）。请看一个简单的示例：

    var target  = {}, 
        handler = {};
    var p       = new Proxy(target, handler);

代理的行为很简单：将代理对象的所有内部方法转发至目标对象。简单来说，如果调用`proxy.[[Enumerate]]()`，就会返回`target.[[Enumerate]]()`。

接下来我们来检测下上面的定义：

    p.color = 'pink';
    console.log(`target's color===${target.color}`);//pink

我们并没有在直接target上设置属性，而是通过代理在target上设置了属性。完整代码请看[lesson8-2.js](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson8-2.js)

## 句柄对象（handler）

句柄对象可以覆写代理对象的内部方法——有14种内部方法，可以覆写。
`get`是其中一种，表示获取对象属性值，接下来我们就试试拦截目标对象获取属性的行为[lesson8-3.js](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson8-3.js)：

    var target = {
        name:'name of target'
    };

    var handler = {
        // 拦截目标上获取属性的行为，三个参数分别是目标对象，属性名，
        // 最后一个参数receiver可选，当target对象设置了key属性的get函数时，receiver对象会绑定get函数的this对象。
      get: function(target,key,receiver) {
        return `${target[key]},plus handler 's name`;
      }
    };

    var p = new Proxy(target, handler);
    console.log(p.name);  //name of target,plus handler 's name

`set`表示为对象的属性赋值，通过句柄对象，我们可以拦截这个行为[lesson8-4.js](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson8-4.js)：

    var target = {};
    var handler = {
        set: function(target,key,value,receiver) {
            console.log(`准备为${key}属性赋值：${value}`);
            target[key] = value;    //注意
            return true;
        }
    };

    var p = new Proxy(target,handler);
    p.color = 'pink';
    console.log(target.color);

    /*~ 输出日志
    准备为color属性赋值：pink
    ~*/

句柄方法的完整列表可以在[MDN有关代理的页面](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy#Methods_of_the_handler_object)上找到，一共有14种方法，与ES6中定义的14中内部方法一致。所有句柄方法都是可选的，没被句柄拦截的内部方法会直接指向目标对象。