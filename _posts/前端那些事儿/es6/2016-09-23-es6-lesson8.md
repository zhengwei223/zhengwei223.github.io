---
layout: post
title: ES6(ES2015)-lesson8
category: es6
tags: es6 es2015
author: 郑未
keywords: lanqiao 蓝桥 培训 教程 前端 es6 es2015
p_cate: 前端那些事儿
description: 本章主要介绍①es6的新数据结构Map+Set+WeakMap+WeakSet②代理
---
>内容提要

- Map + Set + WeakMap + WeakSet新数据结构，其他语言都有，es6就顺便加上了
- Proxies 代理，用于拦截目标对象的调用，做一些前置或后置的处理，类似Java等语言都有这方面的支持

# 新增的数据结构

用于实现常见算法的高效数据结构，WeakMaps提供不会泄露的对象键(对象作为键名，而且键名指向对象)索引表 
*注：所谓的不会泄露，指的是对应的对象可能会被自动回收，回收后WeakMaps自动移除对应的键值对，有助于防止内存泄露。*

请看[lesson8-1](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson8-1.js)的代码和注释：

    // Sets基本用法
    var s = new Set();
    s.add("hello").add("goodbye").add("hello");
    console.log(`s.size === ${s.size}`);
    console.log(`s.has("hello") === ${s.has("hello")}`);

    // Maps基本用法
    var m = new Map();
    m.set("hello", 42);
    m.set(s, 34);
    console.log(`m.get(s) == ${m.get(s)}`);

    // Weak Maps
    var wm = new WeakMap();
    wm.set(s, { extra: 42 });
    console.log(`wm.get(s) == ${wm.get(s).extra}`);
    console.log(`wm.size === ${wm.size}`);//undefined

    // Weak Sets
    var ws = new WeakSet();
    ws.add({ data: 42 });
    // 由于所加入的对象没有其他引用，故在此集合内不会保留之。

    console.log(`ws.size === ${ws.size}`);  //undefined

# Proxies 代理

## 基本使用

ES6规范定义了一个全新的全局构造函数：代理（`Proxy`）。它可以接受两个参数：目标对象（`target`）与句柄对象（`handler`）。请看一个简单的示例：

    var target = {}, handler = {};
    var proxy = new Proxy(target, handler);

代理的行为很简单：将代理对象的所有内部方法转发至目标对象。简单来说，如果调用`proxy.[[Enumerate]]()`，就会返回`target.[[Enumerate]]()`。

接下来我们来检测下上面的定义：

    p.color = 'pink';
    console.log(`target's color===${target.color}`);//pink

我们并没有在直接target上设置属性，而是通过代理在target上设置了属性。完整代码请看[lesson8-2.js](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson8-2.js)

## 句柄对象（handler）

句柄对象的可以覆写代理对象的内部方法——有14种内部方法，可以覆写。
`get`是其中一种，表示获取对象属性值，接下来我们就试试拦截目标对象获取属性的行为[lesson8-3.js](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson8-3.js)：

    var target = {
        name:'name of target'
    };

    var handler = {
        // 拦截目标上获取属性的行为，三个参数分别是目标对象，属性名，
        //最后一个参数receiver可选，当target对象设置了key属性的get函数时，receiver对象会绑定get函数的this对象。
      get: function (target,key,receiver) {
        return `${target[key]},plus handler 's name`;
      }
    };

    var p = new Proxy(target, handler);
    console.log(p.name);  //name of target,plus handler 's name

`set`表示为对象的属性赋值，通过句柄对象，我们可以拦截这个行为[lesson8-4.js](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson8-4.js)：

    var target = {};
    var handler = {
        set: function(target,key,value,receiver){
            console.log(`准备为${key}属性赋值：${value}`);
            target[key] = value;    //注意
            return true;
        }
    };

    var p = new Proxy(target,handler);
    p.color = 'pink';
    console.log(target.color);

    /*~ 输出日志
    准备为color属性赋值：pink
    ~*/

句柄方法的完整列表可以在[MDN有关代理的页面](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy#Methods_of_the_handler_object)上找到，一共有14种方法，与ES6中定义的14中内部方法一致。所有句柄方法都是可选的，没被句柄拦截的内部方法会直接指向目标。