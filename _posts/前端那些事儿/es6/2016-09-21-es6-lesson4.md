---
layout: post
title: ES6(ES2015)-lesson4
category: es6
tags: es6 es2015
author: 郑未
keywords: lanqiao 蓝桥 培训 教程 前端 es6 es2015
p_cate: 前端那些事儿
description: 这一章主要讲解es6在函数参数上的改进，重点介绍新的变量声明关键字：let和const
---
>内容提要

- 函数参数可以设定默认值、接受不定个数参数、还可以用数组批量传参
- es6引入新的变量声明关键字`let`和`const`，改变了js没有块级作用域变量的尴尬现状

# 默认值+不定参+数组展开（Default + Rest + Spread）

代码：[lesson4-1.js](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson4-1.js)

看代码和注释比较直观：

    'use strict'

    function f(x, y = 12) {
      // 如果没有传第二个参数，y的值为12
      return x + y;
    }
    console.log(`f(3) == ${f(3)}`);

    function f1(x, ...y) {
      // y 是一个数组，第二个及以后的实参全部作为y的元素
      return x * y.length;
    }
    console.log(`f1(3, "hello", true) ===  ${f1(3, "hello", true)}`);


    function f2(x, y, z) {
      return x + y + z;
    }
    // 将数组的元素依次作为函数参数，这就是spread
    console.log(`f2(...[1,2,3]) ==  ${f2(...[1,2,3]) }`);

此例中我们顺便回顾了模板字符串的用法。

# Let + Const 关键字

代码：[lesson4-2.js](https://coding.net/u/lanqiao/p/frontAdvance/git/blob/master/es6/lesson4-2.js)

## es5的问题

我们知道js里面一直没有**块级作用域变量**的定义语法，请看这样一条规则：**在JS函数中的var声明，其作用域是函数体的全部**，如果不用`var`则更糟糕——这样的变量是全局变量。
这意味着：①在代码块内声明的变量，其作用域是整个函数作用域而不是块级作用域。②循环内变量会过度共享。
我们来看看这样一份代码：

    var messages = ["喵！", "我是一只会说话的猫！", "回调（callback）非常有趣!"];
    for (var i = 0; i < messages.length; i++) {
      setTimeout(
        ()=>{
        console.log(messages[i]);
        }, 
        i * 1000);
    }

我们期望的效果是：

    "喵！"  //立即输出
    "我是一只会说话的猫！"  //1秒后
    "回调（callback）非常有趣!" //2秒后

但输出了三个`undefined`。
这个问题的答案是，循环本身及三次`timeout`回调均共享唯一的变量`i`。当循环结束执行时，`i`的值为3（因为`messages.length`的值为3），此时回调尚未被触发。
所以当第一个`timeout`执行时，调用`cat.say(messages[i])`，此时`i`的值为3，所以猫咪最终打印出来的是`messages[3]`的值亦即`undefined`。

这个问题在es6之前的解决办法如下：

    //es5解决办法
    for (var i = 0; i < messages.length; i++) {
      (function(i){
          setTimeout(
            ()=>{
            console.log(messages[i]);
            }, 
            i * 1000);
        })(i);
    }

我们用`(function(i){函数体})(i);`的句式立即执行一个匿名函数，这个匿名函数具有**闭包特性**，能持有传入的参数`i`。实际上循环三次，将创建三个匿名函数并立即执行，它们的`i`是独自持有的，全局的那个`i`仍然是共享的。

## let是更完美的var

`let`与`var`一样，也可以用来声明变量，但它有着更好的作用域规则。

它看起来是这样的：

    let t = readTachymeter();

或者这样的：

    for (let i = 0; i < messages.length; i++) {
      ...
    }

`let`定义的变量是块级作用域，在循环中使用`let`，每次迭代都为变量创建新的绑定，因此上一节的问题在es6环境中可以这样轻松解决：

    //es6解决办法
    for (let i = 0; i < messages.length; i++) {
      setTimeout(
        ()=>{
        console.log(messages[i]);
        }, 
        i * 1000);
    }

## const

`const`声明的变量与`let`声明的变量类似，它们的不同之处在于，`const`声明的变量只可以在声明时赋值，不可随意修改，否则会导致`SyntaxError`（语法错误）。

    const MAX_CAT_SIZE_KG = 3000; // 正确

    MAX_CAT_SIZE_KG = 5000; // 语法错误（SyntaxError）
    MAX_CAT_SIZE_KG++; // 虽然换了一种方式，但仍然会导致语法错误

当然，规范设计的足够明智，用const声明变量后必须要赋值，否则也抛出语法错误。

    const theFairest;  // 依然是语法错误，你这个倒霉蛋