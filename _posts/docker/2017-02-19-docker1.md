---
layout: post
title: docker概念、安装与基本使用
category: docker虚拟化技术
tags: docker 虚拟机 运维 容器化技术
keywords: 蓝桥 lanqiao 教程 docker 虚拟机 运维 容器化技术
description: Docker 是一个便携的应用容器.本章主要介绍docker的基本概念，安装过程及基本命令。
author: 郑未
---

> Docker 是一个便携的应用容器

>Docker是Linux下应用容器引擎，提供一种比LXC高级的API。Docker使用Go语言开发，利用了Linux提供的LXC，AUFS，namespace和cgroup技术。实现了文件系统，资源和网络的隔离，最终目标实现类似PaaS平台的应用隔离。LXC——Linux容器工具，容器有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。与虚拟化相比，这样既不需要指令级模拟，也不需要即时编译。容器可以在核心 CPU 本地运行指令，而不需要任何专门的解释机制。此外，也避免了准虚拟化（paravirtualization）和系统调用替换中的复杂性。容器在提供隔离的同时，还通过共享这些资源节省开销，这意味着容器比真正的虚拟化的开销要小得多。


# 和虚拟机有什么不同

可以自己去读读[这篇文章](https://zhuanlan.zhihu.com/p/22382728)

## 虚拟机

虚拟机是一种模拟系统，即在软件层面上通过模拟硬件的输入和输出，让虚拟机的操作系统得以运行在宿主机的操作系统上.

![](https://pic3.zhimg.com/307fc27ab1dbab631edd25496423f0fe_b.png)

这种机制意味着虚拟机上程序的运行效率比宿主机系统上的程序运行效率要低很多。因为宿主机系统的程序可以直接和物理硬件打交道，而虚拟机上的程序是先和虚拟硬件打交道，然后虚拟硬件再和宿主操作系统交互……其次虚拟出来的硬件和物理硬件在架构上的差别，是的输入输出还不止是简单的搬运，这中间还涉及到转化，效率进一步被降低。

一般来说，虚拟机都会有自己的kernel，自己的硬件，这样虚拟机启动的时候需要先做开机自检，启动kernel，启动用户进程等一系列行为，虽然现在电脑运行速度挺快，但是这一系列检查做下来，也要几十秒，也就是虚拟机需要几十秒来启动。

路径越长，效率越低！

## 操作系统虚拟化（非硬件虚拟化）

假如宿主机和虚拟机他们的kernel是一致的，就不用做硬件输入输出的搬运工了，只需要做kernel输入输出的搬运工即可，为了有别于硬件层面的虚拟机，这种虚拟机被命名为 操作系统层虚拟化：Operating-system-level virtualization 也被叫做**容器**

在虚拟机的系统中，虚拟机认为自己有独立的文件系统，进程系统，内存系统，等等一系列，所以为了让容器接近虚拟机，也需要有独立的文件系统，进程系统，内存系统，等等一系列，为了达成这一目的，主机系统采用的办法是：**只要隔离容器不让它看到主机的文件系统，进程系统，内存系统，等等一系列，那么容器系统就是一个接近虚拟机的玩意了**


## 结论

docker容器没有自己的kernel，它不是虚拟硬件上的操作系统，它只是宿主机上的一个守护进程创建的若干子进程——容器和宿主机共享kernel，docker容器的kernel version由宿主机决定而不是镜像

但是，但是……docker镜像明明看起来像各种系统版本，其实docker只是一个kernel搬运工（是一个隔离者，也是一个搬运工），例如你在mac上运行一个Ubuntu的docker容器，在容器中的任何指令都被转化为mac kernel指令，而任何文件操作直接转化为mac上的文件操作。

*如果容器的预设kernel和宿主机kernel不兼容，也还是要使用虚拟化技术，如在window和mac上*

**本质上讲，docker容器的启动就是在宿主机上启动了一个被隔离的进程**

# 用docker能干啥——容器即服务

学习linux，快速搭建各种环境，而不用消耗过多资源（因为一个容器只是一个进程）

让测试变得更加容易：开发团队把应用部署在容器里面，然后制作一个镜像，这个镜像给测试团队就行了，无需反复搭建测试环境

节约开发的时间，通过容器可以快速搭建一个部署环境，甚至直接把镜像传到部署主机上，在部署主机上运行容器，直接由容器向外提供服务。因为容器直接使用宿主机资源，所以这个方案是可行的。

案例：

>我们（AVOS Cloud）是做 BaaS，场景非常适合使用 Docker，抛出来大家一起聊下。 在我们的平台上，一台 16 核 32G 内存的虚拟机上，需要跑 500+ 个用户的应用（每个应用的功能可以认为是一个网站 + 一系列的 RESTful API），有两个事情很重要： 资源隔离：比如限制应用最大内存使用量，或者资源加载隔离等。 低消耗：虚拟化本身带来的损耗需要尽量的低。 我们不可能在一台机器上开 500 个虚拟机，虽然可以在资源隔离方面做的很好，但这种虚拟化本身带来的资源消耗太严重。 另一个方面，我们可以考虑使用语言级别沙箱，虽然这种「虚拟化」本身的消耗可以低到忽略不计，但是资源隔离方面绝对是噩梦，比如你打算在一个 JVM 里隔离内存的使用。 而 Docker 很好的权衡了两者，即拥有不错的资源隔离能力，又有很低的虚拟化开销。

>作者：无知
>链接：https://www.zhihu.com/question/22969309/answer/30865048
>来源：知乎
>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


启停一个容器非常快速，意味着可以快速部署，重新部署若干个应用只是重启一个进程而不是重启一个系统。


## 提高开发效率


# Docker 内部

要理解 Docker 内部构建，需要理解以下三种部件：

- Docker 镜像 = Docker images
- Docker 仓库 = Docker registeries
- Docker 容器 = Docker containers

## Docker 镜像

Docker 镜像是 Docker 容器的只读模板，每一个镜像由一系列的层 (layers) 组成。Docker 使用 UnionFS 来将这些层联合到单独的镜像中。UnionFS 允许独立文件系统中的文件和文件夹(称之为分支)被透明覆盖，形成一个单独连贯的文件系统。正因为有了这些层的存在，Docker 是如此的轻量。当你改变了一个 Docker 镜像，比如升级到某个程序到新的版本，一个新的层会被创建。因此，不用替换整个原先的镜像或者重新建立(在使用虚拟机的时候你可能会这么做)，只是一个新的层被添加或升级了。现在你不用重新发布整个镜像，只需要升级，层使得分发 Docker 镜像变得简单和快速。

## Docker 仓库

Docker 仓库用来保存镜像。同样的，Docker 仓库也有公有和私有的概念。公有的 Docker 仓库名字是 Docker Hub。Docker Hub 提供了庞大的镜像集合供使用。这些镜像可以是自己创建，或者在别人的镜像基础上创建。Docker 仓库是 Docker 的分发部分。

## Docker 容器

一个Docker容器包含了所有的某个应用运行所需要的环境。每一个 Docker 容器都是从 Docker 镜像创建的。Docker 容器可以运行、开始、停止、移动和删除。每一个 Docker 容器都是独立和安全的应用平台，Docker 容器是 Docker 的运行部分。

<p class="text-error">
仓库保存镜像，有公有和私有，镜像是静态的，运行起来就是容器，容器保存下来就是镜像。
</p>

# docker安装

所谓docker安装指的是安装docker引擎。

各平台的docker安装都很简单，请参考[官方文档](https://docs.docker.com/engine/installation/)进行安装。

获取当前 docker 版本

	docker version
    Client:
	 Version:      1.13.1
	 API version:  1.26
	 Go version:   go1.7.5
	 Git commit:   092cba3
	 Built:        Wed Feb  8 08:47:51 2017
	 OS/Arch:      darwin/amd64

	Server:
	 Version:      1.13.1
	 API version:  1.26 (minimum version 1.12)
	 Go version:   go1.7.5
	 Git commit:   092cba3
	 Built:        Wed Feb  8 08:47:51 2017
	 OS/Arch:      linux/amd64
	 Experimental: true

# docker基础用法

## 官方示例

	docker run hello-world

这句话的意思是启动名为hello-world的镜像，将其运行在容器中。

可是我们本地还没有任何镜像，这时docker会自动到docker hub上去搜索并下载，然后运行，日志如下：

	Unable to find image 'hello-world:latest' locally
	latest: Pulling from library/hello-world
	535020c3e8ad: Pull complete
	af340544ed62: Pull complete
	Digest: sha256:a68868bfe696c00866942e8f5ca39e3e31b79c1e50feaee4ce5e28df2f051d5c
	Status: Downloaded newer image for hello-world:latest

	Hello from Docker.
	This message shows that your installation appears to be working correctly.

	To generate this message, Docker took the following steps:
	1. The Docker Engine CLI client contacted the Docker Engine daemon.
	2. The Docker Engine daemon pulled the "hello-world" image from the Docker Hub.
	3. The Docker Engine daemon created a new container from that image which runs the
	executable that produces the output you are currently reading.
	4. The Docker Engine daemon streamed that output to the Docker Engine CLI client, which sent it
	to your terminal.

	To try something more ambitious, you can run an Ubuntu container with:
	$ docker run -it ubuntu bash

	Share images, automate workflows, and more with a free Docker Hub account:
	https://hub.docker.com

	For more examples and ideas, visit:
	https://docs.docker.com/userguide/

简单翻译下，是这样的：

	本地找不到'hello-world:latest'
	从远程仓库下载
	……
	下面是运行容器后，容器中默认的应用程序输出的信息，这些信息自己说明了信息产生的过程：
	1.docker引擎的客户端工具联系docker引擎的守护进程
	2.守护进程下载镜像
	3.守护进程从下载的镜像创建容器并运行了其中的可执行程序用来产生你读到的这些信息
	4.守护进程把文字传输给客户端程序，也就是你敲命令的这个终端

	更多挑战，你可以直接运行一个Ubuntu容器：
	$ docker run -it ubuntu bash
	这会下载镜像--启动容器--进入Ubuntu的bash shell界面

	分享镜像要到https://hub.docker.com去创建账号
	更多信息，请访问https://docs.docker.com/userguide/

下面我们分步骤来试试：

## 访问docker hub并下载指定镜像

	docker search ubuntu  # 搜索镜像
	docker pull registry.cn-hangzhou.aliyuncs.com/ubuntu-14-04/ubuntu14.04  # 从国内镜像下载
	# docker pull ubuntu # 从docker hub下载，比较慢
	docker images # 查看本机镜像列表

REPOSITORY   												TAG
registry.cn-hangzhou.aliyuncs.com/ubuntu-14-04/ubuntu14.04   latest

IMAGE ID            CREATED             SIZE
ef3ecf68e1e2        6 weeks ago         261 MB

<p class="text-error">
	以后我们可以用镜像id来做各种操作，也可以用REPOSITORY:TAG为标识来做操作，但这里的REPOSITORY很长，我们可以通过这条命令来修改下：
	<pre><code>docker tag ef3ecf68e1e2 zhengwei/ubuntu:14.04</code></pre>
</p>

继续列出镜像，就会发现同一个镜像有多种标签了：

zhengwei/ubuntu  14.04               ef3ecf68e1e2        6 weeks ago         261 MB

注：阿里云Docker镜像库，阿里云容器Hub服务：http://dev.aliyun.com/search.html，系列步骤注册后再返回这个地址，从镜像搜索进入输入关键字得到列表并拷贝pull的地址，然后用docker pull进行下载，速度比从docker hub下载要快很多。

## 启动容器并进入交互模式

	docker run -it --name master zhengwei/ubuntu:14.04 /bin/bash
	#启动ubuntu，将容器命名为master，并直接进入交互shell

- docker run - 运行一个容器
- -t - 分配一个（伪）tty (link is external)
- -i - 交互模式 (so we can interact with it)
- ubuntu:14.04 - 使用 ubuntu 基础镜像 14.04
- /bin/bash - 运行命令 bash shell

注: ubuntu 会有多个版本，通过指定 tag 来启动特定的版本 [image]:[tag]

这一步骤相当于启动了一个Ubuntu的操作系统并直接进入了它的shell

	docker ps  # 查看运行的容器状态，宿主上执行

## 其他命令

	docker stop master  		# 停止容器
	docker start Name/ID  		# 启动容器
	docker exec -it name bash 	# 进入容器的shell交互界面
	docker attach Name/ID 		# 附到一个运行中的容器
	docker restart Name/ID   	# 重启一个正在运行的容器
	docker rm -f master 		# 移除容器
	docker rmi ubuntu   		# 移除镜像，慎用，下载很费时的

# 镜像修改（升级）与保存

## docker commit

我们进入到基于某个镜像的容器之后，可能会安装别的东西，或者新增一些文件，我们希望把这种状态保存下来作为一个升级版的镜像，以便以后随时使用这个升级版的镜像，可以这么做：

	#……系列更改如：
	apt-get update && apt-get install -y openssh-server openjdk-7-jdk wget
	exit 	#退出
	#使用 docker commit 命令
	#docker commit -m "注释信息"  <container_id> [REPOSITORY[:TAG]]
	docker commit -m "ubuntu上安装了ssh jdk7 和wget" e6282b775a5b zhengwei/ubuntu-ssh-java7:14.04

container_id怎么获得，使用`docker ps -a`命令来查看，完成后再运行`docker images`应该可以看到一个600多兆的新镜像

REPOSITORY                                                   TAG                 IMAGE ID            CREATED             SIZE

zhengwei/ubuntu-ssh-java7                                    14.04               1ae25d4ed73a        5 seconds ago       616 MB

## 利用 Dockerfile 来创建镜像

使用 docker commit 来扩展一个镜像比较简单，但是不方便在一个团队中分享。我们可以使用 `docker build `命令来创建一个新的镜像。为此，首先需要创建一个 Dockerfile，包含一些如何创建镜像的指令。

新建一个目录和一个Dockerfile，Dockerfile 中每一条指令都创建镜像的一层，例如：

	# 制作一个ssh免登陆+jdk7+wget的基于Ubuntu1404的镜像
	FROM zhengwei/ubuntu:14.04

	MAINTAINER zhengwei <zhengwei@lanqiao.org>

	# 升级apt-get并且安装openssh-server jdk7和wget三款软件
	RUN apt-get update && \
	    apt-get install -y openssh-server openjdk-7-jdk wget

	# set environment variable
	ENV JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64

	# ssh without key
	RUN ssh-keygen -t rsa -f ~/.ssh/id_rsa -P '' && \
	    cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys  # 产生的公钥加入到许可证文件中
	CMD ["sh","-c","service ssh start; bash"]

Dockerfile 基本的语法是

- 使用#来注释
- FROM 指令告诉 Docker 使用哪个镜像作为基础
- 接着是维护者的信息
- RUN开头的指令会在创建中运行，比如安装一个软件包，在这里使用 apt-get 来安装了一些软件

编写完成 Dockerfile 后可以使用`docker build -t=name:tag Dockerfile文件路径`来生成镜像：

	docker build -t=zhengwei/ubuntu-ssh-java7:10.04 Dockerfile文件路径

可以看到 build 进程在执行操作。它要做的第一件事情就是上传这个 Dockerfile 内容，因为所有的操作都要依据 Dockerfile 来进行。 然后，Dockerfile 中的指令被一条一条的执行。每一步都创建了一个新的容器，在容器中执行指令并提交修改（就跟之前介绍过的 docker commit 一样）。当所有的指令都执行完毕之后，返回了最终的镜像 id。所有的中间步骤所产生的容器都被删除和清理了。

此外，还可以利用`ADD/COPY`命令复制本地文件到镜像中；用`EXPOSE`命令来向外部开放端口；用`CMD`命令来描述容器启动后立即运行的程序如：

	CMD ["sh","-c","service ssh start; bash"]


**注意一个镜像不能超过 127 层**

## 上传镜像

我们按需制作了镜像，为了共享给他人，可以上传到docker hub的镜像库或者国内的镜像库。
docker hub的注册和上传，此处略。
下面简单说下在阿里云上如何上传镜像：

- 到[这里](https://dev.aliyun.com/search.html)注册
- 登录后返回https://dev.aliyun.com/search.html
- 进入管理中心
- 点击“创建镜像仓库”按钮
- namespace输入你的名字或者组织机构的名字
- 仓库名称输入形如ubuntu-ssh-java7这样的东东
- 然后创建
- 创建好之后就能在镜像列表中看到你创建的镜像库，点击管理就会弹出操作文档：

  - 登录
  - 修改本地镜像的标签为指定的格式
  - docker push命令进行上传

# 下载本文示例镜像

本文最终制作了一个基于Ubuntu14.04系统的带有sshserver和免密码密钥对、jdk7和wget的docker镜像，它的下载命令是：`docker pull registry.cn-beijing.aliyuncs.com/zhengwei/ubuntu-ssh-java7`

下载完成后，你可以打新标签（`docker tag <imageid> <registry:tag>`命令）便于操作，可以在此基础上开发和运行java程序，也可以升级这个镜像（安装新的文件）……


# 使用export/import导出和导入docker容器

1、导出容器
如果要导出本地某个容器，可以使用 docker export 命令，导出容器快照到本地文件。

	$ sudo docker ps -a
	CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES
	7691a814370e        ubuntu:14.04        "/bin/bash"         36 hours ago        Exited (0) 21 hours ago                       test
	$ sudo docker export 7691a814370e > ubuntu.tar

2、导入容器快照
可以使用 docker import 从容器快照文件中再导入为镜像，例如

	$ cat ubuntu.tar | sudo docker import - test/ubuntu:v1.0
	$ sudo docker images
	REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE
	test/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB

此外，也可以通过指定 URL 或者某个目录来导入，例如

	$sudo docker import http://example.com/exampleimage.tgz example/imagerepo

*注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。*
[]: https://pic3.zhimg.com/307fc27ab1dbab631edd25496423f0fe_b.png
