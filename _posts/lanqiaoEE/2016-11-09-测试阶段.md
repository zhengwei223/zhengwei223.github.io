---
layout: post

title: 测试阶段

category: lanqiaoEE

tags: 文档说明

description: 测试阶段的说明

author: 董皊

keywords: lanqiao 测试  阶段 

---
# 测试主导阶段

**1. 软件测试的概念**

　　软件测试是通过人工或自动的手段发现软件中隐含的缺陷，目的是要找出预期结果和实际结果之间的差异。

**2. 测试的生命周期**

　　开发模型有很多种，互联网推荐敏捷，推荐使用**Scrum**，他们对软件开发过程有很好的指导作用，但非常遗憾的是，这些模型无法更好地指导测试工作。软件测试是与软件开发紧密相关的一系列有计划的系统性的活动，所以软件测试也需要模型去指导实践，以下也有专家总结了几个测试模型，由于测试和开发的结合非常紧密，在这些测试模型中也都把开发过程进行了很好的总结，体现了测试与开发的融合，下面对主要的模型做一简单的介绍。

**V模型：**

* V模型是最具有代表意义的测试模型

* V模型存在一定的局限性，它仅仅把测试过程作为在需求分析、概要设计、详细设计及编码之后的一个阶段。容易使人理解为测试是软件开发过程的最后的一个阶段，主要是针对程序进行测试寻找错误，而需求分析阶段隐藏的问题可能要到后期的验收测试才会被发现。

**W模型，双v模型**

　　强调：测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、设计等开发输出的文档同样要测试。

　　测试人员可以尽早参与项目，可以预先估计问题和难度，地减少总体测试时间，加快项目进度。

　　W模型和V模型都把软件的开发视为需求、设计、编码等一系列串行的活动。同样的，软件开发和测试保持一种线性的前后关系，需要有严格的指令表示上一阶段完全结束，才可正式开始下一个阶段工作。这样就无法支持迭代、自发性以及变更调整。

**H模型**

　　H模型是配合敏捷开发模式进行的，达到就绪点就进行测试。

　　图中的其他流程可以是任意开发流程，例如，设计流程和编码流程。也可以是其他非开发流程，例如，SQA流程，甚至是测试流程自身。也就是说，只要测试条件成熟了，测试准备活动完成了，测试执行活动就可以进行了。

**测试模型的使用**

* 前面我们介绍了几种典型的测试模型，应该说这些模型对指导测试工作的进行具有重要的意义，但任何模型都不是完美的。我们应该尽可能地应用模型中对项目有实用价值的方面，但不强行地使用模型而使用模型，否则也没有实际意义。

* 因此，在实际的工作中，我们要灵活地运用各种模型的优点，在W模型的框架下，运用H模型的思想进行独立测试，并同时将测试和开发紧密结合，寻找恰当的就绪点开始测试并反复迭代测试，最终保证按期完成预定目标。

**3. 测试的分类**

**动态测试：**指实际运行被测程序，输入相应的测试数据，检查输出结果和预期结果是否相符的过程

**静态测试：**不运行被测软件，而只是静态地检查程序代码、界面或文档可能存在的错误的过程

**单元测试：**指对软件中的最小可测试单元进行检查和验证，如一个模块、一个过程等等。它是软件动态测试的最基本的部分，也是最重要的部分之一，其目的是检验软件基本组成单位的正确性。一个软件单元的正确性是相对于该单元的规约而言的。因此，单元测试以被测试单位的规约为基准。单元测试的主要方法有控制流测试、数据流测试、排错测试、分域测试等等。

**集成测试：**通过测试的单元模块组装成系统或子系统再进行测试，其主要目的是检查软件单位之间的接口是否正确。它根据继承测试计划，一边将模块或其他软件单位组合成越来越大的系统，一边运行该系统，以分析所组成的系统是否正确，各组成部分是否合拍。重点是测试不同模块间的接口部分。它用来检查各个模块结合到一起能否正常运行

**系统测试：**将整个软件系统全部集成好之后作为一个整体进行测试，以验证软件系统的正确性和性能是否满足规约所指定的要求，检查软件的行为和输出是否正确并非一项简单的任务，它被称为测试的“先知者问题”。因此，系统测试应该按照测试计划进行，其输入、输出和其他动态行为应该与软件需求进行对比。包括功能、性能以及软件所运行的软硬件环境进行的测试，还有随机测试。为的是确认此系统满足了特定的功能性和非功能性的需求

**验收测试：**验收测试目的是向客户展示该软件系统满足其用户需求。它的测试数据通常是系统测试的测试数据的子集。所不同的是，验收测试常常有软件系统的购买者代表在现场，甚至是在软件安装使用的现场。这是软件在投入使用之前的最后测试。一般有客户进行确认是否可以接受一个系统的验证性测试，是根据用户需求、业务流程进行的正式测试以确保系统符合所有验收准则，通过了验收，软件就进入发布阶段。

* α测试：有用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的测试，试图发现错误并修正。

* β测试：是一种验收测试，经过α测试调整的软件成为β版本。

**黑盒测试：**把程序看作一个黑盒子，在不考虑程序内部结构的情况下，在程序接口进行测试，它只检查程序功能是否按照需求说明书的规定正常使用，程序是否能接收输入数据而产生正确的输出结果。

**白盒测试：**需要知道盒子里面是怎么运作的，需要检查程序的内部结构，从检查程序的逻辑着手，得出测试数据

**确认测试：**重新执行上次失败的测试用例，以验证是否已经修复

**回归测试：**回归测试是对软件进行修改之后进行的测试，目的是检验对软件进行的修改是否正确。这里，修改的正确性有两重含义：一是所做的修改达到了预定的目的，也就是确认测试，二是还要保证不影响软件的其他功能的正确性。

**冒烟测试：**该术语源自硬件行业。对一个硬件或硬件组件进行更改或修复后，直接给设备加电。如果没有冒烟，则该组件就通过了测试。在软件中，“冒烟测试”是指测试版本的主要功能，如果能通过测试，才继续进行接下来的其它全功能测试。冒烟测试的名称可以理解为该种测试耗时短，仅用一袋烟功夫足够了。

**随机测试：**随机输入测试数据进行测试，其目的是模拟用户的真实操作发现一些边缘性bug，它是测试的一个重要的补充手段，可以保证测试有效覆盖。

**性能测试：**是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。它是为了确定一个软件产品的性能所进行的测试，它是针对特定的应用领域检查系统的性能（比如：处理速度、响应时间、CPU使用、内存使用情况等等）。主要是考察一些性能指标是否符合用户要求，比如汽车的一些性能指标有：汽车马力、载容量、速度。它主要是测试软件处理事务的速度，性能指标包括响应时间、CPU的使用，内存资源占用等。

**负载测试：**确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况。比如：通过增加并发用户数和事务数量来测量组件或系统能够承受的负载。是用于检查系统在使用大量数据的时候正确工作的能力，也就是检查系统的能力最高能达到什么程度。正常工作下的最大承载量。

**压力测试：**在规定的或超过规定的需求条件下测试组件/系统，以对其进行评估。它是为了评价一个系统或一个组件达到或超过需求规定的界限时的反应的测试。可以检查系统在超负荷的情况下的性能反应（例如：通过在高数据量或特定的错误条件下工作）。主要任务是获取系统正确运行的极限，检查系统在瞬间峰值负荷下正确执行的能力，不管性能指标，直到瘫痪前，在能用与不能用之间，测的是最大限度下的运行情况。

**手工测试：**不借助自动测试工具完成的测试。手工测试者最适合成为领域专家，他们可以把相当复杂的业务逻辑存在最强力的测试工具——大脑里。而且手工测试速度比较慢，测试者就有时间可以观察分析细微的逻辑问题。速度虽然慢些，但是比较容易。

**自动化测试：**借助工具进行的测试。自动化胜在测试底层的细节。自动化可以测试崩溃、挂起、错误返回值、返回码、异常和内存使用等等。速度快但是也困难些。想对业务逻辑进行自动化测试比较困难，风险也大。事后想想，我觉得Vista就有这个问题，太依赖自动化测试了。如果能加多一些手工测试人员，效果会更好。 

**4. 需求分析**

**用户需求：**一开始先要有需求，通过需求调研产生用户需求，用户需求就是用户自以为的需求，并且经常表达为用户的解决方案。

**产品需求：**就是经过产品经理的分析，找到的真实需求，并且表达为产品的解决方案。

**需求分析：**用户需求和产品需求是不同的，而这之间的转化过程，就是需求分析。虚无分析是从用户提出的需求出发，找到用户内心真正的渴望，再转化为产品需求的过程。

　　伟大的需求分析师，可以无视用户想要的东西，去探究他内心真正的渴望，再给出一个更好的解决方案，或者说是用户真正需要的东西。

**5. 测试计划**

　　就是在软件测试工作正式实施之前明确测试的对象，并且通过对资源、时间、风险、测试范围和预算等方面的综合分析和规划，保证有效的实施软件测试。

　　试计划是用来计划测试的，指导整个测试过程，所以一个好的测试计划一定是可以指导测试的，就是对整个测试过程中的人力、时间、资源、策略、范围做一个说明。

**测试目的：**主要是测试计划这个文档要达到的目的。比如：本文档对xx系统项目测试工作做了总体规划，用于指导xx系统测试工作开展，适用于xx系统项目所有参与者。

**测试项目简介：**介绍产品的规格，产品的信息，用户以及开发该产品的背景。描述没有这个产品的时候，所处的悲惨境地，还要介绍技术结构和产品的主要功能。比如：xx系统是一个类淘宝的电商网站，采用BS架构，主要包括，前台和后台业务，前台业务包括首页、登录、注册、购物车、商品货架等等，后台包括上传商品信息和图片、商品管理、会员管理等等。

**测试参考文档：**测试计划中引用的文档或书籍，还有规格说明书、概要设计说明书、用户手册、引用文件、其他资料等等。

**测试提交文档：**测试计划、测试用例、测试日志、缺陷报告、测试总结报告

**术语定义：**是为了让非专业人士也能看懂你这份测试计划，很多老板他们不是测试专业出身，很多测试术语他们不知道，比如性能测试中的流量、点击率、吞吐量，类似这些专有名字一定要有一个介绍。

**测试策略：**是描述测试小组用于测试整体和每个阶段的方法，确定测试策略要从模块、功能、整体、系统、版本、压力、性能、配置和安装等各个方面来考虑。比如：值域测试、大数据测试、SQL语句导入、功能测试、是否做安全测试、性能测试、稳定性测试等等。

**测试工具：**本项目所使用的工具，比如bug管理工具QC、bugfree、bugzilla、禅道、mantis等等。如果需要工具，那么对自动化测试工具和性能测试工具做个简单的测试说明。QTP、Loadrunner等等

**测试阶段进入退出的标准：**进入标准是允许系统进入一个特定的测试阶段时所必备的条件。退出标准：规定什么条件下测试可以结束。

**确定测试内容：**历史功能是否做测试，新增的模块是否做测试。把功能列表整理清楚。

**资源：**包括人力资源、硬件资源和软件资源。还有测试环境，从哪个测试环境来执行，谁负责测试环境的建立和制造，要明确责任人。

**测试进度安排：**根据软件的大小和系统不同，一般安排测试3轮，每轮周期多长，截止到上线，线上跟踪时间等等。每轮时间怎么评估呢，可以根据测试用例的多少来评估，比如张三负责的A模块要3天完成，李四负责的B模块要5天完成，王五负责的C模块要4天完成，那么这轮测试计划的时间要按照5天来算，这个叫最大关键路径法。而整体的测试时间安排一般是用倒退法，比如，一个项目3个月，2个月用来开发了，那么最终的测试你就剩1个月了，测试时间就只能在这1个月内计划和安排。

**测试人员的任务分配：**就是谁负责哪个模块。最好是征求下组内人员的意见，尽可能把能力比较强的人放到核心模块，可以更好的保证质量和控制风险。

**在测试计划中我们要提前预知几个风险，**比如：bug太多了改不完咋办？你不能一直改下去啊，有市场的压力呢；测试资源设备和人员能否及时到位；测试人员的技能是否达标？开发进度发生了变化或者需求和设计有变更怎么办？还有性能调优达不到上线的标准，但没时间调了怎么办？

　　有了风险，还要想出相应的措施来应付紧急风险。

**一页纸测试计划**

　　在公司里一般都是测试经理或者项目负责人去写测试计划，不是每个人都需要写的，但是测试经理在写这个测试计划的时候会跟每个测试人员去沟通，然后汇总成一份完整的测试计划。测试计划写完之后要进行评审，项目经理、产品经理。测试计划每次都会做，但在互联网公司，通常计划赶不上变化，测试计划就是废纸一张，你本来定的测试3轮，很多时候bug太多了，根本来不及测试第二轮就到上线时间了，他们更愿意上线了之后再改，然后就带bug上线了，但是你说既然大部分时间没用，那就不写了吧，那也不行，好歹大家是知道在这个基础上变化的。

　　测试计划内容这么多，其实核心就是三要素：时间、资源、范围。时间就是什么时候做以及要花多长时间做？资源就是你要调用的人力、机器等资源，范围是你要测试的东西以及测试重点。谷歌的一位测试总监曾经提到过一页纸测试计划，就是测试计划内容你不要写太多，就写必要的这三要素，写一页纸就好了，写多了没人看，而且变数也很大。所以没必要写那么多，但为什么讲这么多，减掉些内容容易，不讲的话增加起来就难了，对吧。

**测试时间进度表、测试里程碑、具体测试实施任务和时间人员安排**

**测试计划和测试方案的区别：**

　　如果是功能测试手工测试的话，测试计划和测试方案并没有区别，但是如果是自动化测试、性能测试或者其他更复杂的测试的话，就需要做个单独的说明。

**6. 测试用例**

　　开发工程师在设计与编码的同时，测试工程师也没闲着，他们会继续细化和调整测试计划，并完成TC编写的任务。在TC中，测试人员会进行测试任务的描述，体现测试方案、方法、技术和策略。内容包括测试目标、测试环境、输入数据、测试步骤、预期结果、测试脚本等，并形成文档。

　　是按一定的顺序执行的并与测试目标相关的测试活动的描述，它确定怎样测试。测试用例时有效发现软件缺陷的最小执行单元，是软件的测试规格说明书。
指对一项特定的软件产品进行测试任务的描述，体现测试方案、方法、技术和策略，内容包括测试目标、测试环境、输入数据、测试步骤、预期结果、测试脚本等，并形成文档

1）	大纲法

2）	等价类划分法

3）	边界值法

4）	决策表法

5）	因果图法

6）	正交表法

7）	场景法

8）	状态图转换法

**测试用例的设计方法的选择：**

![典型技全栈术模型](http://lemon.lanqiao.org:8082/teaching/img/test/test001.png)

　　以上测试用例的方法请参看视频《测试用例》

**测试用例的内容：**

**项目名称：**指明本测试用例是用来测试什么软件项目的

**功能模块名：**指明要测试的内容，如菜单名称，模块名称等

**测试目的：**描述被测试功能的详细的特性，要测试的目标

**用例编号：**标识该测试用例的唯一编号

**操作步骤：**描述实现用例的步骤

**预置条件：**执行测试用例之前所做的操作，如启动程序等。

**输入数据：**描述测试用例所需的输入数据或条件。例如测试计算器，输入可以就是1+1；测试基于文件的操作，输入可以是文件名，或者内容的描述

**预期结果：**描述输入数据后程序应该的输出结果。例如：1+1的预期结果是2。

**实际结果：**输入数据后程序实际的输出结果。主要是说明测试用例是否通过，如果不通过，就有bug，那么bug编号也要跟填写，bug编号可以去bug跟踪系统当中去查找。

**但是，在很多情况下，测试用例模板的是不同的，可以调整，比如某些项不填或者增加某些项。也可以采用简单的数据表的格式。比如：财务系统，测试过程需要数以万计的用于计算的输入数据，这时测试用例就可以只写数据的组合。**

**测试用例的优先级：**你的程序不需要十全十美，但必须符合目标用户的需求和期望。所以你要确定什么是应用程序中最重要的，目标和风险又是什么。Ross collard在use case testing一文中说：测试用例的前10%和15%可以发现75%到90%的重要缺陷。测试用例的优先级划分就是要帮助找出这前10%到15%的测试用例。

1-	小版本确认测试（BVTs）：也叫冒烟测试，这是一组你想先运行的以确定这个小版本是否可以测试的测试用例。如果这个优先的测试用例测试失败，你试图去做其他任何的测试都没有意义，因为他们大多数肯定要测试通不过。所以在企业当中，你拿到一个新的版本，应该先运行冒烟测试用例。比如:登录模块中会有很多用例，但是其中第一条使用正确的用户名和正确的密码，你要能测试通过，才去测试别的才有意义。这种用例占总用例的10%~~15%

2-	高：最常执行以保证功能性是稳定的。占总用例的20~30%

3-	中：这是更详细的功能测试。占总用例的40~~60%

4-	低：这是最少被执行的测试用例。但这并不是说这些测试都不重要，只是说他们在项目的生命期间里不是常常被运行，例如GUI，错误信息，一些易用性测试。占用例的10%~~15%

　　划分测试用例的优先级是很有好处的，可以为待定的自动化项目做一个好的起点。比如：BVT中的测试用例，就可以采用自动化测试，因为他们在每个版本提交之前就必须执行一次。

　　TC编写完成后，测试经理会组织TC评审，时间一般在开发提交测试之前，PD和开发人员都要参与评审，再次确认大家对需求的理解是否一致。很多需求的细节无法在需求阶段考虑完全，会通过开发和测试阶段的反复沟通来不断细化。

　　TC评审通过，待开发提交测试以后，测试会迅速完成一轮冒烟测试，目的是确认软件基本功能可用，可以进行后续的正式测试工作。

　　冒烟测试起源于硬件术语，当一个电路板设计好之后第一步要做的就是先给电路板充电，如果一插电就冒烟的话，说明电路板的基本功能不可用，那么就不需要再做其他的测试了。引申到软件测试当中，冒烟测试其实就是指软件的基本功能的测试。

比如登录功能：

1）使用正确的用户名和正确的密码可以成功登录；

2）使用错误格式的用户名和密码登录失败；

3）使用错误的密码登录失败；

4）网络异常登录失败；

5）用户名已存在登录失败；

　　那么其中第1条就是属于冒烟测试的范畴，这一条用例叫做冒烟测试用例。只有这一条通过了测试，才测试其他的。

　　在测试人员正式开始测试的同时，PD又要出场了，我们会组织一次产品的评审，或者叫产品演示会，利用测试环境，把可以使用的产品在第一时间给所有的项目干系人，更进一步确保做出来的东西就是大家想要的。功能评审过后，PD一般还会代表用户做更详细的UAT，或者称为验收测试。

　　接下来，测试的同学会做多轮测试，是一个发现bug，开发修正，测试验证，发现新bug的循环过程，从第2轮开始就可以叫做回归测试，在bug都处理妥当之后，项目紧接着就进入了发布阶段，有的项目除了功能测试以外，还需要做性能测试，比如验证系统是否能承受1万用户同时访问的压力，公司也有特定的测试工程师做这方面的事情，他们一般是多个产品共用的资源。

**编写测试用例必要性和粒度一直有争论。**其实如果你是一家传统软件公司，一个项目可能几个月甚至半年、一年才一次交付，那你就有充足的时间去设计用例。

　　但是在大多数互联网公司，基本都走敏捷，讲究小步快跑，快速试错，基本上产品迭代非常频繁，经常两周一个迭代，这就导致留给测试的时间极短，更别说写用例的时间，这时咱们就不得不做某种程度的妥协，简化用例，或者说我们更多的是写测试点。只写测试点并不是说不考虑各种用户场景，而是尽可能通过一句话描述出这个场景的概要，这样测试人员在了解需求的前提下通过这么一句话概要就知道怎么执行用例，这对测试员的要求会相对高一些。

　　其实用例写多了，总会发现很多功能模块是类似的，例如查询功能，翻页功能，文本框校验，时间控件校验等等，这时可以学学编程思路，你可以提取类似的测试用例，形成一个用例库，给相同的功能模块复用。

　　其实编写用例之前，也可以找开发聊聊，是如何实现这个功能。这样可以很容易的把握到测试的注意点。例如Ａ开发曾经用某种方式做了ａ功能，出现了某个bug,现在B开发用了同样方式实现，那么极有可能之前的bug这次还会出现。

　　还有一点就是，产品走迭代，测试用例同样也需要迭代。

**7. 执行测试**

**Bug的级别定义：**

![典型技全栈术模型](http://lemon.lanqiao.org:8082/teaching/img/test/test002.png)

缺陷级别：Severity：即上图中的5级定义，一般大于3级的bug被认为是严重过的问题。

所属产品、项目：有的人需要同时处理很多产品、项目，这个属性可以用来筛选。

Bug名称：一个短句，对此bug的简单说明。

Bug描述：写成如下格式，执行某操作，期望出现什么情况，实际出现什么情况，还可以添加截图、文档等附件。

**测试管理工具：QC（请看QC/bugfree的使用视频）**

　　它是Mercury Interactive公司的Quality Center，是一个基于Web且支持测试管理的所有必要方面的应用程序。更小的团队，用Excel来管理bug也未尝不可。作为PD，也是会经常提bug的，与测试人员相比，PD做测试的时候主要是模拟用户的身份正常使用产品，而测试人员会更多地按照TC执行，尝试极端的使用情景下产品有没有漏洞。

**Bug的生命周期**

　　在发现一个bug以后，我们会提交给相应的开发工程师，如果认为是需求问题也可以提交给对应的PD，这时候bug的状态为Open，之后的状态改变。

![典型技全栈术模型](http://lemon.lanqiao.org:8082/teaching/img/test/test003.png)

　　任何人收到Open的bug，确认并修复，状态变为fixed；否认，也许提出者理解错了，也许不打算修改，状态改为Rejected；认为不是自己的问题，或者PD对需求问题作出解释之后，把bug转交Asign to给了合适的人。

　　测试人员验证状态为Fixed的bug，没问题了就Closed，否则可以Reopened。看到Rejected的bug，发现是自己理解错了，就可以Closed，仍然认为是bug的可以Reopened。对于Deferred的bug，意味着本项目暂不修正，可能是因为技术做不到、时间不允许、性价比太低等，这个认定必须慎之又慎，通常由能负责的人，比如是测试经理、项目经理最终同意才Deferred。

　　在整个过程中，bug的每次状态改变都可以添加注释说明，我们更鼓励在有争议时叫上当事人面对面的交流，而不是在系统里不停的纠缠。

　　到了项目发布之时，我们要求所有的bug状态必须是Closed或Deferred，当然对1级和2级bug，有时候没这么严格。

　　使用QC相比Excel的好处在于，每个bug重要的状态转换点，系统都会有邮件通知到相关人员，防止遗漏；项目中每个人在系统里的角色不同，权限不同，此软件可防止误操作，甚至是一些恶意行为，比如开发人员就不能把bug状态改为Closed；所有操作都有记录，谁在何时做了什么，便于追溯。这些都有效地防止了人为因素导致的问题。

**8. 测试总结报告：**

**测试结束的标志：**

* 基本功能需求和非功能需求都实现了

* 全部测试用例回归测试都执行完毕了

* 框架不用再变了，缺陷数呈现收敛趋势，并趋于收敛走势

* 规定等级的bug都修复了，比如1、2级的bug和紧急的bug都修复了，90%的3级bug也都解决了。没修复的都得到了审核和批准。

**软件测试报告：**

是在测试结束后对整个测试过程与产品进行评估的过程。通过评估确定软件的各项指标是否满足测试标准的规定，检验应用程序是否合格。

**软件测试报告模板：**

1）	概述：编写目的、项目背景、参考文档

2）	测试情况：测试进度表、人员分工、用例模板

3）	遗留问题：遗留问题描述、问题级别、解决计划

4）	各种统计图：各模块缺陷数、测试人员的bug数、各状态bug数、开发人员的bug数、各级别的bug数、bug引入原因、bug趋势图。





