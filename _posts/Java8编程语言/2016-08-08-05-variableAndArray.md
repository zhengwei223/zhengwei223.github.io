---
layout: post
title: 变量与常量
category: 变量与常量
tags: Java 入门
keywords: 蓝桥 lanqiao 教程 java Java8 变量
description: 
author: 付天有
importance: 4
order: 5
---
## 第5章 变量与常量

> 本章目标

## 5.1 变量
变量在程序语言中扮演着最基本的角色。变量可以用来存放数据，而使用变置之前则必须先 声明它所预保存的数据类型。接下来看看Java中变量的使用规则。

### 5.1.1 变置的声明

举例来说，想在程序中声明一个可以存放整数的变量，这个变量的名称为num，在程序中即可写出如下所示的语句：

	int num;//声明num为整數变量

int为Java的关键字，代表整数的声明。若要同时声明多个整型的变量，可以像 上面的语句一样分别声明它们，也可以把它们都写在同—个语句中，每个变量之间以逗号分开（`int num,age,year;`）。

### 5.1.2 变量名称

每个人可以依据个人的喜好来决定变置的名称，这些变置的名称不能使用Java的关键字。通常会以变量所代表的意义来取名（如num代表数字）。当然也可以使用a、b、o等简单的英文字母代表变量，但是当程序很大时，需要的变量数量会很多，这些简单名称所代表的意义就比较容易忘记，必然会增加阅读及调试程序的困难度。

### 5.1.3 变置的赋值
给所声明的变量赋予一个属于它的值，用等号运算符`=`来实现。具体可使用如下所示的 3种方法进行设置。

1. 在声明变量时赋值
举例来说，在程序中声明一个整数的变量num，并直接把这个变量陚值为2,可以在程序中写出如下的语句。
	int num = 2;//声明变量，并直接设置

2. 声明后再设置

般来说也可以在声明后再给变量陚值。举例来说，在程序中声明整数的变量num丨、num2 及字符变Mch,并a给它们分别賦值，在程序中即可写出下面的语句。
	
	int num1,num2 ; 
	char c ;		//声明变量
	num1 = 2; 		//变量赋值
	num2 = 3;
	ch = 'z';

### 5.1.4 变量的作用域和生存期

到目前为止，使用的所有变量都是在main()方法开始时声明的。然而，Java允许在任何 代码块中声明变量。正如在`第3章`中所解释的，代码块以开花括号开始并以闭花括号结束。 代码块定义了作用域。因此，每当开始一个新的代码块时就创建了一个新的作用域。作用域 决定了对象对程序其他部分的可见性，并且也决定了这些对象的生存期。

许多其他计算机语言定义了两种通用的作用域类别：全局作用域和局部作用域。然而，这些传统的作用域不能很好地适应Java中严格的、面向对象的模型。虽然可以创建属于全局 作用域的变量，但这只是例外，而不是规则。在Java中，两种主要的作用域分别是由类和方 法定义的。尽管这种分类有些人为因素，但是，由于类作用域具有的一些独特属性和特性，不能应用于由方法定义的作用域，因此这种分类方法有一定的道理。由于存在这种差别，对类作用域(以及在其中声明的变量)的讨论将推迟到后续章节，那时会介绍类的相关内容。现在，只分析由方法定义以及在方法中定义的作用域。

由方法定义的作用域从方法的开花括号开始。然而，如果方法具有参数，那么它们也会 被包含到方法的作用域中。尽管本书在第6章会进一步分析参数，但是出于作用域讨论的目的，在此将它们与任何其他方法变量一样一并考虑。

作为通用规则，在作用域中声明的变量，对于在作用域之外定义的代码是不可见的(即不可访问)。因此，当在某个作用域中声明变量时，就局部化了该变量，并保护它免受未授权的访问和/或修改。实际上，作用域规则为封装提供了基础。

作用域是可以嵌套的。例如，每当创建一个代码块时，就创建了一个新的、嵌套的作用域。当遇到这种情况时，外层的作用域包围了内层作用域。这意味着在外层作用域中声明的 对象对于内层作用域中的代码是可见的。然而，反过来就不是这样了，在内层作用域中声明 的对象，在内层作用域之外是不可见的。

**[程序清单 5.1.4]**

	class Scope {

		public static void main(String args[]) {
			int x; // main方法内部的x变量
			x = 10;
			if (x == 10) { // 开始一个新的作用于
				int y = 20; // 尽在当前代码块内有效的变量y
				// x与y都可以访问
				System.out.println("x and y: " + x + " " + y);
				x = y * 2;
			}
			// y = 100; //错误! 已超出y的作用于
			// x 仍可以被访问
			System.out.println("x = " +x);
			
		}
	}

**[运行结果]**

	x and y: 10 20
	x = 40
正如注释指出的，变量x是在main()作用域的开始处声明的，因此main〇方法中的所有 后续代码都可以访问变量X。变量y是在if代码块中声明的，既然代码块定义了作用域，所 以只有对于if代码块中的代码y才是可见的。这就是为什么在if代码块之外，将“y=100;”注释掉的原因。如果删除前面的注释符号，就会发生编译时错误，因为在if代码块之外y不 是可见的。在if代码块的内部可以使用x,因为代码块(即嵌套的作用域)中的代码可以访问在外部作用域中声明的变量。

在代码块中，可以在任意位置声明变量，但是只有在声明之后变量才是有效的。因此，如果在方法的开头定义变量，那么变量对于该方法的所有代码都是可见的。相反，如果在代 码块的末尾声明变量，那么变量是无用的，因为没有代码能够访问该变量。例如，下面的代码片段是无效的，因为count在声明之前不能使用：

	//错误的使用!
	count = 100; //注意!不能在声明前使用变量
	int count;

最后一点：尽管可以嵌套代码块，但是在内层代码块中不能声明与外层代码块具有相同名称的变量。例如，下面的程序是非法的：

**[程序清单 5.1.5]**
	
	class ScopeErr {
	
		public static void main(String args[]) {
			int bar = 1;
			{
				// 创建一个新作用域
				int bar = 2;// 编译错误： error "C bar already defined!
			}
		}
	}


## 5.2 常量
在Java语言中，利用final关键字来定义Java常量，其本质为值不可变的变量。
因为Java常量的本质是值不可变的变量，所以在声明的时候，就必须要进行初始化。和变量不同的是，Java常量在程序中将无法再进行赋值，如果强行赋值，程序会抛出错误信息，并拒绝接受这一个新的值。

**[程序清单 5.2]** 常量的定义

	public class FinalValue{
		public static void main(String[] args){
			final int STU_AGE = 22;			//定义Java常量STU_AGE，其值为22
			System.out.println(STU_AGE);	//打印出STU_AGE的值
			STU_AGE = 27;					//企图改变Java常量的值
		}
	}

**[运行结果]**

![运行结果](https://coding.net/u/lanqiao/p/lanqiao/git/raw/coding-pages/public/img/Java8/2016-08-05_finalValue.png)

## 5.3 字面常量 
要了解字面常量我们先看一段代码如下：
	int age =100;
这是一段变量的声明与赋值的代码，age是我们声明的变量，这个变量被赋值为100，
那么100就称之为“字面常量”或者“字面值“。

字面常量可分为如下几类：


**1. 整数常量**

- 十进制:第一位不能是0(0本身除外)的4字节整数　`例:255,1024`

- 十六进制:以0x或0X开头的4字节整数　`例:0x128,  0XFF,   0X9A`
- 八进制:以0开头的　`例:0123, 045, 055`

- 长整形:以L作为结尾，表示8字节的整数　`例:156L, 44L`

***注：整数常量默认为4字节，需要注意值的范围***


**2. 浮点数常量**

- 单精度(float):需要以F/f结尾,可以使用指数表示,占4字节空间　`例:2e3f, .4f, 5.022e+23f,0f`
- 双精度(double):需要以D/d结尾,可以使用指数表示,占8字节空间　`例:3.6d, 3.84d, 2.5e-10d, 0d`

***注：浮点常量默认为8字节，需要注意值的范围***


**3. 字符常量**

字符常量是由英文字母,数字,转义序列,特殊字符等所表示,它的值就是字符本身,字符常量要用两个单引号括起来, Java中的字符是Unicode编码占2字节,也可以使用Unicode码值加上"\u"来表示对应的字符.　`例:'a','\t','\u0027'`

**4. 布尔常量**

Java中的boolean值仅有2个值:**true**,**false**. 


**5. null常量**

null常量只有一个值,通常用来表示对象的引用变量的值为空,即不指向任何对象.

## 5.3 数组

数组是以通用名称引用的一组类型相同的变量。可以创建任意类型的数组，并且数组可 以是一维或多维的。数组中的特定元素通过索引进行访问。数组为分组相关信息提供了一种 便利方法。

### 5.3.1 —维数组

一维数组本质上是一连串类型相同的变量。为了创建数组，首先必须创建期望类型的数 组变量。声明一维数组的一般形式如下所示：

	type var-name [];

其中，type声明了数组的元素类型(也称为基本类型)。元素类型决定了构成数组的每个元素的类型。因此，数组的元素类型决定了数组可以包含什么类型的数据。例如，下面的语句声明了一个名为month_days的数组，该数组的类型是“int数组”：

	int month_days[];

尽管这个声明确立了month_days是数组变量的事实，但是这个数组实际上并不存在。为 了将month_days链接到一个实际的、物理的整数数组，必须使用new分配一个数组，并将之赋给month_days。new是一个用于分配内存的特殊运算符。

在后面的章节中会更加详细地分析new运算符，但是现在需要使用它为数组分配内存。 将new运算符用于一维数组的一般形式如下所示：

	array-var = new type [size];

其中，type指定了将要分配的数据的类型，size指定了数组中元素的数量。array-var是 链接到数组的数组变量，即为了使用new分配一个数组，必须指定要分配元素的类型和数量。 通过new分配的数组，其元素会被自动初始化为0(对于数值类型)、false(对于布尔类型)或 null(对于引用类型，引用类型将在后面的章节中描述)。下面这个例子分配了一个具有12个元素的整数数组，并将该数组链接到month_days:

	month_days = new int[12]

执行完这条语句之后，month_days将指向具有12个整数的数组。此外，数组中的所有元素都被初始化为0。

下面回顾一下：获得一个数组需要两个步骤。

- 首先，必须声明一个期望数组类型的变量。 
- 其次，必须使用new分配容纳该数组的内存，并将其赋给数组变量。

因此，在Java中所有数组都是动态分配的。如果不熟悉动态分配的概念，不要着急。在后面章节会对其进行详细描述。

一旦分配数组，就可以通过在方括号中指定索引的方法来访问数组中的特定元素。所有数组索引都是从0开始的。例如，下面这条语句将数值28赋给month_days的第2个元素：

	month_days[1] =28;

下面这条语句显示在索引3处保存的值：

	System.out.println(month一days[3]);

下面的程序将所有这些内容组合到一起，创建了一个包含一年中每个月份天数的数组：

**[程序清单 5.3.1-1]**

	public class Array {
	
		public static void main(String args[]) {
	
			int month_days[];
			month_days = new int[12];
			month_days[0] = 31;
			month_days[1] = 28;
			month_days[2] = 31;
			month_days[3] = 30;
			month_days[4] = 31;
			month_days[5] = 30;
			month_days[6] = 31;
			month_days[7] = 31;
			month_days[8] = 30;
			month_days[9] = 31;
			month_days[10] = 30;
			month_days[11] = 31;

			System.out.println("April has " + month_days[3] + " days.");
		}
	}

**[运行结果]**

	April has 30 days.

当运行这个程序时，会打印出4月份的天数。前面提到过，Java数组的索引从0开始， 所以4月份的天数是month_days[3]或30。

可以将数组变量的声明和数组本身的分配组合起来，如下所示：

	int month—_days[] = new int[12];

在专业编写的Java程序中，通常采用的就是这种方式。

当声明数组时，可以对其进行初始化，这一过程与初始化简单类型的过程相同。数组初 始化器(array initializer)是一个位于花括号中由逗号分隔的表达式列表。用逗号分隔数组元素的值。Java会自动创建足够大的数组，以容纳在数组初始化器中指定的元素的数量。这时不需要使用new运算符。例如，为了保存每个月份的天数，下面的代码创建了一个已初始化的整数数组：

**[程序清单 5.3.1-2]**

	public class AutoArray {
		public static void main(String args[]) {
			int month_days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; 
			System.out.println("April has " + month_days[3] + " days.");
		}
	}

**[运行结果]**

	April has 30 days.

当运行这个程序时，看到的输出与程序前面版本生成的输出相同。

Java会进行严格的检查，以确保不会意外地试图保存或引用数组范围之外的值。Java运行时系统会进行检查，以保证所有数组索引都在正确的范围之内。例如，运行时系统会检查 month_days的每个索引值，以确保它们在0到11之间。如果试图访问数组范围之外(索引为负数或大于数组长度)的元素，就会导致运行时错误。

### 5.3.2 多维数组

在Java中，多维数组实际上是数组的数组。可能正如您所愿，Java中的多维数组无论是 形式还是行为都与常规的多维数组类似。然而，您将会看到它们之间有一些微妙的区别。为了声明多维数组变量，需要使用另外一组方括号指定每个额外的索引。例如，下面声明了一 个名为twoD的二维数组：

	int twoD[][] = new int[4][5];

这条语句分配了一个4X5的数组，并将之赋给twoD。在内部，这个矩阵是作为int数 组的数组实现的。从概念上讲，这个数组看起来如图 5.3.2 所示。

![多维数组](http://1)
图5.3.2

当为多维数组分配内存时，只需要为第一(最左边的)维分配内存。可以单独为余下的维分配内存。例如，下面的代码在声明时为twoD的第一维分配内存，然后手动分配第二维：

	int twoD[][]=new int[4][];
	twoD[0] = new int[5];
	twoD[1] = new int[5];
	twoD[2] = new int[5];
	twoD[3] = new int[5];

虽然对于这种情况单独分配第二维没有优点，但是这对于其他情况可能有优点。例如， 当手动分配维数时，不必为每一维分配相同数量的元素。正如在前面说明的，既然多维数组 实际上是数组的数组，那么您可以控制每个数组的长度。

使用不一致(或不规则)的多维数组对于许多程序可能不合适，因为这和人们遇到多维数 组时所期望的情况不同。然而，在某些情况下却可以高效地使用不规则数组。例如，如果需要一个非常大的二维稀疏数组(即只使用其中的部分元素)，那么不规则数组可能是完美的解决方案。

可以初始化多维数组。为此，只需要在一连串的花括号中包含每一维的初始化器。下面 的程序创建了一个矩阵，其中的每个元素包含各自列索引和行索引的乘积。还应当注意，在数组初始化器中也可以使用表达式以及字面值。

**[程序清单 5.3.2]**
	public class Matrix {
	
		public static void main(String args[]) {
			double m[][] = {
				{ 0 * 0, 1 * 0, 2 * 0, 3 * 0 },
		
				{ 0 * 1, 1 * 1, 2 * 1, 3 * 1 },
		
				{ 0 * 2, 1 * 2, 2 * 2, 3 * 2 },
		
				{ 0 * 3, 1 * 3, 2 * 3, 3 * 3 } };
		}
	}

## 5.3.3 另一种数组声明语法

还有另一种用于声明数组的形式:

	type[] var-name;

其中，方括号位于类型限定符之后，而不是位于数组变量名的后面。例如，下面两个声 明是等价的：

	int al[] = new int[3]; 
	int[] a2 = new int[3];

下面的声明也是等价的：

	char twodl[][] = new char[3][4]; 
	char[][] twod2 = new char[3][4];

当同时声明多个数组时，这种形式可以提供便利，例如：

	int[] nums, nums2, nurns3; // create three arrays

这可以创建3个int类型的数组变量，上述语句和下面的声明语句是等价的：

	int nums[], nums2[], nums3[]; // create three arrays

当将数组指定为方法的返回类型时，这种数组声明方法也是有用的。
