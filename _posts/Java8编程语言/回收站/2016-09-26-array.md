

# 实验一 扑克游戏

> 目的 声明一副扑克牌，完成3人的发牌，剩余3章底牌，并输出3个人的牌以及底牌。1-13(黑桃A-K)、14-26(红桃A-K)、梅花、方片。53小鬼，54大鬼，

## 思考

一副扑克牌有54张牌，每张牌可以用一个1-54的整型变量表示，如果利用传统的变量声明，我们需要声明54个变量，来表示一副扑克牌。

显然如果这样声明程序会显得非常的冗杂，我们需要一种技术，把拥有相同意义或者相同数据类型的数据统一声明表示。

## 关键技术

### 数组
所谓数组，就是相同数据类型的元素按一定顺序排列的集合，就是把有限个类型相同的变量用一个名字命名，然后用编号区分他们的变量的集合，这个名字称为数组名，编号称为下标。先来看一个简单的数组声明

	int[] monthDays = new int[12];//声明12一个长度为12的int类型数组，表示12各月份的天数
								  //相当于12个int类型变量
	monthDays[0] = 31;//数组的下标是从0开始的。利用数组变量monthDays+[下标]引用数组的每一个变量，monthDays[0]代表1月份的天数。
	monthDays[1] = 28;
	monthDays[2] = 31;
	monthDays[3] = 30;
	monthDays[4] = 31;
	monthDays[5] = 30;
	monthDays[6] = 31;
	monthDays[7] = 31;
	monthDays[8] = 30;
	monthDays[9] = 31;
	monthDays[10] = 30;
	monthDays[11] = 31;

### 随机数 

利用`Math.random()`方法可以获取一个0~1之间的小数。

## 设计

	//扑克牌声明
	//扑克牌赋值
	//玩家手牌声明
	//发牌
	//获取0-53随机数，派给玩家（可以先给一家派牌，也可轮流派）
	//如果随机下标已派出，则该下标值置为-1，如遇到-1，重新生成随机数派牌
	//输出各玩家手牌

## 实现

	import java.util.Arrays;
	
	public class Poker {
		public static void main(String[] args) {
			//扑克牌声明
			int[] cards = new int[54];
			//扑克牌赋值
			for (int i = 0; i < cards.length; i++) {
				cards[i] = i+1;
			}
			//玩家手牌声明
			int[] player1 = new int[17];
			int[] player2 = new int[17];
			int[] player3 = new int[17];
			
			//为player1发牌
			for (int i = 0; i < player1.length; ) {
				
				int ram = (int) (Math.random() * (53+1));;//获取0-53随机数，派给玩家（可以先给一家派牌，也可轮流派）
				if(cards[ram]>0){
					//如果随机下标已派出，则该下标值置为-1，如遇到-1，重新生成随机数派牌
					player1[i] = cards[ram];
					cards[ram] = -1;
					i++;
				}
			}
			
			//为player2发牌
			for (int i = 0; i < player2.length; ) {
				//发牌
				int ram = (int) (Math.random() * (53+1));
				if(cards[ram]>0){
					player2[i] = cards[ram];
					cards[ram] = -1;
					i++;
				}
			}
			
			//为player3发牌
			for (int i = 0; i < player3.length;) {
				//发牌
				int ram = (int) (Math.random() * (53+1));
				if(cards[ram]>0){
					player3[i] = cards[ram];
					cards[ram] = -1;
					i++;
				}
			}
			
			//输出各玩家手牌
			System.out.println(Arrays.toString(player1));
			System.out.println(Arrays.toString(player2));
			System.out.println(Arrays.toString(player3));
			//输出底牌
			for (int i = 0; i < cards.length; i++) {
				if(cards[i]!=-1){
					System.out.print(cards[i]+",");
				}
			}
		}
	}

## 解读

### 数组基本要素

- 标识符：数组的名称，用于获取数组元素的引用
- 数组元素：向数组中存放的数据
- 元素下标：对数组元素进行编号，从0开始，数组中的每个元素都可以通过标识符[下标]来访问
- 元素类型：数组元素的数据类型  

### 数组的声明

我们使用的都是先声明`int[] cards = new int[54];`，在通过下标赋值。

我们还可以直接在声明时赋值

	int[] monthDays = new int[]{31,28,31,30,31,30,31,31,30,31,30,31};

或者

	int[] monthDays = {31,28,31,30,31,30,31,31,30,31,30,31};

这两种方式都只适合，数组元素较少，且声明时就已知道数组的各个元素。

注意：`int[] monthDays = {31,28,31,30,31,30,31,31,30,31,30,31};`仅能在一行中声明，**不可以**先声明`int[] arr;`在赋值`arr={31,28,31,30,31,30,31,31,30,31,30,31};` 

### 数组的赋值
循环在数组的应用中是非常广泛的，数组拥有连续的特点，每一个数组元素都可以通过下标来获取，而下标是从0开始连续的正整数，配合循环我们可以非常容易的操作数组中的每一个元素。

### 指定范围内的随机数

我们需要0~53的随机数，而`Math.random();`获取了0~1之间的小数，那么我们只要把随机数乘以53即可获得一个0~53的随机实数，但是这个数不能够等于53，所以`(int) (Math.random() * （53+1）);`可以获得0~53的随机整数。

### Arrays工具类

`Arrays.toString(player1)`可以把数组变为一个字符串，格式为`[数组元素,...]`,Arrays需要`import java.util.Arrays;`引入工具包，Arrays提供了很多数组操作方法，可以参考API文档。

## 优化

在声明player1，player2，player3时，我们反复声明了3个数组，那么数组类型是否也可以声明为数组呢？

	int[][] players = new int[3][17];//相当于3个int[17]的数组

这种数组称作二维数组，声明方式与普通一位数组类似，同理还有三维、四维数组..N维数组。

我们利用二维数组来优化一下我们的代码

	import java.util.Arrays;
	
	public class Poker2 {
		public static void main(String[] args) {
			//扑克牌声明
			int[] cards = new int[54];
			//扑克牌赋值
			for (int i = 0; i < cards.length; i++) {
				cards[i] = i+1;
			}
			//玩家手牌声明
			int[][] players = new int[3][17];
			
			//为player发牌
			for (int i = 0; i < players.length; i++) {
				//循环为每一个player发牌，players[i],就是每一个player的牌，数量为17
				for (int j = 0; j < players[i].length; ) {
					//player[i][j]为每一个player的具体某一张手牌
					int ram = (int) (Math.random() * (53+1));;//获取0-53随机数，派给玩家（可以先给一家派牌，也可轮流派）
					if(cards[ram]>0){
						//如果随机下标已派出，则该下标值置为-1，如遇到-1，重新生成随机数派牌
						players[i][j] = cards[ram];
						cards[ram] = -1;
						j++;
					}
				}
				System.out.println("player"+(i+1)+"的手牌" + Arrays.toString(players[i]));
			}
			
			//输出底牌
			for (int i = 0; i < cards.length; i++) {
				if(cards[i]!=-1){
					System.out.print(cards[i]+",");
				}
			}
		}
	}

二维数组可以利用嵌套循环来操作。


## 小结

### 什么是数组

> 数组是一种特殊的数据类型，它描述了一组拥有相同数据类型的数据集合。

比如我们现实生活种的书柜、鞋柜。都是用来装放特定事物的容器。如果把一本书比作一个"图书"类型的变量，那么书架就可以理解为一个图书类型的数组。

![数组示意图](http://lemon.lanqiao.org:8082/teaching/img/Java8/array.png)

### 为什么要使用数组

说到为什么要设计数组这种数据类型，思考一下为什么我们要使用书架？

当然，你会想到很多好处，如：便于管理图书、能够快速的定位到我想要找的图书、看起来更加简洁。

那么这些也正是数组存在的原因。

### 什么场景下需要使用数组

通常我们选择数据这种数据结构是要满足：

1. 一组变量拥有相同数据类型
2. 这些变量要拥有相同的表达意图
3. 这些变量的数量是已知或可预测

### 使用数组四部曲

#### 1. 声明数组

一维数组的声明方式：

	type var[]; 或 type[] var;
其中`type`为数据类型，var可以是任意合法的标识符

**注意**：声明数组时不能指定其长度（数组中元素的个数），`int scores[10];`是错误的声明

二维数组的声明:
	
	type var[][]; 或 type[][] var;

多维数组的声明相信大家可以举一反三了吧。
	
#### 2. 分配空间

这个过程是告诉计算机分配几个连续的空间
	
	int[] score;
	score = new int[10]; 分配一个10个int的一维连续空间
	int[][] arr2;
	arr2 = new int[5][5]; 分配一个5行5列的二维连续空间

#### 3. 赋值和引用

声明并赋值：

	int[] scores = new int[]{88,76,90,89,70,95,99,85,66,89};
	double m[][] = {
			{ 0 * 0, 1 * 0, 2 * 0, 3 * 0 },
	
			{ 0 * 1, 1 * 1, 2 * 1, 3 * 1 },
	
			{ 0 * 2, 1 * 2, 2 * 2, 3 * 2 },
	
			{ 0 * 3, 1 * 3, 2 * 3, 3 * 3 } };

需要注意的是"{}"这种赋值方式必须在声明时立刻赋值，且不能声明数组的长度，以下声明方式都是错误的：

	int[] scores;
	scores = {1,2,3,4,5};//错误！｛｝赋值只能跟在数组声明的时候。
	int[] arr = new int[3]{1,2,3};//错误！｛｝赋值不能指定数组长度

引用赋值：

我们可以通过数组的下标获取任意数组元素，并为其赋值

	int[] score = new int[30];
	Scanner input = new Scanner(System.in);
	for(int i = 0; i < 30; i ++){
	     score[i] = input.nextInt();
	}

注意：对于数组元素的引用和赋值要格外注意数组的下标，当所引用的下标超出了数组声明的长度，将会报出`java.lang.ArrayIndexOutOfBoundsException`异常

	int[] score = {10,11,52}; //score[0]=10;score[1]=11;score[2]=52;
	System.out.println(score[3]);//已经超出score数组的最大下标引用


#### 4. 数据处理

##### 数组的遍历：

遍历是数组的最基本操作：

	int[] scores = new int[]{88,76,90,89,70,95,99,85,66,89};
	for(int i=0;i < scores.length;i++){
		System.out.println("数组的第" + i + "位是" + scores[i]);
	}

以上代码就完成了遍历输出每一位数组元素。
这里用到了`数组对象.length`的方法来获取数组的长度

JDK1.5提供了一个增强的for循环来简化数组的遍历。

	for (int score : scores) {
		System.out.println(score);
	}

但是这中方式也有它的缺点，就是无法在循环体中获取数组的下标


##### 数组元素换位

	int[] scores = new int[]{88,76,90,89,70,95,99,85,66,89};
	//交换0号下标元素与9号下标元素
	int temp = scores[0];
	scores[0] = scores[9];
	scores[9] = temp;

数组元素的换位需要借助中间变量


# 实验二 对已知数字序列排序

> 目的：给定数字序列，按照由小到大顺序输出序列

## 为什么要研究排序

首先排序是一个非常常见的编程问题，在很多面试题中都会出现，那么我们为什么要挖空心思来研究排序问题呢？

1、业务场景需要：比如一个班级内学员的成绩，我们要求要从高到低排列。

2、便于查找：我们在一个无序的序列中查找一个元素，只能通过逐个元素去比对查找，而一旦序列有序，我们就能够很快的找到目标元素所处的区间。

3、利于统计分析：我们把数据排序后，就能够很方便去进行一些列的数据分析和统计，比如某一年度内商品的销量走势，这个序列就需要按照时间来排序。

## 实现思路

![排序算法原理](http://lemon.lanqiao.org:8082/teaching/img/Java8/bubble-sort.gif)

依次比较相邻的两个数，将小数放在前面，大数放在后面。
第一轮：首先比较第1个和第2个数，将小数放前，大数放后；然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后；至此第一轮结束，将最大的数放到了最后。
第二轮：仍从第一对数开始比较，将小数放前，大数放后，一直比较到倒数第二个数（倒数第一的位置上已经是最大的数），第二轮结束，在倒数第二的位置上得到一个新的最大数（其实在整个数列中是第二大的数）。
按此规律操作，直至最终完成排序。由于在排序过程中总是小数往前放，大数往后放，类似于小的气泡往上升，所以称作冒泡排序。
通过上面的分析可以看出，假设需要排序的序列的个数是n，则需要经过n-1轮，最终完成排序。在第一轮中，比较的次数是n-1次，之后每轮减少1次。

这个方法叫做冒泡排序法，让最大或最小的元素，像气泡一样一层一层冒出来。

## 代码

	/**
	 * 冒泡排序算法实现
	 */
	public class BubbleSort {
		public static void main(String[] args) {
			int[] a = new int[]{88,76,90,89,70,95,99,85,66,89};//待排序数组
			int temp;
			//数组的长度可以通过“数组名.length”获得
			for (int i = 0; i < a.length-1; i++) {			//需要比较n-1轮
				for (int j = 0; j < a.length-i-1 ; j++) {	//根据a.length-i-1，每轮需要比较的次数逐轮减少1次
					if (a[j] > a[j+1]) {			//相邻数进行比较，符合条件进行替换
						temp = a[j];
						a[j] = a[j+1];
						a[j+1] = temp;
					}
				}
			}
			System.out.println(Arrays.toString(a));
		}
		
	}

## 解读

排序算法有很多，且各自有各自的特点和应用场景，对于不同量级，是否部分有序，空间限制等等都是排序算法选择的依据。算法是一个优秀程序员的灵魂，在初学阶段大家可不必过分钻研，待掌握了基本程序写法后，大家可以深入研究更多的算法

Arrays工具类提供了sort方法，此方法利用快速排序法对给定数组进行排序。

	int[] arr = {1,3,5,8,6,11};
	Arrays.sort(arr);//对给定数组进行排序

更多排序算法参考[http://www.cricode.com/3212.html](http://www.cricode.com/3212.html)


# 实战练习

1、有100盏灯，依次编号1-100，初始都是关着的。第1次，打开全部的灯；第2次，关掉第2盏、第4盏等被2整除的灯；第3次打开被3整除的灯；第i次，对被i整除的灯做如下操作

- 如果灯开着，就关掉
- 如果灯关着，就打开

如此交替进行，知道100次遍历完毕，请问，还有多少盏灯亮着。

2、控制台录入10名学生考试成绩，输出最高分和最低分。

3、输出给定数列的倒序输出

4、有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13，求出这个数列的前20项之和。

5、打印出杨辉三角

![](http://lemon.lanqiao.org:8082/teaching/img/Java8/yanghui.jpg)

