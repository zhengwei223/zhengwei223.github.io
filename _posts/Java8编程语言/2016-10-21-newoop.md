---
layout: post
title: 面向对象的程序设计
category: 初学者的第一套Java教程
tags: Java 入门
keywords: 蓝桥 lanqiao 教程 java Java8 OOP 类 对象 
description: 高级面向对象
author: 付天有
importance: 2
order: 8
---

# 实验一 管理多个牌局的问题

> 之前我们完成了一副扑克牌的洗牌和发牌。如果程序升级为网络游戏，支持很多玩家同时玩扑克，每三个人凑成一局并发牌。

## 1 类外部调用static方法

	package chapter06.main;//声明当前类的包路径
	
	import chapter06.Poker4;//导入所要使用的外部类
	
	public class GameCenter {
		
		public static void main(String[] args) {
			
			int[] player1;//玩家1加入游戏
			int[] player2;//玩家2加入游戏
			int[] player3;//玩家3加入游戏
			//初始化牌堆,准备为玩家1，2，3发牌
			Poker4.init();//类名.方法名来在类外部调用方法
			player1 = Poker4.deal(3);//玩家1发3张牌
			player2 = Poker4.deal(3);//玩家2发3张牌
			player3 = Poker4.deal(3);//玩家3发3张牌
			
			int[] player4;//玩家4加入游戏
			int[] player5;//玩家5加入游戏
			int[] player6;//玩家6加入游戏
			
			//初始化牌堆,准备为玩家4，5，6发牌
			Poker4.init();
			
			player4 = Poker4.deal(3);//玩家4发3张牌
			player5 = Poker4.deal(3);//玩家5发3张牌
			player6 = Poker4.deal(3);//玩家6发3张牌
			
			//此时，player1叫牌，需要从牌堆派1张牌
			int [] player1NewCard = Poker4.deal(1);
		}
	}

## 2 使用包管理代码

上述代码中，在第一行我们声明了`package chapter06.main;`,表示类是在`classpath`目录下的`chapter06.main`包中。在操作系统中，相当于当前`chapter06/main`的目录结构。并支持更多层级的包结构。例如：`com.lanqiao.chapter06.main`。

Java中包的概念就和操作系统中文件夹的概念一样，我们会把硬盘上的文件，放在不同的文件夹中，通过文件路径，可以精确的获取到唯一一个文件。同样我们可以用包名+类名来确定唯一的类。

**包的导入**

使用包可以将功能相似的若干类保存在一个文件目录之中，但是这样一来就有可能出现包之间的互相访问的问题，当一个程序需要其他包中类的时候可以通过`import`关键字完成导入操作，我们之前经常使用的`Scanner`类就是通过`import java.util.Scanner`来导入使用的。**相同包内的类无需相互导入**

当我们需要导入一个包的的多个类是，可以通过`包路径.*`的方式导入当前包的所有类。

`java.lang`是Java默认运行时载入的包，不需要import就可以使用其中的类，例如我们常用的`System`类。

## 3 牌堆的问题

不知道大家有没有发现这段程序的问题。

![](/public/img/Java8/poker_problem.png)

问题就在于，成立多个牌局时，我们操作的都是同一个数据成员。如果沿用当下的方法，我们就不得不做多个和`Poker4`同样的类。显然这样会很笨拙。

也就是说，我们希望每一个牌局都可以拥有自己的一副牌，然后根据这副牌进行发牌动作。

## 4 static关键字的解释

到目前位置，我们所声明的方法和成员变量都有`static`修饰。`static`所修饰的方法叫做**静态方法**，修饰的成员变量叫做**静态变量**。

在一个类内部，静态方法只能访问静态成员变量。

	package chapter06;

	public class StaticDemo {
		
		private static int NUMSTATIC = 0;
	
		private int num;
	
		public void sum() {
			NUMSTATIC++;	//非静态的方法可以访问静态成员
			num++;			//可以访问非静态的成员
			sumStatic();	//可以访问静态的方法
		}
	
		public static void sumStatic() {
			NUMSTATIC++;	//可以访问静态成员变量
			num++;			//错误！不可以访问非静态的成员
			sum();			//错误！不可以调用非静态的方法
			sumStatic2();	//可以调用静态方法
		}
	
		public static void sumStatic2() {
	
		}
	}

可以看到，静态的方法是比较**矫情**的，它不能够去引用非`static`修饰的方法和变量。这是因为静态方法和静态成员变量**初始化空间的**比较早。就像你不能在早餐还没做出来之前吃到早餐一样。

*关于静态成员空间分配请参考[http://developer.51cto.com/art/201009/225071.htm](http://developer.51cto.com/art/201009/225071.htm)

## 5 类和对象的关系

静态的方法和成员变量是被`类`直接调用的，那么非静态的成员和方法是被`对象`所调用的。那么究竟类和对象是什么关系呢?

广义的讲，具有相同性质的事物的集合就叫做类。在我们编程时，类(class)往往是可以有实际抽象意义的。

	public class Student{
		
		//姓名成员变量
		private String name;
		
		//年龄成员变量
		private int age;

		/**
		 * 自我介绍方法
		 */
		public void introduce(){
			System.out.println("我叫"+name+",今年"+age+"岁");
		}
	}

`Student`就是学生的类定义，抽象了学生所拥有的一些属性（成员变量）和行为（方法）。类是一个抽象概念。比如汽车本身一个抽象描述，而`法拉利恩佐`就是一个汽车类的一个实例，也可以叫做一个对象。正如上例，学生是一个类（class）,而一名叫张三学生就时一个`Student`的实例（对象）。

## 6 类到对象的桥梁——构造方法

类的方法中有一个比较特别的方法，没有声明返回值，且名称与类名相同，它就是**构造方法**。

	public Student(){
		//Student类的构造方法	
	}

构造方法是由类创建对象的桥梁，我们可以通过构造方法创建一个类的实例（对象），通过构造方法得到的变量称作对象的引用。

	introduce //创建一个Student类型的实例对象，引用为zhangsan

如果不显示声明，类会默认拥有一个无参的构造方法，也就是说，如果我们不在类中声明任何构造方法，我们同样可以使用`new 类名()`来构造对象，构造方法同样支持重载。

	/**
	 * 拥有两个参数的构造方法重载
	 */
	public Student(String name,int age){
		this.name = name;
		this.age = age;
	}

一旦我们显示的声明了任何构造方法重载，则默认无参构造方法就不复存在了。声明了上述构造方法后，如果不在显示声明无参的构造方法，就不能使用`new Student();`来创建对象。而需要遵循当前拥有的构造方法构建`new Student("张三",21);`。

## 7 关于this关键字

在上面构造方法中，我们使用了`this`关键字，`this`在类中是一个**泛指的代号**,它代表的就是**当前对象**。如`Student zhangsan = new Student("张三",21);`,此时构造方法中的`this`代表的就是`zhangsan`这个对象。就好比“每周值日的同学负责把黑板擦了"，那么"每周值日的同学"就是一个代号，如果轮到张三值日，那么擦黑板的同学就是他。
	
`this.name = name;`中`this.name`是当前对象的`name`属性，即`private String name;`的值，要赋的值是参数中的name变量。此句为把构造方法传入的参数name,赋值给当前对象。
	
	Student zhangsan = new Student("zhangsan",21);
	zhangsan.introduce();//调用对象的自我介绍方法

运行结果

	我叫张三，今年21岁

new + 构造方法就完成了对象的创建过程。实际上就时完成了内存空间的开辟。**每一个对象拥有自己的独立内存空间**，且相互不影响。

## 8 再谈静态变量

首先要明确`static`声明的成员变量是属于`类`，被所有对象所共享。而非static的成员，各自拥有各自的成员变量。

	package chapter06;
	
	public class StaticVar {
	
		private static int NUMSTATIC=0;
		
		private int num=0;
		
		public void add(){
			num++;
			System.out.println("当前成员变量num为" + num);
		}
		
		public static void addStatic(){
			NUMSTATIC++;
			System.out.println("当前静态变量NUMSTATIC为" + NUMSTATIC);
		}
		
		public static void main(String[] args) {
			StaticVar test = new StaticVar();
			test.add();
			test.add();
			StaticVar test1 = new StaticVar();
			test1.add();
			StaticVar.addStatic();
			test1.addStatic();
			test2.addStatic();
		}
	}
运行结果

	当前成员变量num为1
	当前成员变量num为2
	当前成员变量num为1
	当前静态变量NUMSTATIC为1
	当前静态变量NUMSTATIC为2
	当前静态变量NUMSTATIC为3

main方法中，我们创建了两个`StaticVar`对象`test`和`test1`，各自的`num`变量不会受其他对象影响，而无论如何调用`addStatic()`，`NUMSTATIC`变量都是共享的。

![](http://static)

## 9 解决牌堆共享问题

	package chapter06;

	public class Poker5 {
		
		//牌堆此时为成员变量，在类内部，每个方法都共享此变量
		private int[] cards;
		
		public void init(){
			//省略代码
		}
		
		public int[] deal(int count){
			//省略代码
		}
		public static void main(String[] args) {
		
			//构建牌局对象game1
			Poker5 game1 = new Poker5();
			
			int[] player1;// 玩家1加入游戏
			int[] player2;// 玩家2加入游戏
			int[] player3;// 玩家3加入游戏
			// 初始化game1牌堆,准备为玩家1，2，3发牌
			game1.init();
			player1 = game1.deal(3);// 玩家1发3张牌
			player2 = game1.deal(3);// 玩家2发3张牌
			player3 = game1.deal(3);// 玩家3发3张牌
	
			int[] player4;// 玩家4加入游戏
			int[] player5;// 玩家5加入游戏
			int[] player6;// 玩家6加入游戏
	
			//新建牌局对象game2
			Poker5 game2 = new Poker5();
			// 初始化game2牌堆,准备为玩家4，5，6发牌
			game2.init();
	
			player4 = game2.deal(3);// 玩家4发3张牌
			player5 = game2.deal(3);// 玩家5发3张牌
			player6 = game2.deal(3);// 玩家6发3张牌
	
			// 此时，player1叫牌，需要从game1牌堆派1张牌
			int[] player1NewCard = game1.deal(1);
		}
	}


# 实验二 利用面向对象思想设计游戏人物

## 简单的属性和行为

> 设计一个游戏人物，人物拥有血量值，魔法值属性。并可以发起攻击和移动。

## 关键代码

	package chapter07;

	public class Character {
	
		private int hp;
	
		private int mp;
	
		public void attack() {
			System.out.println("发起攻击");
		}
	
		public void move() {
			System.out.println("人物移动");
		}
	}

## 解读

一个类封装的基本要素就是**成员变量**和**方法**。面向对象的程序设计思想是更趋与我们人类来理解的程序描述方式。一个类的描述意义就是一类事物所拥有的**属性(成员变量)**和**行为(方法)**。

# 实验三 将游戏人物划分三个职业

> 为了保证游戏的多样性，人物会被分为三个职业：战士，法师，刺客。都拥有血量值，魔法值，力量，敏捷，智力属性，攻击和移动行为。并且战士拥有重击特性技能，法师拥有地狱火特性技能，刺客拥有背刺特性技能。

## 1 关键问题

1. 三个职业拥有部分相同的属性和行为。
2. 但是还各自拥有自己的特性

如果我们分别编写三个类（战士，法师，刺客）的话，会有很多相同的代码声明。

## 2 利用继承解决重复的声明

### 基本属性描述类

	public class Character {
		
		//血量值
		protected int hp;
	
		//魔法值
		protected int mp;
		
		//力量
		protected int power;
		
		//敏捷
		protected int agility;
		
		//智力
		protected int mentality;
	
		public void attack() {
			System.out.println("发起攻击");
		}
	
		public void move() {
			System.out.println("人物移动");
		}

		//打印自身属性
		public void info(){
			System.out.println("当前属性 [hp=" + hp + ", mp=" + mp + ", power=" + power + ", agility=" + agility + ", mentality="
					+ mentality + "]");
		}
	}

### 3 战士类

	public class Warrior extends Character{
	
		/**
		 * 重击
		 */
		public void thump(){
			System.out.println("战士使用重击，造成眩晕");
		}
	}

### 4 法师类

	public class Magician extends Character{
	
		/**
		 * 地狱火技能
		 */
		public void hellFire(){
			System.out.println("法师使用地狱火技能，造成大面积伤害");
		}
	}

### 5 刺客类

	public class Stabber extends Character{
	
		/**
		 * 背刺技能
		 */
		public void backstab(){
			System.out.println("刺客发动背刺，打出双倍伤害");
		}
	}

## 6 extends关键字

`extends`用于表示两个类的继承关系，类继承和我们现实生活中继承关系有几分相似，`A extends B`,表示A类继承B类，A拥有B类**所暴漏给子类**的属性和方法。

战士类`Warrior`继承了`Character`,自然就拥有了父类所暴漏给它的属性（hp,mp等）。

那么究竟哪些是父类暴漏给子类的属性和方法呢？这就取决与访问限制修饰符的使用。


## 7 访问控制符总结
之前我们使用`private`来修饰成员变量，保证成员变量在类外部不能被访问，`public`修饰方法使得方法可以在其他类可以调用方法。

Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java支持4种不同的访问权限。

默认的，也称为 default，在同一包内可见，不使用任何修饰符。

私有的，以 private 修饰符指定，在同一类内可见。

公有的，以 public 修饰符指定，对所有类可见。

受保护的，以 protected 修饰符指定，对同一包内的类和所有子类可见。

![](https://coding.net/u/lanqiao/p/lanqiao/git/raw/coding-pages/public/img/Java8/visit.png)

`Character`选择使用`protected`修饰成员变量，这样子类中就可以直接访问这几个变量。

## 8 利用构造方法初始化各职业基本属性

每个职业对象诞生开始拥有不同的基础属性，在我们构建对象时，就要做好这些设定。

	/**
	 * Character类构造方法
	 * 5属性设置参数的构造方法
	 */
	public Character(int hp, int mp, int power, int agility, int mentality) {
		this.hp = hp;
		this.mp = mp;
		this.power = power;
		this.agility = agility;
		this.mentality = mentality;
	}

我们为父类设置了一个设置5个属性的构造方法。**注意这时默认无参的构造方法已经失效**。

此时所有子类均出现了**编译错误**`Implicit super constructor Character() is undefined for default constructor. Must define an explicit constructor`。

这是因为子类的构造方法调用之前会**默认调用父类无参的构造方法**，就是所谓的"没有父，哪有子"，也就是创建一个对象时，编译器会按照继承关系依次去构建父类对象出来。

更多对象构造细节参考[http://www.cnblogs.com/lmtoo/archive/2012/04/08/2437918.html](http://www.cnblogs.com/lmtoo/archive/2012/04/08/2437918.html)

上述错误就是因为我们重载了`Character`构造方法，默认无参的构造方法就不存在了，那么子类找不到无参的构造方法调用了。

该怎么办呢？既然编译器想做的就是去构造父类对象，且找不到方法，那么我们要么给它一个无参的构造方法，要么显示的调用一下构造父类对象。

提供无参的构造方法对我们来讲比较简单，却在这个场景下没有什么意义。所以我们使用在子类构造方法中显示调用父类构造方法。

	/**
	 * 战士类构造方法
	 */
	public Warrior() {
		//因为父类Character没有默认无参的构造方法，需要子类在构造期间显示调用父类构造方法
		super(600, 100, 15, 5, 3);//设置战士基础属性
	}
	//其他三个类构造方法类似...

利用super关键字，我们可以调用父类的构造方法`super()`，也可以访问父类的成员变量和方法，`super.hp`。在访问成员和方法时，要注意访问控制修饰符。

	public static void main(String[] args) {
		Warrior warrior = new Warrior();
		warrior.attack();
		warrior.info();
	}

运行结果

	发起攻击
	属性 [hp=600, mp=100, power=15, agility=5, mentality=3]

# 实验四 不同的攻击算法

> 每个职业的攻击attack()方法都是根据自身的专精属性输出伤害，战士专精力量，法师专精智力，刺客专精敏捷。

## 方法重写

现有的攻击方法`attack()`都是继承自`Character`类，且已拥有自己的默认实现。这时我们希望每个子类在这个方法上体现出自己的特性，就可以利用方法重写。
	
	//战士类中重写attack方法
	@Override	//重写注解，给编译器指示校验，如果标有该注解方法父类并不存在此方法，则报出编译错误
	public void attack() {
		double harm = power*1.2;	//伤害为力量的1.2倍
		System.out.println("战士发动攻击，造成" +harm+"点伤害");
	}

方法重写发生在父类与子类中，子类可以出现和父类相同名称且参数列相同的方法，叫做子类重写父类的方法。

	Warrior warrior = new Warrior();
	warrior.attack();

运行结果

	战士发动攻击，造成18.0点伤害

## 多态的体现——重写与重载

很多数据都会说面向对象的三大特点，封装、继承、多态。封装和继承在前面章节我们都有介绍。现在我们来了解一下多态。

多态：事物的多种形态，也就是说，一个对象可以表现出多种形态。具体的体现就是**重写**与**重载**。

- 重载(Overloading)：就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。

- 重写(Overriding):子类和父类拥有相同方法的声明（名称和参数列表）,当用**父类引用指向子类对象**时，可以根据实际的子类对象体现不同的形态。
- 
		//父类Character引用，指向了new Warrior();得到的子类对象
		Character character = new Warrior();
		character.attack();//调用attack方法

运行结果

	战士发动攻击，造成18.0点伤害

如果父类引用`Character character`指向其他子类对象（Magician或Stabber）,体现的也都是各自的attack方法实现(如果有重写)。

# 实验五 利用多态完善攻击方法

> 攻击方法接受一个被攻击对象，每个被攻击对象有一个抵抗方法，根据抵抗方法减免的伤害得出最后的伤害输出。

## 关键代码

	//Character类中重载attack方法，接收一个被攻击对象
	public void attack(Character character){
		System.out.println("有攻击对象的攻击实现");
	}

	//Character中声明抵抗方法，需要在每个具体职业中实现具体抵抗算法
	public float resist(){
		System.out.println("每个职业主属性*抵抗系数");
		return 0;//返回所抵抗的攻击数
	}

战士重写

	@Override
	public void attack(Character character) {
		float excuse = character.resist();//调用被攻击者的抵抗方法，算出抵抗值
		double harm = power*1.2;//计算战士攻击力伤害值
		character.hp = (int) (character.hp-(harm-excuse));//减掉相应血量
		System.out.println("战士发起攻击，造成" + (harm-excuse) +"点伤害");
	}
	
	@Override
	public float resist() {
		return this.power*0.7f;//战士抵抗值为力量*0.7
	}

刺客重写

	@Override
	public void attack(Character character) {
		float excuse = character.resist();//调用被攻击者的抵抗方法，算出抵抗值
		double harm = agility*1.5;//计算刺客攻击力伤害值
		character.hp = (int) (character.hp-(harm-excuse));//减掉相应血量
		System.out.println("刺客发起攻击，造成" + (harm-excuse) +"点伤害");
	}
	
	@Override
	public float resist() {
		return this.agility*0.5f;//刺客为敏捷*0.5
	}

测试代码

	Warrior warrior = new Warrior();//战士对象1
	Warrior warrior2 = new Warrior();//战士对象2
	
	warrior.attack(warrior2);//战士1攻击战士2
	warrior2.info();//输出被攻击战士2的当前属性值
	
	Stabber stabber = new Stabber();
	warrior.attack(stabber);
	stabber.info();

运行结果

	战士发起攻击，造成7.5点伤害
	属性 [hp=592, mp=100, power=15, agility=5, mentality=3]
	战士发起攻击，造成11.5点伤害
	属性 [hp=438, mp=150, power=7, agility=13, mentality=5]

## 解读

我们看到，同一个对象，针对不同职业对象发起攻击，所输出的伤害是不同的，这是因为每一个职业的`resist()`实现不同，抵抗的攻击伤害也不同，这就是`attack(Character character)`方法中，父类引用`character`在传递形参时，指向的是不同实现的子类对象，而表现出了不同的抵抗方法，是多态的一种体现。

# 实验六 利用抽象类去除无意义的方法实现

> character类中的attack方法实现是没有什么实际意义的，在每个子类中都必然会重写其实现。如何处理这些无意义的实现呢？

## abstract关键字

`abstract`关键字用于修饰类和方法，修饰的类叫做**抽象类**，修饰的方法叫做**抽象方法**。

抽象方法

`abstract`修饰的方法，不需要有方法体，仅需要有声明就可以。

	public void attack(Character character);

抽象类

抽象类中可以存在抽象方法，也就是说，只有声明为`abstract`的类中，才能使用`abstract`修饰方法。

## 定义Character为抽象类

	package chapter07;

	public abstract class Character {
	
		protected int hp;
	
		protected int mp;
		
		protected int power;
		
		protected int agility;
		
		protected int mentality;
		
		
		/**
		 * Character类构造方法
		 * 5属性设置参数的构造方法
		 */
		public Character(int hp, int mp, int power, int agility, int mentality) {
			this.hp = hp;
			this.mp = mp;
			this.power = power;
			this.agility = agility;
			this.mentality = mentality;
		}
	
		public abstract void attack();//抽象方法，无需方法实现
		
		public abstract void attack(Character character);//抽象方法，无需方法实现
		
		public abstract float resist();//抽象方法，无需方法实现
	
		public void move() {
			System.out.println("人物移动");
		}
		
		public void info(){
			System.out.println("属性 [hp=" + hp + ", mp=" + mp + ", power=" + power + ", agility=" + agility + ", mentality="
					+ mentality + "]");
		}
	
	}

**注意：父类`Character`存在抽象方法，其子类如果不是抽象类，则必须对父类抽象方法进行实现。所以子类`Warrior`、`Magician`或`Stabber`中必须给出这几个抽象方法的实现。**

## 接口与抽象类

如果说抽象类是一个比较抽象的类（因为有些方法只是声明层面的）的话，那么接口就是一个纯抽象的产物，也就说接口中所有的方法都是抽象的，都不可以有方法实现。定一个接口的形式如下：

	public interface InterfaceName {
	 
	}

接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为`public static final`变量（并且只能是`public static final`变量，用`private`修饰会报编译错误），而方法会被隐式地指定为`public abstract`方法且只能是`public abstract`方法（用其他关键字，比如`private`、`protected`、`static`、 `final`等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。

## 抽象类与接口的区别

1.语法层面上的区别

　　1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；

　　2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；

　　3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；

　　4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。

2.设计层面上的区别

　　1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类`Airplane`，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将飞行 设计为一个接口Fly，包含方法`fly()`，然后`Airplane`和`Bird`分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承`Airplane`即可，对于鸟也是类似的，不同种类的鸟直接继承`Bird`类即可。从这里可以看出，继承是一个 "是不是"的关系，而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。

　　2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。

下面看一个网上流传最广泛的例子：门和警报的例子：门都有`open()`和`close(`)两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：

	abstract class Door {
	    public abstract void open();
	    public abstract void close();
	}

　或者：

	interface Door {
	    public abstract void open();
	    public abstract void close();
	}

但是现在如果我们需要门具有报警`alarm()`的功能，那么该如何实现？下面提供两种思路：

　　1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；

　　2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的`open()`和`close()`，也许这个类根本就不具备`open()`和`close()`这两个功能，比如火灾报警器。

　　从这里可以看出， `Door`的`open()` 、`close()`和`alarm()`根本就属于两个不同范畴内的行为，`open()`和`close()`属于门本身固有的行为特性，而`alarm()`属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含`alarm()`行为,`Door`设计为单独的一个抽象类，包含`open`和`close`两种行为。再设计一个报警门继承`Door`类和实现`Alarm`接口。

	interface Alram {
	    void alarm();
	}
	 
	abstract class Door {
	    void open();
	    void close();
	}
	 
	class AlarmDoor extends Door implements Alarm {
	    void oepn() {
	      //....
	    }
	    void close() {
	      //....
	    }
	    void alarm() {
	      //....
	    }
	}

# 实战练习

1、猜数字游戏：一个类A有一个成员变量v，有一个初值100。定义一个类，对A类的成员变量v进行猜。如果大了则提示大了，小了则提示小了。等于则提示猜测成功。

2、请定义一个交通工具(Vehicle)的类，其中有: 属性：速度`speed`，体积`size`等等 
方法：移动`move()`，设置速度`setSpeed(int speed)`，加速`speedUp()`,减速`speedDown()`等等. 

最后在测试类Vehicle中的`main()`中实例化一个交通工具对象，并通过方法给它初始化`speed`,`size`的值，并且通过打印出来。另外，调用加速，减速的方法对速度进行改变。 

3、在程序中，经常要对时间进行操作，但是并没有时间类型的数据。那么，我们可以自己实现一个时间类，来满足程序中的需要。 

定义名为MyTime的类，其中应有三个整型成员：时（`hour`），分（`minute`），秒（`second`），为了保证数据的安全性，这三个成员变量应声明为私有。 为MyTime类定义构造方法，以方便创建对象时初始化成员变量。 再定义`diaplay`方法，用于将时间信息打印出来。 

为MyTime类添加以下方法： `addSecond(int sec)` `addMinute(int min)` `addHour(int hou)` `subSecond(int sec)` `subMinute(int min)` `subHour(int hou) `
分别对时、分、秒进行加减运算。