---
layout: post
title: 朝夕相处——最常见的Java类
category: 初学者的第一套Java教程
tags: Java 入门
keywords: 蓝桥 lanqiao 教程 java Java8 OOP String Object 引用数据类型
description: String类型
author: 付天有
importance: 2
order: 8
---

# 实验一 自定义字符串类

> 目的：String这个类型我们在之前或多或少已经接触过了，我们就利用面向对象的方法，设计一个我们自己的String类型（MyString）。

## 前言

首先回顾一下数据类型，Java语言为我们提供了**8种基础数据类型**，除了这8种和数组以外，我们使用的所有数据类型都是JDK为我们提供的类型，也就是说，曾经有一位程序员，利用面向对象的设计方法，设计了我们使用的String类。当然，我们也可以这样做。

## 设计思路

### 明确目的

首先我们要明确我们要做什么。一个字符串类，字符串，顾名思义，是由多个字符连成的一个串。我们希望抽象一个类，可以存储这一系列字符（属性），并加上一些常见的字符串操作（行为）。

### 抽象

本质上字符串还是一个一个的字符构成的。这些字符是我们关注的内容，而且它的行为大都针对这些字符而发生的。

#### 属性（成员变量）

**字符串内容(content)**:既然是一些列的字符串，我们当然想到的就是用数组来描述，一个字符类型的数组（char[]）。

#### 行为（成员方法）

**连接字符串**:将指定字符串连接到此字符串的结尾。

**替换字符**:返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 

**判断包含字符**:当且仅当此字符串包含指定的 char 值时，返回 true。 

**分割字符串**``:根据给定字符拆分此字符串。 

**获取字符位置**``:返回给定字符在字符串中的位置，默认0位第一位。

**获取字符串的长度**`length()`:返回当前字符串拥有的字符数。

**打印字符串**`print()`:打印当前字符串内容到控制台。

**截取字符串**`substring(int beginIndex)`：返回一个新的字符串，它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。

**截取指定区间字符串**`substring(int beginIndex,int endIndex)`：返回一个新字符串，它是此字符串的一个子字符串。该子字符串从指定的 beginIndex 处开始，直到索引 endIndex - 1 处的字符。因此，该子字符串的长度为 endIndex-beginIndex。 


### 封装

	package chapter08;
	
	/**
	 * 自定义字符串
	 */
	public final class MyString {
		
		//成员变量，用来存储字符串内容,我们不想利用对象引用直接修改此变量,而是通过方法来影响这个值，顾设置为private
		private char[] content;
		
		//无参的构造方法
		public MyString(){
			
		}
		
		//带有初始内容的字符串构造方法
		public MyString(char[] c){
			
		}
		
		//将指定字符串连接到此字符串的结尾。
		public MyString concat(MyString str){
			return null;
		}
		
		//返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 
		public MyString replace(char oldChar,char newChar){
			return null;
		}
		
		//当且仅当此字符串包含指定的 char 值时，返回 true。 
		public boolean contains(char c){
			return false;
		}
		
		//根据给定字符拆分此字符串。 
		public MyString[] split(char c){
			return null;
		}
		
		//返回给定字符在字符串中的位置，默认0位第一位。
		public int indexOf(char c){
			return -1;
		}
		
		//返回当前字符串拥有的字符数。
		public int length(){
			return 0;
		}
		
		//打印当前字符串内容到控制台。
		public void print(){
			
		}
		
		//返回一个新的字符串，它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。
		public MyString subString(int beginIndex){
			return null;
		}
		
		//返回一个新字符串，它是此字符串的一个子字符串。该子字符串从指定的 beginIndex 处开始，直到索引 endIndex - 1 处的字符。因此，该子字符串的长度为 endIndex-beginIndex。 
		public MyString subString(int beginIndex,int endIndex){
			return null;
		}
	}

> final关键字，我们之前使用final关键字修饰过变量，代表这个变量一旦赋值**不能够被修改**，final还可以用来修饰类和方法。final修饰的类**不能够被继承**。final修饰的方法**不能够被重写**

## 实现

### 构造方法

我们重载了两个构造方法。

	//无参的构造方法
	public MyString(){
		content=new char[0];//创建一个长度为0的char[]数组作为默认值。
	}
	
	//带有初始内容的字符串构造方法
	public MyString(char[] c){
		content = c;//直接把传入的参数作为字符串内容
	}

这样我们就可以有两种方式构建MyString实例对象。

	MyString ms = new MyString();
	char[] str = new char[]{'a','b','c'};
	MyString ms1 = new  MyString(str);

### 打印和获取长度

这两个方法相对简单。

	//返回当前字符串拥有的字符数。
	public int length(){
		return this.content.length;
	}
	
	//打印当前字符串内容到控制台。
	public void print(){
		for (int i = 0; i < this.content.length; i++) {
			System.out.print(this.content[i]);//逐个输出字符不换行
		}
		System.out.println();//最后输出一个换行符
	}

### 连接字符串

传入的参数是一个MyString类型str，我们希望把当前对象（this）的content和传入对象（str）的content拼接起来。

	//将指定字符串连接到此字符串的结尾。
	public MyString concat(MyString str){
		//拼接this.content和str.content
		//创建新的char[],长度为两个char数组长度之和
		char[] newChars = new char[this.content.length+str.content.length];
		for (int i = 0; i < newChars.length; i++) {
			//为新的字符数组赋值
			if(i < this.content.length){
				//i小于当前content长度，赋值前半部分当前content内容
				newChars[i] = this.content[i];
			}else{
				//i大于等于当前content长度，赋值后半部分str的content内容
				newChars[i] = str.content[i-this.content.length];
			}
		}
		return new MyString(newChars);
	}

值得注意的是，我们返回了一个新new的MyString类型，所以原字符串内容并没有改变

	MyString str = new MyString(new char[]{'a','b'});
	MyString str2 = new MyString(new char[]{'c','d'});
	MyString str3 = str.concat(str1);//此时str3是"abcd"，但是str依旧是"ab",str2依旧是"cd"

### 替换字符

	//返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 
	public MyString replace(char oldChar,char newChar){
		//既然要返回新的字符串，那么我们不应该改动原字符串的content,故新创建一个字符数组
		char[] newStr = new char[this.content.length];
		//循环遍历每一个字符内容
		for (int i = 0; i < this.content.length; i++) {
			if(this.content[i] == oldChar){
				//找到要替换的字符即修改为newChar
				newStr[i] = newChar;
			}else{
				//复制原字符到新字符串数组
				newStr[i] = this.content[i];
			}
		}
		//返回一个新的MyString实例
		return new MyString(newStr);
	}

### 判断包含字符

	//当且仅当此字符串包含指定的 char 值时，返回 true。 
	public boolean contains(char c){
		for (int i = 0; i < this.content.length; i++) {
			if(this.content[i]==c){
				//如果找到匹配字符，则return true，此时循环终止，方法结束。
				return true;
			}
		}
		//循环完毕，没有找到，返回false
		return false;
	}

return关键字会让方法终止，故循环也会终止，并返回指定返回值。

### 截取字符串

	//返回一个新的字符串，它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。
	public MyString subString(int beginIndex){
		char[] newStr = new char[this.content.length-beginIndex];
		int count = 0;
		for (int i = beginIndex; i < this.content.length; i++) {
			newStr[count]=this.content[i];
			count++;
		}
		return new MyString(newStr);
	}
	
	//返回一个新字符串，它是此字符串的一个子字符串。该子字符串从指定的 beginIndex 处开始，直到索引 endIndex - 1 处的字符。因此，该子字符串的长度为 endIndex-beginIndex。 
	public MyString subString(int beginIndex,int endIndex){
		char[] newStr = new char[endIndex-beginIndex];
		int index = 0;
		for (int i = beginIndex; i < endIndex; i++) {
			newStr[index] = this.content[i];
			index++;
		}
		return new MyString(newStr);
	}

这两个方法有很大程度的相似度，或者说`subString(int beginIndex,int endIndex)`方法可以实现`subString(int beginIndex)`方法，

	MyString str = new MyString(new char[]{'a','b','c'});
	str.subString(1);
	str.subString(1,str.length());//从第二位截取到末尾，等同于上面所调用的方法。

所以我们`subString(int beginIndex)`方法可以**重复利用**其他方法

	public MyString subString(int beginIndex){
		//调用subString(int beginIndex,int endIndex)方法
		return this.subString(beginIndex,this.length());//利用已完成的length()方法获取长度
	}

这样做不但节省的代码，更加利于维护，如果我们现在要求更改index是从1开始的，我们只需要更改一处代码即可，大大的增加的代码的可维护性。

### 分割字符串

	//根据给定字符拆分此字符串。 
	public MyString[] split(char c){
		//要知道最终会被分为几个字符串，先要知道字符出现了几次
		int appears = 0;
		for (int i = 0; i < this.content.length; i++) {
			if(this.content[i] == c){
				appears++;
			}
		}
		if(appears>0){
			//如果出现超过一次，创建结果数组，并依次截取字符串赋值给结果数组
			MyString[] result = new MyString[appears+1];//出现n此分隔符，则截取结果为n+1,如aaa.bbb.ccc按.截取结果为aaa,bbb,ccc三个字符串
			int loc=0;//已经截取部分的末位
			int count=0;//已截取次数，截取的次数和截取符出现的次数相同，可以想象为切蛋糕，两刀切成三块
			for (int i = 0; i < this.content.length; i++) {
				if(this.content[i] == c){
					//找到截取符,开始截取
					result[count] = this.subString(loc, i);
					count++;//截取次数+1
					loc = i;//记录已经截取到的位置
					if(count == appears){
						//如果已经截取到最后一个出现的截取符，直接截取到末位
						result[count]=this.subString(loc+1);
						break;
					}
				}
			}
			return result;
		}
		//如果一次都没有出现，则直接返回原字符串，当然也可以返回null,规则我们自己说的算。
		MyString[] myString = new MyString[1];
		myString[0] = this;
		
		return myString;
	}

## 探究

至此我们完成了一个自己定义的String类型，当然这些功能也都是`java.lang`包中的String已经提供的方法，并且还有更多的方法等待大家去探索，我们可以参照API文档和源码来研究一下使用方法和具体实现。

### 引用数据类型和基础数据类型

首先String是一个引用数据类型，也可以说除了8种基础数据类型以外，其他都是引用数据类型，那么引用数据类型和基础数据类型究竟有什么区别呢？我们先看一个例子。
	
	package chapter08;
	
	import java.util.Arrays;
	
	public class TypeDemo {
	
		/**
		 * 对传入的数组进行排序
		 */
		public void sort(int[] arr){
			//利用冒泡排序法，对数组进行排序，这里都是对原数组进行操作
			int temp;
			for (int i = 0; i < arr.length-1; i++) {			
				for (int j = 0; j < arr.length-i-1 ; j++) {	
					if (arr[j] > arr[j+1]) {			
						temp = arr[j];
						arr[j] = arr[j+1];
						arr[j+1] = temp;
					}
				}
			}
		}
	
		/**
		 * 传入一个数字，并赋值这个数字为该数的平方
		 */
		public void square(int num){
			num = num*num;
		}
		
		public static void main(String[] args) {
			TypeDemo demo = new TypeDemo();
			int[] a = {11,33,12,9,7,1,6,10};
			demo.sort(a);
			System.out.println(Arrays.toString(a));
			
			int n = 10;
			demo.square(n);
			System.out.println(n);
		}
		
	}

运行结果
	
	[1, 6, 7, 9, 10, 11, 12, 33]
	10

首先，数组是引用数据类型，int是基础数据类型。

当数组作为参数传入方法时，方法体内操作的就是数组本身，而基础数据类型int作为参数传入方法时，却并没有操作数据本身。这又是为什么呢？

这里我们有必要先了解一下Java的内存模型

### Java的内存模型

程序的本质就是对内存中数据的存取和计算，而Jvm把内存管理已经做的很好，我们编程时也不需要关心内存中是如何操作的，但是，了解内存模型可以使我们更清晰的理解程序的本质。

堆和栈是Jvm在内存中划分的不同功能的区域。引用数据类型和基础数据类型的本质区别也就是对内存的使用和分配方式不同。参考下图

![](http://lemon.lanqiao.org:8082/teaching/img/Java8/memory.png)

狭义的讲`new`关键字就会开辟堆空间内存。也就是说任何引用数据类型都必须通过new来构建对象实例。但是需要注意如下几个特例，这些特例都是在编译器内部有有一些"特权"。

	String str = "abc";//String是引用数据类型，
	Integer i = 123;
	Float f = 123f;
	Byte  b = 12;
	Short s = 10;
	Long l = 199923l;
	Double d = 123.1d;
	Boolean bb = false;
	Character = 'aaa';

除了String类型，剩下的8个是8种基础数据类型的包装类。这8中类型可以与基础数据类型互相自动转型运算

	Integer i = 100; //注意：不是 int i = 100; 自动装箱

实际上，执行上面那句代码的时候，系统为我们执行了：Integer i = Integer.valueOf(100); 

	int t = i; //自动拆箱，实际上执行了 int t = i.intValue();

### 常量池

常量池也是Java内存管理中一个重要部分。广义上它存放的就是Java中出现的以文本或符号形式存在的引用。例如各种字面常量（1，'b',"aaa",123.1f,true等等），字段名，方法名，类全路径名。并且**常量池中不会有相同的值存在的**。

当然会对我们编程造成影响的部分就是字面常量（字面值）在常量池中的管理。理解以下程序

	package chapter08;
	
	public class ConstantPool {
	
		public static void main(String[] args) {
			String s1 = new String("aaa");//s1指向堆内存创建的新空间
			String s2 = new String("aaa");//s2指向堆内存创建的新空间
			String s3 = "aaa";//查找常量池是否有"aaa"如果有s3指向，没有创建
			String s4 = "aaa";//查找常量池是否有"aaa"如果有s4指向，没有创建
			System.out.println(s1 == s2);//false,s1和s2的中引用的地址是不同的空间
			System.out.println(s3 == s4);//true,s1和s2引用的同时常量池的相同数据空间
			System.out.println(s1 == s3);//false,s1指向堆空间，s3指向常量池
		}
	}

![](http://lemon.lanqiao.org:8082/teaching/img/Java8/String.png)

### ==与equals

`==`比较的是引用的值（本质上是引用所指堆空间的地址）
`equals`来自Object（所有引用类型的祖先），Object的默认实现也是比较两个引用值。但是String**重写**了equals方法，所以以上s1,s2,s3,s3互相equals都是成立的，以下是String对equals的重写。

	public boolean equals(Object anObject) {
        if (this == anObject) {
			//如果比较对象指向地址相同，则无需比较，字符串一定相同
            return true;
        }
        if (anObject instanceof String) {
			//由于Object抽象的定义equals的形参为Object类型，首先要保证传入的是一个String,否则没有比较意义，一定返回false
            String anotherString = (String)anObject;//如果类型为String,强制向下转型为String。这样才可以暴漏出String所特有的属性和方法。
            int n = value.length;
            if (n == anotherString.value.length) {
				//长度相同逐一比较String中char[]的每一个字符。如果遇到不同则返回false
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }


### instanceOf 运算符

该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。instanceof运算符使用格式如下：

	( Object reference variable ) instanceOf  (class/interface type)

如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。下面是一个例子：

	String name = "James";
	boolean result = name instanceof String; // 由于name是String类型，所以返回真

如果被比较的对象是右侧类型的子类，该运算符仍然返回true。
	
	boolean result = name instanceof Object;//String是Object的子类，所以返回true

## 常见面试题

1、String s = new String("xyz");创建了几个对象，分别在什么地方

2、Java是值传递还是引用传递

3、==与equals的区别

## 实战练习

1、转换控制台输入英文，全部输出为大写字母。

2、判断控制台输入IP地址的有效性。

3、让用户分别输入字符串和子字符串，输出子字符串出现的次数

4、完成用户注册（窗口或控制台均可），用户名长度不能小于6。密码长度不能小于8。两次输入的密码必须一致。

5、参照JDK文档，学习StringBuffer类的使用