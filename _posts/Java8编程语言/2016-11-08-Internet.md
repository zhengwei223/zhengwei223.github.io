---
layout: post
title: Java网络编程
category: 初学者的第一套Java教程
tags: Java 入门
keywords: 蓝桥 lanqiao 教程 java Java8 文件 I/O
description: 网络编程 指的是在多个设备（计算机）执行，其中的设备使用一个网络中的所有连接到对方编写程序。java.net包中包含的类和提供底层通信细节接口的集合，允许编写程序方案，重点解决手头的问题。
author: 付天有
importance: 2
order: 12
---

内容摘要

- 编写Java网络服务程序
- 编写Java网络客户端程序
- 利用Socket实现网络信息传递


# 实验一 实现点对点通信

> 网络在现如今已经不是什么新鲜词了，软件应用也越来越趋向网络化，QQ、微信等互联网应用也是老少皆知。所有网络应用都可以分为**服务端**和**客户端**。无论是服务端还是客户端，都可以理解为一台安装有特定应用程序的计算机。下面我们就利用JDK提供的网络编程API来实现简单的点对点通信功能。

## 1 服务端程序

### 代码

	package chapter12;

	import java.io.IOException;
	import java.io.InputStream;
	import java.io.OutputStream;
	import java.net.ServerSocket;
	import java.net.Socket;
	
	public class Server {
	
		/**
		 * 启动服务器
		 * @throws IOException
		 */
		public static void main(String[] args) throws IOException {
			
			//创建服务器对象，构造方法参数为当前服务端口号
			ServerSocket serverSocket = new ServerSocket(9999);
			//服务器对象的accept()方法会使服务程序处于等待状态，等待客户端的连接
			Socket socket= serverSocket.accept();
			
			//仅当监听到有客户端连接时，如下代码才会执行，socket中包含了客户端发来的消息包，包括发送者IP，端口等等
			System.out.println(socket.getRemoteSocketAddress());//发送者的ip及端口
			
			
			//以字节流的形式来获取具体内容
			OutputStream outputStream = socket.getOutputStream();//发送消息用输出流
			
			InputStream inputStream = socket.getInputStream();//接收信息用输入流
			
			//处理流信息
			
			
			//关闭服务器并释放资源
			serverSocket.close();
		}
		
	}


### 解读

服务端程序的核心类为`java.net.ServerSocket` 该类用于服务器应用程序。用以获取一个端口，侦听客户端请求。

`public ServerSocket(int port) throws IOException`是最为常用的构造方法，向本机申请一个端口，在这个端口上创建服务。

端口：我们知道IP是一台计算机在网络上的地址，那么端口就是计算机上网络服务的窗口，参考一下去银行办理业务，我们有了地址（IP）可以找到一家银行，进入银行后，我们会选择一个窗口（端口）去办理业务。

`ServerSocket serverSocket = new ServerSocket(9999);`一句声明了一个服务对象，并绑定在`9999`端口上，此构造方法有一个I/O异常需要处理，

服务对象准备就绪，执行`serverSocket.accept();`方法让服务开始在9999端口上监听，一旦有客户端连接此机IP及9999端口，就可以通过**流**来进行相互传递信息。

## 2 客户端程序

### 简单代码

	package chapter12;
	
	import java.io.IOException;
	import java.io.OutputStream;
	import java.net.Socket;
	
	public class Client {
	
		public static void main(String[] args) throws IOException {
			//创建一个发送到指定IP和端口的连接信息包，等于是买个信封，贴上邮票，写好地址
			Socket socket = new Socket("127.0.0.1", 9999);//127.0.0.1代表本机IP,服务端程序也可运行在其他同一个网络的设备上
			
			//连接到目标服务，并创建输出流，准备好信纸
			InputStream inputStream = socket.getInputStream();//接收服务端信息用输入流
			
			OutputStream outputStream = socket.getOutputStream();//发送消息到服务端用输出流

			//输出流信息到连接目标服务
		}
	}

客户端的实现非常简单，核心就是`Socket`,没错就是那个`serverSocket.accept();`所得到的信息包，一个`Socket`对象就是服务器端和客户端连接的纽带，两者通过输入输出流来进行通信。

### 梳理重构

	package chapter12;
	
	import java.io.IOException;
	import java.io.OutputStream;
	import java.net.Socket;
	
	public class Client {
		
		//核心就是socket，发送和接受消息都是利用它来获取流信息，顾作为成员变量
		private Socket socket;
		
		/**
		 * 构造方法，根据给定IP和端口初始化Socket对象
		 * @param ip
		 * @param port
		 */
		public Client(String ip,int port){
			//创建一个发送到指定IP和端口的信息包，等于是买个信封，贴上邮票，写好地址
			try {
				socket = new Socket(ip, port);
			} catch (IOException e) {
				System.out.println("创建socket失败");
				e.printStackTrace();
			}
		}
	
		/**
		 * 发送消息到服务器
		 * @param message String类型消息
		 * @throws IOException
		 */
		public void sendServerMsg(String message) throws IOException{
			OutputStream outputStream = socket.getOutputStream();
			//流信息处理
		}

		/**
		 * 获取服务器消息，
		 * @return 获取到的信息
		 * @throws IOException
		 */
		public String receiveServerMsg() throws IOException{
			InputStream inputStream = socket.getInputStream();
			//流处理
		}

		public void close(){
			try {
				socket.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
	}


## 3 关于协议

协议是一系列约定的集合，`ServerSocket`和`Socket`已经把网络中的一些**基础协议**（[TCP协议](http://baike.baidu.com/link?url=0Z6sVBLd-Bt2iPDpGvtH8arYVy-AQ6qkpJouUQ_Sj6LG8re0XrCwfCBRde7B4fibQykqmgDAkjtDsSmh0gTjDXVpVQfHVFL6QcmYqwB8W-TtaBicHe75OBFey3dGnrbA625ng7dqOc8jiEOcnctMvXRP-drDIsdbJB5H06NHDSC)）包装的很好，设备1与设备2如和建立连接、打开信息流通道，并传输到目的，这些地我们**都不需要关心**，上面的代码已经完成这些诸多工作。正如我们找快递公司发一个邮件，我们根本不需要关心邮件是如何运输的(空运、陆运还是漂洋过海)，我们要做的就是整理好包裹中的东西。TCP协议在网络分层模型中属于传输层协议，它负责的就是把包裹(消息)，完整的送达目的地。至于目的地如何处理这些包裹，属于更上层的协议，参考[网络七层协议](http://baike.baidu.com/link?url=E--GjUWDs31SSqigSikyAuevhkFuVhYwp_ohAT5rnxTAxizPqjUrZL0a-KdUgYHNCMx0tLsqEw0mLk53uLi0N4wvJdlwIJsHuYe7tlIxktCRXIiV2IZgE0xmnd_ipFrf5h4tuBLGsK83HrSO3QBnUq)。

一个包裹不远万里到达你的手里，打开你却不知道是什么，怎么办？这时双方可以定义一些更高层的协议，双方可以根据这些约定的更高层协议(应用层：如HTTP,SMTP,FTY等)，如聊天我们打886,大家都能理解是说再见的意思，这类网络用语就可以理解为对于普通汉语的更高层协议，是对基础语义的包装和加工。

前面的代码我们已经建立了两个设备的连接，并得到了输入输出流，如下图

![](/public/img/Java8/internet/connectIO.png)

值得注意的是TCP协议是**面向连接**的，也就是说，在收发数据前，必须和对方建立可靠的连接。也就是说，Socket连接但建立成功，如果非意外断网或一方显示close(),两端的输入输出流通道时刻都是保持连接的。一方write,另一方就可以read到，就像我们打电话一样，但是打电话说话是需要断句的。所以我们在流中需要一个标志和动作，让流的另一端可以知道哪里是一段整体的数据。

至于如何解析流中的信息，就取决于我们如何定义这个约定；假设我们定义流中的信息都是用`\n`即换行来分割每一段信息，这样我们就可以利用BufferedReader中的readline()方法方便的完成读取工作。

## 4 重构服务端代码

	package chapter12;

	import java.io.BufferedReader;
	import java.io.BufferedWriter;
	import java.io.IOException;
	import java.io.InputStream;
	import java.io.InputStreamReader;
	import java.io.OutputStream;
	import java.io.OutputStreamWriter;
	import java.net.ServerSocket;
	import java.net.Socket;
	
	public class ServerPro {
		
		//服务对象成员
		private ServerSocket serverSocket;
		
		//与客户端连接对象成员
		private Socket socket;
		
		
		/**
		 * 构造方法初始化服务对象及端口
		 */
		public ServerPro(int port) {
			//创建服务器对象，构造方法参数为当前服务端口号
			try {
				serverSocket = new ServerSocket(port);
			} catch (IOException e) {
				System.out.println("服务器启动失败");
				e.printStackTrace();
			}
		}
		
		/**
		 * 发送消息到客户端
		 * @param message String类型消息
		 * @throws IOException
		 */
		public void sendClientMsg(String message) throws IOException{
			
			//获取字节输出流，用以向服务端输出信息
			OutputStream outputStream = socket.getOutputStream();
			//包装字节流，使用带有缓冲的字符流
			OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);
			BufferedWriter writer = new BufferedWriter(outputStreamWriter);
			
			//写入字符串消息
			writer.write(message);
			//插入换行符。
			writer.newLine();
			//刷新流
			writer.flush();
		}
		
		/**
		 * 获取客户端消息
		 * @return
		 * @throws IOException
		 */
		public String receiveClientMsg() throws IOException{
			
			//获取输入流
			InputStream inputStream = socket.getInputStream();
			
			//包装流
			InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
			
			BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
			
			//整行读取
			return bufferedReader.readLine();
			
		}
		
		public void start(){
			try {
				socket = serverSocket.accept();
				sendClientMsg("您已成功接入服务器！");
				String message = receiveClientMsg();
				System.out.println(message);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
		public void close(){
			try {
				socket.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	
	}

## 5 客户端发送与接收

	/**
	 * 发送消息到服务器
	 * @param message String类型消息
	 * @throws IOException
	 */
	public void sendServerMsg(String message) throws IOException{
		
		//获取字节输出流，用以向服务端输出信息
		OutputStream outputStream = socket.getOutputStream();
		//包装字节流，使用带有缓冲的字符流
		OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);
		BufferedWriter writer = new BufferedWriter(outputStreamWriter);
		
		//写入字符串消息
		writer.write(message);
		//插入换行符。
		writer.newLine();
		//刷新流
		writer.flush();
	}
	
	/**
	 * 获取服务器消息
	 * @return
	 * @throws IOException
	 */
	public String receiveServerMsg() throws IOException{
		
		InputStream inputStream = socket.getInputStream();
		
		InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
		
		BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
		
		return bufferedReader.readLine();
		
	}

## 6 测试运行

运行Server端

	public static void main(String[] args) {
		ServerPro server = new ServerPro(9999);
		server.start();
	}

运行client端

	public static void main(String[] args) {
		Client client = new Client("127.0.0.1", 9999);
		try {
			String loginMessage = client.receiveServerMsg();
			System.out.println(loginMessage);
			client.sendServerMsg("Hello World");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

client端结果

	您已成功接入服务器！

server端结果

	Hello World

## 总结

至此我们的已经实现服务端与客户端的交互，两个应用程序可以运行在一个网络的不同设备上运行。

核心类就是`ServerSocket`和`Socket`,而通信的纽带就是`Socket`对象，客户端直接`new`一个`Socket`对象，`ServerSocket`则使用`accept()`方法侦听并获取客户端发来的`Socket`，双方利用`Socket`对象的`getXStream`来获得字节输入/输出流，来发送/接收消息。

![](/public/img/Java8/internet/socket-summary.jpg)

### Socket通信的步骤

① 创建`ServerSocket`和`Socket`

② 打开连接到`Socket`的输入/输出流

③ 按照协议对`Socket`进行读/写操作

④ 关闭输入输出流、关闭`Socket`

### 服务端

① 创建`ServerSocket`对象，绑定监听端口

② 通过`accept()`方法监听客户端请求

③ 连接建立后，通过输入流读取客户端发送的请求信息

④ 通过输出流向客户端发送乡音信息

⑤ 关闭相关资源

### 客户端

① 创建`Socket`对象，指明需要连接的服务器的地址和端口号

② 连接建立后，通过输出流想服务器端发送请求信息

③ 通过输入流获取服务器响应的信息

④ 关闭响应资源

## 7 封装重复代码

在上述服务端和客户端代码中，双方在获取信息和发送信息的方法实现是非常相似的。

客户端

	/**
	 * 发送消息到服务器
	 * @param message String类型消息
	 * @throws IOException
	 */
	public void sendServerMsg(String message) throws IOException{
		OutputStream outputStream = socket.getOutputStream();
		//流信息处理
	}

	/**
	 * 获取服务器消息，
	 * @return 获取到的信息
	 * @throws IOException
	 */
	public String receiveServerMsg() throws IOException{
		InputStream inputStream = socket.getInputStream();
		//流处理
	}

服务端

	/**
	 * 发送消息到客户端
	 * @param message String类型消息
	 * @throws IOException
	 */
	public void sendClientMsg(String message) throws IOException{
		
		//获取字节输出流，用以向服务端输出信息
		OutputStream outputStream = socket.getOutputStream();
		//包装字节流，使用带有缓冲的字符流
		OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);
		BufferedWriter writer = new BufferedWriter(outputStreamWriter);
		
		//写入字符串消息
		writer.write(message);
		//插入换行符。
		writer.newLine();
		//刷新流
		writer.flush();
	}
	
	/**
	 * 获取客户端消息
	 * @return
	 * @throws IOException
	 */
	public String receiveClientMsg() throws IOException{
		
		//获取输入流
		InputStream inputStream = socket.getInputStream();
		
		//包装流
		InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
		
		BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
		
		//整行读取
		return bufferedReader.readLine();
		
	}

由于我们双方的协议都是相同的（利用纯文本字符串传输，用换行符`\n`来分割）,所以在接收/发送消息的实现上都是一样的，只不过是操作的socket对象是不同的（都是各自的成员变量），所以我们把这两个方法抽象出一个工具类(SocketUtil.java)

	package chapter12;

	import java.io.BufferedReader;
	import java.io.BufferedWriter;
	import java.io.IOException;
	import java.io.InputStream;
	import java.io.InputStreamReader;
	import java.io.OutputStream;
	import java.io.OutputStreamWriter;
	import java.net.Socket;
	
	/**
	 * Socket工具类
	 * 根据指定协议(纯文本字符串以'\n'分割)解析/发送Socket消息
	 */
	public class SocketUtil {
	
		/**
		 * 向指定Socket发送文本消息，以'\n'作为分割标记
		 * @param socket
		 * @param message
		 * @throws IOException
		 */
		public static void sendMsg(Socket socket,String message) throws IOException{
			
			OutputStream outputStream = socket.getOutputStream();
			
			OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);
			
			BufferedWriter writer = new BufferedWriter(outputStreamWriter);
			
			writer.write(message);
			
			writer.newLine();
			
			writer.flush();
		}
		
		/**
		 * 接受指定Socket发来的消息，
		 * @param socket
		 * @return
		 * @throws IOException
		 */
		public static String receiveMsg(Socket socket) throws IOException{
			
			InputStream inputStream = socket.getInputStream();
			
			InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
			
			BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
			
			return bufferedReader.readLine();
		}
	}
	
工具类中提供了静态方法解析/发送Socket消息，使用方法如下

服务端

	/**
	 * 获取客户端消息
	 * @return
	 * @throws IOException
	 */
	public String receiveClientMsg() throws IOException{
		
		return SocketUtil.receiveMsg(socket);
	}

	/**
	 * 发送消息到客户端
	 * @param message String类型消息
	 * @throws IOException
	 */
	public void sendClientMsg(String message) throws IOException{
		
		SocketUtil.sendMsg(socket, message);
	}


客户端

	/**
	 * 获取客户端消息
	 * @return
	 * @throws IOException
	 */
	public String receiveClientMsg() throws IOException{

		return SocketUtil.receiveMsg(socket);	
	}

	/**
	 * 发送消息到服务器
	 * @param message String类型消息
	 * @throws IOException
	 */
	public void sendServerMsg(String message) throws IOException{

		SocketUtil.sendMsg(socket, message);
	}

	
	