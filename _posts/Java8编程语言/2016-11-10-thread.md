---
layout: post
title: 多线程编程
category: 初学者的第一套Java教程
tags: Java 入门
keywords: 蓝桥 lanqiao 教程 java Java8 多线程
description: 当一件工作足够庞大，我们会分派给多个人去做，公路也会提供多条车道来使得多辆车可以同时通过一个路段，到目前为止我们所些的程序都是由一条线程来完成，Java提供了简单易用的多线程编程方法。多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。
author: 付天有
importance: 2
---

内容摘要

- 多线程的创建与启动
- 线程的同步
- 线程协作

# 实验一 创建多个线程同时工作

> 一个线程的执行能力是有限的，就好像一个人无论在怎么加班加点的工作，也无法独自建起长城，这时候我们就需要多线程协作。下面我们来体验一下多线程编程。

## 1 创建可运行线程类

我们以往编写的程序，`main`方法默认就启用了一条线程。另外新启一个线程需要用到`java.lang.Thread`类，一个**Thread类实例**就代表一个可运行的线程。

### 继承Thread类，重写run方法

直接`new`一个`Thread()`实例并没有什么意义，因为线程并没有要执行的任务，通常我们可以**继承Thread**类，并重写其中`run()`方法来实现一个有具体执行任务的线程类。

	class MyThread extends Thread{
	
		@Override
		public void run() {
			System.out.println("MyThread 的执行任务");
		}
	}


上述代码实现了一个线程类，声明执行任务是打印一句话。通过`new MyThread();`即可得到一个可运行的线程实例。

	//创建可执行线程实例
	Thread myThread = new MyThread();
	

### Thread直接构造，传入Runnable接口实例

`Thread`类提供了一个`Thread(Runnable target);`构造方法，可以不用继承重写`run()`方法而使得线程有执行任务。

	class RunnableTask implements Runnable{

		@Override
		public void run() {
			// TODO Auto-generated method stub
			System.out.println("hello 我还是一条线程");
		}
		
	}
	
利用Runnable实例创建可执行线程

	//创建可执行线程实例
	Runnable task = new RunnableTask();
	Thread myThread = new Thread(task);
	
**利用Runnable接口实例创建线程对象的方法在实际开发过程中比较常用**


## 2 启动一个线程

我们已经定义了一个可执行线程实例，启用一条线程需要调用一个`Thread`实例对象的`start()`方法。线程一旦启动，就会执行线程类中定义的`run()`方法。

	public static void main(String[] args) {
		//主方法会默认一条线程来执行任务

		//创建已定义线程类实例
		MyThread myThread = new MyThread();

		//启动一条线程,start后新启动的线程会执行MyThread类中的run方法
		myThread.start();
		
		//主方法线程执行打印
		System.out.println("我是主线程在执行");
	}	

运行结果

	我是主线程在执行
	MyThread 的执行任务

![](/public/img/Java8/thread/threadDemo.png)

## 3 线程的基本方法使用

为了更加了解线程的使用，我们先掌握如下几个线程的方法，以便理解下面实验。

### public long getId()

返回该线程的标识符。线程 ID 是一个正的 long 数，在创建该线程时生成。线程 ID 是唯一的，并终生不变。线程终止时，该线程 ID 可以被重新使用。 

### public final String getName()

返回该线程的名称。该名称可以通过构造方法`Thread(Runnable target, String name)`来设定，也可以通过`setName(String name)`修改一个线程实例的方法，

### public static Thread currentThread()

返回对当前正在执行的线程对象的引用， 注意是Thread类的静态方法，可以在任意正在执行的线程中调用。

### public static void sleep(long millis)

在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）， 注意是Thread类的静态方法，可以在任意正在执行的线程中调用。


# 实验二 模拟售票系统

> 一场演唱会设置了3个售票网点，一共出售100张票，每次出票前都需要查询指定座位票是否卖出，然后完成交易。

## 1 实现售票网点类

### 关键代码

	package chapter13;

	class TicketSouce implements Runnable {
		
		//总票数
		private int tickets = 10;
	
		//具体任务执行方法
		public void run() {
			//循环执行售票过程
			while (true) {
				// 模拟查票过程，网络上需要耗时，当前休眠1s秒中。
				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				if(tickets>0){
					//输出当前线程名称(票点名称)，以及已出票的座位号。并减少总票数
					System.out.println(Thread.currentThread().getName() + "号窗口卖出" + this.tickets-- + "号票");
				}
			}
		}
	}
	
	public class TicketSale {
		public static void main(String args[]) {
			TicketSouce task = new TicketSouce();
			// 基于火车票创建三个窗口
			new Thread(task, "第一代售点").start();
			new Thread(task, "第二代售点").start();
			new Thread(task, "第三代售点").start();
		}
	}

	
### 解读

上文提到过实现Runnable接口来实现线程类的方式是比较常用的。这是因为，实例化线程对象时，多个线程可以共用一个Runnable对象。

三个线程都使用了`task`对象作为任务执行者，这三个任务执行者又都共享一个成员变量`tickets`,这就使得三个线程都共享了一个票源。而如果使用继承`Thread`类的方法实现，就没有这么容易，且基于`Java`单根继承的特点，类继承的侵入性也比接口更高。所以通常选择实现`Runnable`接口的实例来创建线程对象。

我们再来看一下运行结果(结果较多，摘取部分结果，而且由于线程执行顺序不受代码控制，每次结果可能都不一样)

	第二代售点号窗口卖出100号票
	第一代售点号窗口卖出99号票
	第三代售点号窗口卖出99号票
	第一代售点号窗口卖出98号票
	第二代售点号窗口卖出98号票
	第三代售点号窗口卖出98号票
	...
	
结果就是，不同代售点可能售出相同位置的票。

我们来分以一下原因。

三个线程共用一个任务执行者`task`，三个代售点线程开始时，先后进入`run`方法(顺序不一定，假设为1,2,3顺序)，1号线程查询回100号位置的票，用时1s，在1号线程查询的同时，2号、3号线程也在执行run()方法，并同时查到了99号票，依次类推，就造成了资源的争抢。

## 线程同步锁

上面的问题成因就是由于多个线程访问一个共享的资源，就好像多个人同时使用一个洗手间，势必会出现问题。

解决的办法就是，在资源使用过程中加锁，也就是说，无论在洗手间外如何，当某人进入了洗手间（资源）,便获得钥匙，并关门反锁,其他人只能等待完成整个过程才可进入。

![](/public/img/Java8/thread/threadSafty.png)

同步的意思就是，让多个线程在一个点上排上队，逐个通过。我们通常说某个方法是同步的，或者线程安全的，

### 同步代码块

	//同步代码快
	synchronized(锁对象){
		//过程
	}

锁对象（API常翻译做监视器）理论上是任意的对象，常用`""`空字符串常量。锁对象就像一把钥匙，进入同步代码块后，就得到了这把钥匙，过程结束，归还钥匙。

### 同步方法

`synchronized`可以修饰方法,方法体本身也是个一个过程，synchronized的方法，整个过程都是同步的(同时只能被一个线程访问)。

## 同步查票出票过程

	// 具体任务执行方法
	public void run() {
		// 循环执行售票过程
		while (true) {
			// 模拟查票过程，网络上需要耗时，当前休眠1s秒中。
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			//同步查票出票过程
			synchronized ("") {
				if (tickets > 0) {
					// 输出当前线程名称(票点名称)，以及已出票的座位号。并减少总票数
					System.out.println(Thread.currentThread().getName() + "号窗口卖出" + this.tickets-- + "号票");
				}
			}
		}
	}

运行结果

	第二代售点号窗口卖出100号票
	第一代售点号窗口卖出99号票
	第三代售点号窗口卖出98号票
	第二代售点号窗口卖出97号票
	第一代售点号窗口卖出96号票
	第三代售点号窗口卖出95号票
	第一代售点号窗口卖出94号票
	第二代售点号窗口卖出93号票

# 实验三 包子与吃货

> 包子铺来了5个吃货，每人1秒钟能吃一个包子，包子一笼12个，每5分钟出做一个，吃货吃完就要等待师傅再做一笼。利用线程模拟此过程。

## 1 分析问题

做包子和吃包子为两个独立过程，过程行为不同，但是操作相同资源，都是包子。那么抽象两个线程类。由于涉及相同资源，所以需要线程同步。要点如下

1. 两个线程类，分别执行吃包子和做包子过程
2. 包子容器两者共享
3. 吃包子和做包子过程需要同步
4. 线程协作

## 2 共享资源类

多个执行不同功能的线程共享数据可以利用外部静态变量实现

	/**
	 * 线程公用资源类
	 */
	class Resource{
		
		//锁对象，静态资源，可以被公开访问
		static Object lock = new Object();
		
		//包子容器，静态资源，可以被公开访问
		static List<String> container = new ArrayList<String>();
	}

这样在任何类中都可以利用`Resource.container.add("包子1")`操作一个容器。

## 3 线程协作实现

线程协作又叫做线程通信，即线程在执行过程中可以调度其他线程继续工作。

首先线程协作一定建立在**同步线程**的基础上，且依赖锁对象。简单点说就是，同步过程一定发生在`synchronized`代码块中，并利用此代码块的锁对象，实现在对所有等待此锁的线程对象的调度。

	/**
	 * 包子制作者
	 */
	class Producer implements Runnable{
	
		/**
		 * 制作包子过程
		 */
		@Override
		public void run() {
			//持有Resource.lock对象的才可执行以下过程，即执行线程在Resource.lock对象上同步。
			synchronized (Resource.lock) {
				//当制作完成12个包子，制作线程就要唤醒吃货线程来吃包子
				if (Resource.container.size() == 12) {
					Resource.lock.notifyAll();//唤醒所有在等待Resource.lock这把锁的线程
				}else{
					System.out.println("开始制作包子");
					//模拟耗时
					try {
						Thread.sleep(500);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					Resource.container.add("包子");
				}
			}
		}
		
	}

	class Cutstom implements Runnable {
	
		/**
		 * 吃包子过程
		 */
		@Override
		public void run() {
			
			//重复吃包子过程
			while (true) {
		
				//线程在Resource.lock上同步
				synchronized (Resource.lock) {
					
					//容器中没有包子了，吃货们就要等待包子	
					if (Resource.container.size() == 0) {
						
						System.out.println("包子吃光啦，老板上包子");
						try {
							Resource.lock.wait();//释放自己持有了锁，并开始等待被notify
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
	
					} else {
						System.out.println("吃货吃包子");
						//模拟耗时
						try {
							Thread.sleep(100);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						//移除吃过的包子
						Resource.container.remove(0);
					}
				}
			}
		}
	
	}

### notify()、notifyAll()与wait()

`notify()`,`notifyAll()`,`wait()`都是`Object`类中声明的方法，这几个方法都是当且仅当对象被当做`synchronized`锁对象时调用有效，并且只能在`synchronized`代码块中调用。

当锁对象调用`wait()`方法使得当前线程等待，直到另外一个同步线程在**相同锁对象**上调用`notify()`或者`notifyAll()`方法。

`notify()`唤醒在此锁对象上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是**任意性**的，并在对实现做出决定时发生。

`notifyAll()`唤醒在此锁对象上等待的所有线程。

# 总结

## 线程的生命周期

线程是一个动态执行的过程，它也有一个从产生到死亡的过程。

下图显示了一个线程完整的生命周期。

![](/public/img/Java8/thread/java-thread.jpg)

- 新建状态:

使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。

- 就绪状态:

当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。

- 运行状态:

如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。

- 阻塞状态:

如果一个线程执行了`sleep`（睡眠）、`suspend`（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：

等待阻塞：运行状态中的线程执行`wait()`方法，使线程进入到等待阻塞状态。

同步阻塞：线程在获取`synchronized`同步锁失败(因为同步锁被其他线程占用)。

其他阻塞：通过调用线程的`sleep()`或 发出I/O请求时(`Scanner`的`next()`方法，等待控制台录入)


- 死亡状态:

一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

## 多线程的实现

在Java中要想实现多线程，有两种手段:

- 继续Thread类。
- 实现Runable接口。

实现Runnable接口比继承Thread类所具有的优势：

1）适合多个相同的程序代码的线程去处理同一个资源

2）可以避免Java中的单继承的限制

3）增加程序的健壮性，过程可以被多个线程共用。

## 线程同步

线程同步就是多个线程可以在某一个过程排队执行，避免资源的争抢。同步某一段过程有两种方式：

- synchronized代码块
- synchronized方法

其中代码块的方式更为灵活，可以选择任意过程片段进行同步包装，还可利用锁对象来实现线程协作。

**注意：尽量避免同步的嵌套使用，如果场景需要嵌套同步，一定不要在嵌套中交叉使用锁对象。**

	package chapter13;
	public class DeadLockThread {
		
		private static Object lock1 = new Object();
		private static Object lock2 = new Object();
	
		public static void main(String[] args) {
			new Thread(new ShareThread1()).start();
			new Thread(new ShareThread2()).start();
		}
	
		private static class ShareThread1 implements Runnable {
			public void run() {
				synchronized (lock1) {
					System.out.println("Thread1获取到lock1，休息一会"  );
					try {
						Thread.sleep(50);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					System.out.println("尝试获取lock2锁");
					synchronized (lock2) {
						System.out.println("ShareThread1");
					}
				}
			}
		}
	
		private static class ShareThread2 implements Runnable {
			public void run() {
				synchronized (lock2) {
					System.out.println("Thread2获取到lock2休息一会");
					try {
						Thread.sleep(50);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					System.out.println("尝试获取lock1锁");
					synchronized (lock1) {
						System.out.println("ShareThread2");
					}
				}
			}
		}
	}

上述代码`ShareThread1`持有`lock1`等待`lock2`,而`ShareThread2`持有`lock2`等待`lock1`，构成死锁，双方都执行不下去。

## 线程协作

利用锁对象的`wait()`、`notify()`、`notifyAll()`实现在多个在相同锁上同步的线程相互调度。



